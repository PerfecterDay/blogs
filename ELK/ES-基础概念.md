## ES 基础概念
{docsify-updated}
> https://doc.codingdict.com/elasticsearch/1/

### 起源
Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库—​无论是开源还是私有。

但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。Lucene 非常 复杂。

Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。

然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：
+ 一个分布式的实时文档存储，每个字段 可以被索引与搜索
+ 一个分布式实时分析搜索引擎
+ 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据

Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端，甚至可以使用命令行（去充当这个客户端）。

### Near Realtime（NRT 近实时）
Elasticsearch 是一个近实时的搜索平台。这意味着从您索引一个文档开始直到它可以被查询时会有轻微的延迟时间（通常为一秒）。

### Cluster（集群）
cluster（集群）是一个或者多个节点的集合，它们一起保存数据并且提供所有节点联合索引以及搜索功能。集群存在一个唯一的名字身份且默认为 “elasticsearch”。这个名字非常重要，因为如果节点安装时通过它自己的名字加入到集群中的话，那么一个节点只能是一个集群中的一部分。

请确保您在不同环境中不要重复使用相同的集群名字，否则您可能最终会将节点加入到了错误的集群中。例如，您可以使用 logging-dev，logging-stage，以及 logging-prod 用于 development（开发），staging（演示）和 production（生产）集群。

注意，一个集群如果只有一个结点也是有效的，并且完全可行的。此外，您还可以有多个独立的集群并且每个集群都有它自己唯一的 cluster 

### Node（节点）
node（节点）是一个单独的服务器，它是集群的一部分，存储数据，参与集群中的索引和搜索功能。像一个集群一样，一个节点通过一个在它启动时默认分配的一个随机的 UUID（通用唯一标识符）名称来识别。如果您不想使用默认名称您也可自定义任何节点名称。这个名字是要识别网络中的服务器对应这在您的 Elasticsearch 集群节点管理的目的是很重要的。

节点可以通过配置 cluster name 来加入到指定的集群中。默认情况下，每个节点安装时都会加入到名为 elasticsearch 的集群中，这也就意味着如果您在网络中启动许多节点--假设它们可以发现彼此–它们全部将自动的构成并且加入到一个名为 elasticsearch 的单独的集群中。

在一个集群中，你需要多少就可以添加多少结点。此外，如果在当前网络中没有其它 elasticsearch 结点在运行，则启动一个结点将会默认形成一个叫 elasticsearch 的单结点集群。

### Index（索引）
index（索引）是具有稍微类似特征文档的集合。例如，您有一个消费者数据的索引，一个产品目录的索引，和另一个是订单数据的索引。一个索引通过名字（必须全部是小写）来标识，并且该名字在对 document（文档）执行 indexing（索引），search（搜索），update（更新）和 delete（删除）操作时会涉及到。

在一个单独的集群中，您可以定义您想要的许多索引。

### Document（文档）
在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。

也许有一天你想把这些对象存储在数据库中。使用关系型数据库的行和列存储，这相当于是把一个表现力丰富的对象塞到一个非常大的电子表格中：为了适应表结构，你必须设法将这个对象扁平化—​通常一个字段对应一列—​而且每次查询时又需要将其重新构造为对象。

Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档。Elasticsearch 不仅存储文档，而且 索引 每个文档的内容，使之可以被检索。在 Elasticsearch 中，我们对文档进行索引、检索、排序和过滤—​而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。

document（文档）是索引信息的基本单位。例如，您有一存储 customer（客户）数据的文档，另一个是存储 product（产品）数据的文档，还有一个是存储 order（订单）数据的文档。该文档可以使用 JSON 来表示，它是一种无处不在的互联网数据交换格式。

在索引中，您可以存储许多文档。注意，尽管一个文档物理的存在于索引中，实际上一个文档必须被 索引/分配 给索引内的类型。

### Shards & Replicas（分片 & 副本）
索引可以存储大量数据，可以超过单个节点的硬件限制。例如，十亿个文档占用了 1TB 的磁盘空间的单个索引可能不适合放在单个节点的磁盘上，并且从单个节点服务请求会变得很慢。

为了解决这个问题，Elasticsearch 提供了把 Index（索引）拆分到多个 Shard（分片）中的能力。在创建索引时，您可以简单的定义 Shard（分片）的数量。每个 Shard 本身就是一个 fully-functional（全功能的）和独立的 “Index（索引）”，（Shard）它可以存储在集群中的任何节点上。

Sharding（分片）非常重要两个理由是 : 

+ 水平的拆分/扩展。
+ 分布式和并行跨 Shard 操作（可能在多个节点），从而提高了性能/吞吐量。
Shard 的分布式机制以及它的文档是如何聚合支持搜索请求是完全由 Elasticsearch 管理的，并且是对用户透明的。

在 网络/云 环境中可能随时会故障，无论出于何种原因，在 shard/node 不知何故会离线或者消失的情况下强烈建议设置故障转移是非常有效的。为了达到这个目的，Elasticsearch 可以让您设置一个或多个索引的 Shard 副本到所谓的副本分片，或者副本中去。

副本非常重要的两个理由是 : 

在 shard/node 故障的情况下提供了高可用性。为了达到这个目的，需要注意的是在原始的/主 Shard 被复制时副本的 Shard 不会被分配到相同的节点上。
它可以让你水平扩展搜索量/吞吐量，因为搜索可以在所有的副本上并行执行。
总而言之，每个索引可以被拆分成多个分片，一个索引可以设置 0 个（没有副本）或多个副本。开启副本后，每个索引将有主分片（被复制的原始分片）和副本分片（主分片的副本）。分片和副本的数量在索引被创建时都能够被指定。在创建索引后，您也可以在任何时候动态的改变副本的数量，但是不能够改变分片数量。

默认情况下，Elasticsearch 中的每个索引分配了 5 个主分片和 1 个副本，这也就意味着如果您的集群至少有两个节点的话，您的索引将会有 5 个主分片和另外 5 个副本分片（1 个完整的副本），每个索引共计 10 个分片。

注意 :

每个 Elasticsearch 分片是一个 Lucene 索引。在单个 Lucene 索引中有一个最大的文档数量限制。从 [LUCENE-5843](https://issues.apache.org/jira/browse/LUCENE-5843) 的时候开始，该限制为 **2,147,483,519**（=**Interger.MAX_VALUE** - **128**）个文档。您可以使用 [_cat/shards](https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html "cat shards") **api** 来监控分片大小。