# TCP 协议
{docsify-updated}


#### TCP服务概述
TCP提供一种面向连接的、可靠的字节流服务。
面向连接意味着两个使用TCP的应用在彼此交换数据之前必须先建立一个TCP连接
TCP通过下列方式来提供可靠性：

      1. 应用数据被分割成TCP认为最适合发送的数据块，对比UDP，UDP不会处理应用程序产生的数据报。
      2. 确认机制：接收方收到一个报文段后会向发送方发送一个确认，告诉对方收到了报文段。
      3. 超时重传：TCP发出一个报文段后，启动一个定时器，如果在超时之前没有收到接收方的确认，将会重发这个报文段。
      4. 校验机制：TCP将保持它首部和数据的检验和。如果收到段的检验和有差错，TCP将丢弃这个报文段，也不确认收到此报文段（希望发端超时并重发）
      5. 保证有序：IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序，如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
      6. 保证无重复：IP数据报会发生重复， TCP的接收端会丢弃重复的数据。
      7. 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

#### TCP首部
<center><img src="pics/tcp.png" alt="" width=40%></center>

+ URG：紧急指针有效
+ ACK：确认序号有效。
+ PSH：接收方应该尽快将这个报文段交给应用层。
+ RST：重建连接。
+ SYN：同步序号用来发起一个连接。
+ FIN：发送端完成发送任务。

#### TCP连接的建立与关闭（三次握手与四次挥手）
<center><img src="pics/tcp_open_close.png" alt="" width=40%></center>

##### 三次握手建立连接

1. 请求端（通常称为客户）发送一个 SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，在这个例子中为1415531521）。这个SYN段为报文段1。
2. 服务器发回包含服务器的初始序号的 SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。
3.  客户必须将确认序号设置为服务器的 ISN加1以对服务器的SYN报文段进行确认（报文段3）。

##### 四次挥手断开连接

1. 首先进行关闭的一方发送第一个 FIN执行主动关闭，而另一方（收到这个 FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭（也可以双方都执行主动关闭）。
2. 当服务器收到这个 FIN，它发回一个ACK，确认序号为收到的序号加 1（报文段5）。和SYN一样，一个FIN将占用一个序号。同时 TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。
3. 接着这个服务器程序就关闭它的连接，导致它的 TCP端发送一个FIN（报文段6），客户必须发回一个确认，并将确认序号设置为收到序号加1（报文段7）。

#### TCP半关闭
TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。

#### TCP状态变迁
<center><img src="pics/tcp-status.png" alt="" height=40%></center>

##### 2MSL等待状态

TIME_WAIT 状态也称为 2MSL 等待状态。每个具体 TCP实现必须选择一个报文段最大生存时间MSL(Maximum Segment Lifetime) 。它是任何报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为 TCP 报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的 TTL字段。RFC 793 指出MSL为2分钟。然而，实现中的常用值是30秒，1分钟，或2分钟。

当 TCP 执行一个主动关闭，并发回最后一个ACK，该连接必须在 TIME_WAIT 状态停留的时间为 2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的 FIN）。

这种2MSL 等待的另一个结果是这个 TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的 IP地址和端口号）不能再被使用。这个连接只能在 2MSL结束后才能再被使用。大多数 TCP实现（如伯克利版）强加了更为严格的限制。在 2MSL等待期间，插口中使用的本地端口在默认情况下不能再被使用。