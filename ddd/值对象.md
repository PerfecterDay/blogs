#值对象
{docsify-updated}

- [值对象](#值对象)
	- [度量或描述](#度量或描述)
	- [不变性](#不变性)
	- [概念整体](#概念整体)
	- [可替换性](#可替换性)
	- [相等性比较](#相等性比较)
	- [无副作用行为](#无副作用行为)
	- [实现](#实现)


当你决定一个领域概念是否是一个值对象时，你需要考虑它是否拥有以下特征：
+ 它度量或者描述了领域中的一件东西。
+ 它可以作为不变量。
+ 它将不同的相关的属性组合成一个概念整体 (conceptual Whole) 。
+ 当度量和描述改变时，可以用另一个值对象予以替换。
+ 它可以和其他值对象进行相等性比较。
+ 它不会对协作对象造成副作用

在使用这种方法分析模型时，你会发现很多领域概念都可以设计成值对象，而不是你先前认为的实体对象。

### 度量或描述
当你的模型中的确存在一个值对象时，不管你是否意识到，它都不应该成为你领域中的一件东西，而只是用于度量或描述领域中某件东西的一个概念。一个人拥有年龄，这里的年龄并不是一个实在的东西，而只是作为你出生了多少年的一种度量。一个人拥有名字，同样这里的名字也不是一个实在的东西，而是描述了如何称呼这个人。该特征和下面的“概念整体"特征是紧密联系在一起的。

### 不变性
一个值对象在创建之后便不能改变了。

### 概念整体
一个值对象可以只处理单个属性，也可以处理一组相关联的属性。在这组相关联的属性中，每一个属性都是整体属性所不可或缺的组成部分，这和简单地将一组属性组装在对象中是不同的。如果一组属性联合起来并不能表达一个整体上的概念，那么这种联合并无多大用处。

### 可替换性
```
Fullname name = new Fullname("Vaughn","Vernon");
//稍后
name = new Fullname("Vaughn","L","Vernon");
```
首先， name 通过 firstName 和 lastName 进行初始化，随后 name 变量被替换成了另一个 FullName 值对象实例，该实例中包含了 firstName 、 middleName 和lastNameo 这里，我们并没有使用 FullName 的某个方法来改变其自身的状态，因为这样破坏了值对象的不变性。我们使用了简单的替换将另一个 FullName 实例的引用重新赋给了 name 变量。

### 相等性比较
在比较两个值对象例时，我们需要检查这两个值对象的相等性。在整个系统中，有可能存在很多相等的值对象实例，但它们并不表示相同的实例引用。相等性通过比较两个对象的类型和属性来决定。如果两个对象的类型和属性都相等，那么这两个对象也是相等的。进而，如果两个或多个值对象实例是相等的，我们便可以用其中一个实例来替换另一个实例。

### 无副作用行为
一个对象的方法可以设计成一个无副作用函数。 这里的函数表示对某个对象的操作，它只用于产生输出，而不会修改对象的状态。由于在函数执行的过程中没有状态改变，这样的函数操作也称为无副作用函数。

对于不变的值对象而言，所有的方法都必须是无副作用函数，因为它们不能破坏值对象的不变性。你可以将这种特性看作是不变性的一部分，但是我更倾向于将该特性从不变性中分离出来，因为这样做可以强调出值对象的一大好处。否则，我们可能只会将值对象看成一个属性容器，而忽略了值对象模式的一个功能强大的特性一一无副作用函数。

### 实现
通常来说，我至少都会为值对象创建两个构造函数。第一个构造函数接受用于构建对象状态的所有属性参数，它是主要的构造函数。该构造函数首先初始化默认的对象状态，对于基本属性的初始化通过调用私有的 setter 方法实现。该私有的 setter 方法向我们展示了一种自委派性，这是我所推荐的。

第二个构造函数用于将一个值对象复制到另一个新的值对象，即复制构造函数。该构造函数采用浅复制 (Shallow copy) 的方式，因为它也是将构造过程委派给主构造函数的，先从原对象中取出各个属性值，再将这些属性值作为参数传给主构造数。当然，我们也可以采用深复制（ Deep copy) 或者克隆 (clone) 的方式，即为每个所引用的属性都创建一份其自身的备份。然而，这种方式既复杂，也没有必要。当需要深度复制时，我们才考虑添加该功能。但是对于不变的值对象来说，在不同的实例间共享属性是不会出现什么问题的。