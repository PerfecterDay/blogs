#领域子域和限界上下文
{docsify-updated}

- [领域子域和限界上下文](#领域子域和限界上下文)
	- [六边形架构](#六边形架构)
	- [CQRS](#cqrs)


<center><img src="pics/ddd-1.jpg" width="50%"></center>
<center><img src="pics/ddd-2.jpg" width="50%"></center>

通常，我们希望将子域一对一地对应到限界上下文。这种做法显式地将领域模型分离到不同的业务板块中，并将问题空间和解决方案空间融合在一起。在实践中，这种做法并不总是可能的，但通过新的努力，我们是可以做到这一点的。让我们虑一个遗留系统，它有可能是个大泥球，其中子域和限界上下文存在相交的地方，就像图 2.1 中所示一样。我们可以在概念上使用两个或者多个子域来分解限界上一下文，或者将多个限界上下文包含在同一个子域中。


### 六边形架构
<center><img src="pics/ddd-4.png" width="50%"></center>


### CQRS

那么，有没有一种完全不同的方法可以将领域数据映射到界面显示中呢？答案是 CQRS (Cammand-Query Responsibility Segregation) [Dahan, CQRS;№ CQRSIO CQRS 是将紧缩 (stringent) 对象（或者组件）设计原则和命令·查询分离 (CQS ）应用在架构模式中的结果。


现在，对于同一个模型，考虑将那些纯粹的查洵功能从命令功能中分离出来。聚合将不再有查询方法，而只有命令方法。资源库也将变成只有 add() 或 save() 方法（分别支持创建和更新操作），同时只有一个查询方法，比如「 romld() 。这个唯一的查询方法将聚合的身份标识作为参数，然后返回该聚合实例。资源库不能使用其他方法来查询聚合，比如对属性进行过滤等。在将所有查询方法移除之后，我们将此时的模型称为命令模型 (command Model) 。但是我们仍然需要向用户显示数据，为此我们将创建第二个模型，该模型专门用于优化查询，我们称之为查询模型(Query ModeI) 。

如果客户端可以处理数据库结果集（比如 JDBC) ，此时我们可能不需要对查询结果进行序列化，但我依然建议使用。这里存在两种不同的观点。一种观点是客户直接处理结果集，或者是一些非常基本的序列化数据，比如 XML 和 JSONO 另一种观点认为应该将返回数据转换成 DTO 让客户端处理。这可能只是一个偏好问题，但是任何时候我们引人 DTO 和 DTO 组装器 (DTO A ssembler)，系统的复杂性都会随之增加。因此，每个团队应该选择最适合自身的方法。