# PromQL 操作符
{docsify-updated}


## 二进制运算符

### 算数擦作符
+ `+`: 加
+ `-`: 减
+ `*`: 乘
+ `/`: 除
+ `%`: 取余
+ `^`: 乘方

在两个标量之间，行为是显而易见的：它们会求值到另一个标量，该标量是运算符应用于两个标量操作数的结果。 

在一个瞬时向量和一个标量之间，运算符应用于向量中每个数据样本的值，例如，如果时间序列瞬时向量乘以 2，结果是另一个向量，其中原始向量的每个样本值都乘以 2。 例如，如果一个时间序列瞬时向量乘以 2，结果就是另一个向量，其中原始向量的每个样本值都乘以 2。 

在两个瞬时向量之间，一个二进制算术运算符会应用到左侧向量中的每个条目和右侧向量中的匹配元素。 结果传播到结果向量中，分组标签成为输出标签集。 度量名称将被删除。 在右侧向量中找不到匹配项的条目不在结果中。

### 三角函数
`atan2`

三角运算符允许使用向量匹配在两个向量上执行三角函数，这是普通函数所不具备的。 它们的作用方式与算术运算符相同。

### 比较运算符
+ `==`: 等于
+ `!=`: 不等于
+ `> `: 大于
+ `< `: 小于
+ `>=`: 大于等于
+ `<=`: 小于等于

比较运算符是在标量/标量、向量/标量和向量/向量值对之间定义的。 默认情况下，它们会过滤。 可以通过在运算符后面提供 bool 来修改它们的行为，这会返回值为 0 或 1，而不是过滤。

在两个标量之间，必须提供 bool 修饰符，根据比较结果，这些运算符会产生另一个 0（假）或 1（真）的标量。 

在瞬时向量和标量之间，这些运算符会应用于向量中每个数据样本的值，比较结果为假的向量元素会从结果向量中删除。 如果提供了 bool 修饰符，则被放弃的向量元素的值为 0，被保留的向量元素的值为 1。 如果提供了 bool 修饰符，则会放弃度量名称。

在两个瞬时向量之间，这些运算符默认作为过滤器，应用于匹配项。 表达式为非 true 的向量元素或在表达式另一端找不到匹配项的向量元素会从结果中删除，而其他元素会传播到结果向量中，分组标签成为输出标签集。 如果提供了 bool 修饰符，则原本会被剔除的向量元素的值为 0，而保留的向量元素的值为 1，分组标签再次成为输出标签集。 如果提供了 bool 修饰符，则度量名称将被删除。

### 逻辑/集合运算符
+ `and` (intersection)
+ `or` (union)
+ `unless` (complement)

## 向量匹配

## 聚合运算符
+ sum (求和)
+ min (最小值)
+ max (最大值)
+ avg (平均值)
+ stddev (标准差)
+ stdvar (标准差异)
+ count (计数)
+ count_values (对value进行计数)
+ bottomk (后n条时序)
+ topk (前n条时序)
+ quantile (分布统计)

```
# 查询系统所有http请求的总量
sum(http_request_total)

# 按照mode计算主机CPU的平均使用时间
avg(node_cpu) by (mode)

# 按照主机查询各个主机的CPU使用率
sum(sum(irate(node_cpu{mode!='idle'}[5m]))  / sum(irate(node_cpu[5m]))) by (instance)
```