# git 核心概念
{docsify-updated}

- [git 核心概念](#git-核心概念)
    - [提交commit快照](#提交commit快照)
  - [Git 分支](#git-分支)
      - [分支合并](#分支合并)
      - [远程分支和跟踪分支](#远程分支和跟踪分支)
      - [变基 Rebase](#变基-rebase)
  - [重置与检出](#重置与检出)
  - [底层原理](#底层原理)
    - [Blob对象](#blob对象)
      - [Git 中存入内容](#git-中存入内容)
      - [查看存入 Git 的内容](#查看存入-git-的内容)
    - [树对象](#树对象)
    - [提交对象](#提交对象)
    - [引用日志reflog](#引用日志reflog)

### 提交commit快照
Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待 数据更像是一个快照流。
<center>
<img src="pics/git-snapshot.png" alt="" width=40% height=60% >
</center>

Git 一次提交大概的数据结构如下图所示：
<center>
<img src="pics/git-commit.png" alt="" width=40% height=60% >
</center>

做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针：
<center>
<img src="pics/commit-list.png" alt="" width=40% height=60% >
</center>

Git 拥有三个阶段：工作区、暂存区（索引）及 Git 目录。
+ 工作区：工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上
供你使用或修改。就是相当于从版本库中提取出一个快照到磁盘上以作修改
+ 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。
+ Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。

工作目录下的每一个文件都不外乎这两种状态：
+ **已跟踪**  
  已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改（已提交），已修改或已放入暂存区。
+ **未跟踪**

## Git 分支
Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。Git 允许创建多个分支，而且极其高效和方便，因为仅仅是创建了一个指针。

Git 又是怎么知道当前在哪一个分支上呢？也很简单，它有一个名为 HEAD 的特殊指针，指向当前所在的本地分支。
<center>
<img src="pics/branch.png" alt="" width=40% height=60% >
</center>

分支的切换其实就是让 HEAD 指针指向不同的分支。

#### 分支合并
当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。

如果两个分支从一个共同祖先处开始分叉开来，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。
<center>
<img src="pics/three-merge.png" alt="" width=40% height=60% >
</center>

三方合并的结果：
<center>
<img src="pics/three-merge-result.png" alt="" width=40% height=60% >
</center>

有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。Git 会暂停下来，等待你去解决合并产生的冲突。Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：
```
    <<<<<<< HEAD:index.html
    <div id="footer">contact : email.support@github.com</div>
    =======
    <div id="footer">
     please contact us at support@github.com
    </div>
    >>>>>>> iss53:index.html
```
这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。修改完文件内容后，使用 `git add filename` 将文件加入暂存区。

#### 远程分支和跟踪分支
远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信(使用 git fetch/ git pull 之类的命令时)， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签，这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。它们以 `<remote>/<branch>` 的形式命名。

从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支，如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。

设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 `-u 或 --set-upstream-to` 选项运行 `git branch` 来显式地设置：
`git branch -u origin/serverfix`

#### 变基 Rebase
它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。  
无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。

## 重置与检出
Git 的三个工作区间可以想像成三棵树， reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止:
1. 移动 HEAD 分支的指向 (若指定了 --soft，则到此停止) ：`git reset --soft HEAD~`
2. 使索引看起来像 HEAD (若未指定 --hard，则到此停止) : `git reset [--mixed] HEAD~`
3. 使工作目录看起来像索引 : `git reset --hard HEAD~`

<center>   
<img src="pics/git-reset.png" alt="" width=40% height=60%>
</center>

git reset 后边加上文件或目录路径时，reset 将会跳过第一步，并且将它的作用范围限定为指定的文件或文件集合。  
`git reset eb43bf file.txt`: 将提交为 eb43bf 中的 file.txt 文件版本恢复到索引


下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引 用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命 令之前请考虑一下。
<center>
<img src="pics/git-reset-checkout.png" alt="" width=60% height=60%>
</center>

## 底层原理
Git 是一个内容寻址文件系统，听起来很酷。但这是什么意思呢? 这意味着，Git 的核心部分是一个简单的键值对数据库(key-value data store)。 你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。

### Blob对象
#### Git 中存入内容
可以通过底层命令`git hash-object`来演示上述效果——该命令可将任意数据保存于`.git/objects`目录 (即对象数据库)，并返回指向该数据对象的唯一的键。`git hash-object`会接受你传给它的东西，而它只会返回可以存储在Git仓库中的唯 一键。 -w 选项会指示该命令不要只返回键，还要将该对象写入数据库中。上述类型的对象我们称之为数据对象(blob object)

#### 查看存入 Git 的内容
1. `git cat-file -p <hash>` 命令从 Git 那里取回数据， -p 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：   
    `git cat-file -p 257fa7137cae7c6a3bab82d371be6007a491cd1e`  
2. `git cat-file -t <hash>` 命令，可以让Git告诉我们其内部存储的任何对象类型，只要给定该对象 的 SHA-1 值:
    `git cat-file -p 257fa7137cae7c6a3bab82d371be6007a491cd1e`

### 树对象
树对象(tree object)能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录(tree entry)，每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针， 以及相应的模式、类型、文件名信息。

`git cat-file -p master^{tree}`: 查看树对象，`master^{tree}` 语法表示 master 分支上最新的提交所指向的树对象

通常，Git 根据某一时刻暂存区(即 index 区域，下同)所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录(某个时间段内)一系列的树对象。首先，需要通过暂存一些文件来创建一个暂存区。然后，可以通过 `git write-tree` 命令将暂存区内容写入一个树对象。

### 提交对象
每个tree对象分别代表我们想要跟踪的不同项目快照。 然而问题依旧:若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象(commit object)能为你保存的基 本信息。
可以通过调用 `git commit-tree` 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父 提交对象(如果有的话) 。


### 引用日志reflog
当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。

你可以使用 git reflog 来查看引用日志，每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。

值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操
作。 git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交——如果你刚刚克隆了仓库，那么它将不会有任何结果返回。