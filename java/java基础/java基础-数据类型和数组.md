# 入门，数据类型和数组
{docsify-updated}

- [入门，数据类型和数组](#入门数据类型和数组)
  - [基本规则](#基本规则)
  - [Java 数据类型](#java-数据类型)
      - [基本类型](#基本类型)
      - [引用类型](#引用类型)
      - [直接量](#直接量)
    - [基本类型的类型转换](#基本类型的类型转换)
      - [自动类型转换](#自动类型转换)
      - [强制类型转换](#强制类型转换)
      - [表达式类型的自动提升](#表达式类型的自动提升)
      - [实例分析](#实例分析)
  - [字符串](#字符串)
      - [常用方法](#常用方法)
      - [StringBuilder](#stringbuilder)
  - [数组](#数组)
    - [数组的初始化](#数组的初始化)
    - [数组的遍历](#数组的遍历)
    - [Arrays数组工具类](#arrays数组工具类)
  - [运算符](#运算符)
    - [运算符的结合性和优先级](#运算符的结合性和优先级)

## 基本规则
0. Java是一种纯粹的面向对象语言，**所有的程序部分必须放在类中定义，类是Java程序的最小单位，Java不允许任何可执行语句、方法等独立存在（Lambda除外）**。
1. Java中定义类名的规则很宽松。名字必须**以字母开头，后面可以跟字母和数字的任意组合**。长度基本上没有限制。但是不能使用Java保留字。
2. 通常情况下，java 程序源文件名是任意的，除非源文件中定义了一个 public 类，此时，**源文件名必须与该 public 类的类名完全相同（包括大小写）**，且源文件的后缀名必须是 .java ,不能是其他文件后缀。
3. 一个源文件中可以有多个类，但是因为上面第2条**只能有一个 public 的类**，好的建议是一个文件只定义一个类，文件名与类名保持一致。
4. java程序是**严格区分大小写**的。
5. 标识符可以由**字母、下划线、美元符号和数字组成，数字不打头**，标识符不能是 java 关键字或保留字且不能包含空格。

## Java 数据类型
两大类： **基本类型** 和 **引用类型**。
<center><img src="pics/java_numberic_data.png" alt="" width=40%></center>

#### 基本类型
基本类型包括 **boolean 类型** 和 **数值类型** 。

boolean 类型只有两个直接量值： true 、 false 。

数值类型包括整数类型和浮点数类型。

**整数类型**包括： byte 、 short 、 int 、 long 、 char 。

**浮点数类型**包括： float 和 double 。

#### 引用类型
**引用类型**包括类、接口、数组和特殊的 null 。 null 是引用类型的一个直接量。

在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。
+ 强引用  
  是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
+ 软引用  
  是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。
+ 弱引用  
  也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
+ 虚引用  
  也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。


#### 直接量
并不是所有的类型都可以指定直接量，能指定直接量的只有三种类型：基本类型、字符串类型 和 null 引用。具体而言， Java 支持以下8中类型的直接量：
1. int 类型的直接量：在程序中直接给出的整数类型数值，可分为二进制、十进制、八进制和十六进制4种，二进制以 0B 或 0b 开头，八进制以 0 开头，十六进制以 0x 或 0X 开头。
2. long 类型的直接量： 在整型值后边添加L(小l极度不推荐)后就变成了 long 类型的直接量。
3. double 类型的直接量：直接给出一个标准小数形式或者科学计数法形式的浮点数就是 double 类型额直接量。
4. float 类型的直接量：在一个浮点数后加f或F就变成了 float 类型。
5. boolean 类型直接量： true 、false。
6. char 类型直接量： char 类型的直接量有三种形式，分别是单引号括起来的字符、转义字符和 Unicode 值表示的字符。如 'a' 、 '\n' 和 '\u0061'。
7. String 类型直接量： 一个用双引号括起来的字符序列就是 String 类型直接量。
8. null ：可以赋值给任意引用类型。

### 基本类型的类型转换
Java 的7种数值类型可以相互转换，有两种转换方式：自动转换和强制类型转换。

#### 自动类型转换
Java 所有的数值类型变量可以相互转换，Java 系统支持把某种数据类型的值直接赋值给另一种类型的变量，这种方式称为自动类型转换。
1. 当把一个表数范围小类型的变量或数值赋值给另一个表数范围大的变量时，系统可以自动进行类型转换，否则就需要强制类型转换。
<center><img src="pics/auto-change.jpg" alt="" width=50%></center>

1. 当把任何基本类型的值和字符串进行连接运算时，基本类型的值将自动转换为字符串类型。

#### 强制类型转换
如果希望把上图中箭头右边的类型转换为左边的类型，则必须进行强制类型转换，强制类型转换额语法是：`(TargetType) value` ，强制类型转换的运算符是（ () ）。强制类型转换会造成精度丢失，被称为“缩小转换”。

#### 表达式类型的自动提升
当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升。Java定义了如下提升规则：
1. 所有的 byte 、 short 和 char 类型将自动被提升为 int 类型。
2. 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数（表数范围最大）同样的类型。

#### 实例分析
```
calss test
{
    public static void main(string[] args)
    {
        short s=1; //等价于 short s=(short) 1
        s=s+1; //编译出错，s+1会提升为 int 类型
        s+=1; //等价于 s=(short) (s+1)
        s++; //等价于 s=(short)(s+1)
        system.out.println(s);
    }
}
```
对于这段代码，编译肯定无法通过的，原因是什么？原因就是s=s+1会出错，这是很久之前很常见的一个面试题，这么多年过去了，解答的套路都固定了，让我们看看从java的创造者视角看这个问题是怎么样的？引用资料java语言规范（JLS）

1.JLS（中文版第三版）5.2 赋值转换

 1. 当把表达式的值赋予一个变量时，就会发生赋值转换：必须把表达式的类型转换为变量的类型；
 2. 如果表达式(=号右边部分)是类型byte，short，char，int的常量表达式，则如果变量类型是byte，short，char，并且常量表达式的值在变量的类型中是可以表示的，那么就执行窄化转换（narrowing conversion），如果不能通过赋值环境中允许的转换把表达式的类型转换成变量的类型，那么编译时会报错。这个可以用来**解释s=1，为何将int赋值给short不会报错**。
 3. `s=s+1`为什么会报错？这里我没有看JLS，因为`s=s+1`，左边有变量参与，编译器在无法分析出该变量的值是什么，因为s为变量，其值不确定无法确定s+1是否超出short范围，为了防止进行类型转换时丢失精度，所以编译器直接当成无法确定来处理，报错了事。so，当有变量为byte，short，char时，编译器就是这么干的。需要知道的是在编译期间，编译器只做语法检查，而不会进行计算动作，也就是说编译器不会对`s+1`是否查出s的范围而进行一次计算判断。
 4. `s++`呢？如有必要将`s+1`的和进行窄化转换，即将`s+1`做强制转换`（short）（s+1）`然后赋给s。（JLS中文三版15.15.1）
 5. 最后s+=1，JLS中文三版15.26.2说对于组合运算符形如`E1 op=E2`的组合赋值表达式等价于`E1=（E1）（（E1）op（E2））`，例如`s+=1`等价于`s=(short)(s+1)`。


## 字符串
想要在计算机中表示一个字符/字符串，需要两个条件：
1. 将字符符号（也可以是非显示字符，比如一些控制字符）映射到一个数字
2. 用字节将映射的数字编码表示出来

一个**代码点（Code Point）**就是一个字符符号映射到的数字。ASCII 和 UNICODE 就是两种著名的标准。其中的每个数字就是编码标准中的一个代码点。
**代码单元(code unit)**就是用实际的字节来编码代码点以存储传输字符，一个代码点需要一个或多个代码单元来编码。代码单元其实说的是编码的基本编码单位（8字节/16字节/32字节）。
举个例子来说，UTF-8 以8字节代码单元作为基本编码单位，UTF-16以16字节为编码单位

Java 使用 UTF-16 编码来表示一个 UNICODE　字符，字符串就是字符序列。

Java　字符串是不可变的，字符串类没有提供修改字符串的方法。也就是说字符串对象一旦初始化，就不能在改变。举个例子：
```java
String hello = "Hello"; // Hello 永远只包含 H,e,l,l,o 五个字符，不能修改其中任何一个字符
```
作为对照，在 C/C++中：
```C
char[] hello = "Hello";
hello[3] = 'x'; //可以修改字符串
```

#### 常用方法
1. `String substring(int fromIndex,int endIndex)`: 提取字符串子串 [fromIndex,endIndex) ，返回一个新的字符串
2. `int length()`: 获取字符串长度
3. `boolean equals(Object other)`:判断两个字符串是否相同
4. `boolean equalsIgnoreCase(String other)`:判断两个字符串是否相同，忽略大小写
5. `char charAt(int index)`:返回指定位置的代码单元
6. `int indexOf(String s)`:返回与s匹配的第一个子串的位置
7. `String replace(CharSequence target, CharSequence replacement)`:将字符串中的 target 替换为 replacement，返回一个新的字符串
9. `String toUpperCase(int,int)`: 小写字母转大写，返回一个新的字符串
8. `String toLowerCase(int,int)`: 大写字母转小写，返回一个新的字符串
10. `String trim(int,int)`: 去除字符串首尾的空格，返回一个新的字符串

#### StringBuilder
如果需要频繁的对短字符串进行拼接以构成长的字符串，应该使用 StringBuilder 类而不要是用 "+" 操作。这样可以避免大量构造字符串对象，提高效率。
常用方法：
1.  `int length()`: 获取字符串长度
2.  `StringBuilder append(String str)`: 追加一个字符串并返回 this
3.  `String toString()`: 返回一个字符串

## 数组
Java数组要求所有数组元素具有相同的类型。Java 数组是一种引用类型。一旦数组的初始化完成，数组在内存中所占的内存空间就被固定下来了，数组的长度将不会改变，所以在初始化数组时一定要指定数组的长度（可以显式指定或者隐式指定）。Java数组的长度存储在length属性中。

### 数组的初始化
+ 静态初始化：初始化时由程序员显示指定每个元素的初始值，由系统决定长度。 ``arr = {element1,element2,element3....}``; 此外，静态初始化还可以直接在定义时完成： ``type[] arr={element1,element2,element3....}``
```
int[] arr = {1,2,3}
```
+ 动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。 ``arr = new int[10]`` 或者 ``type[] arr= new type[length]`` ; 系统根据 type 类型，自动初始化数组。
```
int[] arr = new int[10]
```

### 数组的遍历
```
for (int i = 0; i < nums.length; i++) {
    count += nums[i];
}
```

foreach访问数组:Java 5之后提供的语法糖，使得访问数组更加方便，不需要使用数组下标索引即可访问数组。
```
for(type var: array | collection){
    var //自动访问每个元素
}
```
如果想要改变数组中每个元素的值，使用var并不能保证，此处的var是一个局部变量。还是要用 ``arr[index]=value`` 的方式为数组元素赋值。

### Arrays数组工具类
+ `int binarySearch(type[] arr, type key)` : 使用二分查找在数组arr中查找值为key的元素的索引。如果不存在值为key的元素，返回负数。要求arr数组已经按升序排列。
+ `int binarySearch(type[] arr, int from, int end, type key)` : 这个方法与前一个方法类似，但是它只搜索数组中 [from, end] 索引的元素。
+ `tyep[] copyOf(type[] arr, int len)` : 这个方法会把 arr 数组复制成一个长度为 len 的新数组。如果 len 比 arr 的长度小，则只复制 arr 前 len 个元素，如果比 arr 长度大，则后边的元素初始化为0（整型）、0.0（浮点型）、false（布尔型）、null（引用型）。
+ `tyep[] copyOfRange(type[] arr, int from, int to)` :这个方法与前一个方法类似，但这个方法只复制 arr 数组的 [from,to] 部分。
+ `boolean equals(tyape[] a, type[] b)` : 如果 a, b长度相等且每个数组的元素一一相同（==），返回 true。
+ `void fill(tyape[] a, type value)` : 将 a 的所有元素赋值为 value。
+ `void fill(tyape[] a,int from,int end, type value)` : 将a中索引处于[from,end]的元素全部赋值为 value。
+ `void sort(type[] a)` : 将数组 a 排序。
+ `void sort(type[] a,int from,int end)` : 将数组 a 中[from,end]处的元素排序。
+ `String toString(type[] a)` : 将数组转换成字符串，用逗号连接各个元素。

Java 8 中新增的方法：
+ `void parallelPrefix(type[] a, typeBinaryOperator op)` : 利用 op 参数中的计算方法重新计算数组中每个元素的值，op 计算方法包含 left和right两个参数，right指向当前计算元素的索引，left指向right的前一个，第一个元素时，left值为1 。
+ `void parallelPrefix(type[] a,int from, int to, typeBinaryOperator op)` : 与上个方法类似，但仅计算[from，to]索引处的值。
+ `void setAll(type[] a, IntToTypeFunction generator)` : 使用指定生成器 generator 为所有元素赋值，generator控制元素值的生成算法。
+ `void parallelSetAll(type[] a, IntToTypeFunction generator)` : 同上，但是增加了并行能力。
+ `void parallelSort(type[] a)` : 与 sort 方法类似，只是增加了并行能力。
+ `void parallelSort(type[] a, int from,int end)` : 与上面方法类似，只排序[from,end]处的元素排序。
+ `Spliterator<T> spliterator(T[] array)` : 将数组转换成 Spliterator 对象。
+ `Spliterator<T> spliterator(T[] array, int startInclusive, int endExclusive)` : 同上，值转换[startInclusive,endExclusive]的元素。
+ `Stream<T> stream(T[] array)` : 将数组转换成 Stream 。
+ `Stream<T> stream(T[] array，int startInclusive, int endExclusive)` : 同上。

## 运算符
1. 算术运算符：
   1. 加（+）：加法运算，还可以作为字符串连接运算符。
   2. 减（-）：减法运算。
   3. 乘（*）：乘法运算。
   4. 除（/）：除法运算，如果除法运算的两个操作数都是整数，则计算结果也是整数，小数部分被截断。且这时候除数不能是0，否则会引发除以零异常。但是如果两个操作数有一个是浮点数或者两个都是浮点数，则计算结果也是浮点数。而且这时候允许除数是0或者0.0，得到结果是正无穷大（Infinity）或者负无穷大（-Infinity）   
   5. 取余（%）：求余运算符，结果并不一定是整数。当操作数是浮点数时，结果可能为浮点数。 `System.out.println(5.2%3.1) //2.1`
   6. 自增（++）：将操作数加1，单目运算符，只能操作单个数值类型的变量，不能操作常量或者表达式。既可以放在操作数左边也可以放在右边，放在左边时，会先将变量加1然后再把操作数放入表达式中运算；放在右边时，会先将变量放入表达式中运算，然后将变量加1。
        ```
        int a = 5;
        a++ + 6; // 11
        a = 5;
        ++a + 6; // 12
        ```
    7. 自减（--）：将操作数减1。与自增运算符类似。
2. 赋值运算符（=）：将一个变量或者直接量值赋值给一个变量。赋值表达式是有值的，值就是表达式右边被赋的值。
3. 位运算符
   1. 按位与（&）：当操作数的两个比特位为1时返回1。
   2. 按位或（|）：当操作数两个位只要有一个是1就返回1。
   3. 按位非（~）：单目运算符，将操作数的每个位（包括符号位）全部取反。
   4. 异或（^）：当操作数两个比特位不同时返回1。
   5. 左移（<<）：左移运算符，把操作数的二进制比特位往左移指定位，右边空出来的以0填充
   6. 右移（>>）：右移运算符，把操作数的二进制比特位往右移指定位，左边空出来的以原来的符号位填充。
   7. 无符号右移（>>>）：无符号右移，与右移运算符类似，但是空出来的位用0填充。
4. 关系运算符  
   用来判断两个变量或者常量的大小，比较运算的结果是 true 或 false 。 
   1. 大于（>）:只支持数值类型，左边的值大于右边时返回 true 。
   2. 大于等于（>=）：只支持数值类型，左边的值大于或等于右边时返回 true 。
   3. 小于（<）：只支持数值类型，左边的值小于右边时返回 true 。
   4. 小于等于（<=）：只支持数值类型，左边的值小于或等于右边时返回 true 。
   5. 等于（==）：支持基本类型和引用类型。比较两个数值类型时，只要相等就返回 true ,比较引用类型时，两个引用类型必须相同或者是父子类型，只有两个引用指向同一个对象时返回true ；还可以比较布尔类型，只有两个布尔值形同时才返回 true， true == true 返回 true, false == false 返回 true 。
   6. 不等于（!=）: 与 == 运算符类似。
5. 逻辑运算符  
   逻辑运算符用来对布尔类型的变量或表达式进行运算。
   1. 与（&&）：短路与，前后两个操作数都是 true ，才返回 true 。且当某个表达式为 false 时会立即返回 false ，后边的表达式不会执行。
   2. 与（&）：不短路与，与短路与（&&）相同，但不会短路。
   3. 或（||）：短路非，两个操作数有一个为 true ，就返回 true 。且当某个表达式为 true 时会立即返回 true ，后边的表达式不会执行。
   4. 或（|）：不短路非，与 || 类似，但是不会短路。
   5. 非（!）:单目操作符，操作数为 true ，返回 false；为 false 则返回 true 。
   6. 异或（^）：只有两个操作数不同时才返回 true 。
6. 三目运算符  
   三目运算符只有一个（?:)；语法格式为：
   `(expression)?if-true-statement:if-false-statement`
   三目运算符的规则是：先对 expression 求值，如果为 true ，则返回第二个操作数的值，否则返回第三个操作数的值。

### 运算符的结合性和优先级
Java 中大部分运算符都是从左向右结合和运算的，只有单目运算符、赋值运算符和三目运算符例外，它们是从右向左结合，也是从右向左运算的。

另外，各个运算符的优先级如下，下表中上一行的优先级总是高于下一行的。
<center><img src="pics/operator-priority.png" alt="" width=60%></center>
