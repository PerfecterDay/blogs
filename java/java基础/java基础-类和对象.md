# 类和对象
{docsify-updated}


## 类
类（class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造（construct）对象的过程称为**创建类的实例（instance）**。

封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个类中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为**实例域（instance field）**，操纵数据的过程称为**方法（method）**。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前**状态（state）**。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

OOP的另一个原则：**继承**，会让用户自定义Java类变得轻而易举，这就是：**可以通过扩展一个类来建立另外一个新的类**。事实上，在Java中，所有的类都源自于一个“神通广大的超类”，它就是 `Object` 。

在类之间，最常见的关系有
+ 依赖（“uses-a”）:如果一个类的方法操纵另一个类的对象，那么这个类就依赖操纵的类
+ 聚合（“has-a”）：类A的对象包含类B的对象。例如，订单对象 `Order` 包含购买的商品对象 `Item`
+ 继承（“is-a”）：表示特殊与一般的关系。

从语法的角度静态的分析一个类，我们说一个 Java 类通常由以下几个部分组成：
1. **实例域**（如果有赋值语句，则在**构造时**会赋值）
2. **类域**（ `static` 修饰的静态域，如有赋值语句，则在**类加载时**会赋值）
3. **构造器**
4. **初始化块** (**构造对象**时执行) 
5. **静态初始化块** （**类加载时**执行）
6. **实例方法**
7. **类方法** （静态方法）

如果说 **程序=数据结构+算法** ，那么我们可以认为类中的域是用来描述数据结构的，类中的方法就是用来操作数据结构的算法，类将他们封装在一起。限定了能够访问数据结构的算法（代码）的范围。

+ 从动态的角度来看，**类是构造对象的模板。当从内存中构造对象时，每个对象都会有一个私有的实例域，而静态域属于类域，是一个类下所有实例变量共享的。**
+ 从内存分布的角度看，**实例域真切代表一个对象的状态，存储在堆中。而静态变量和方法代码通常存储在方法区。**

## 对象
要想使用对象，就必须首先构造对象，并指定其初始状态。然后，通过调用方法来改变/访问对象的状态。

在Java程序设计语言中，使用**构造器（constructor）**构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。  
一个对象变量并没有实际包含一个对象，而仅仅**引用**一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的**引用**。new操作符的返回值也是一个**引用**。

### 实例域
实例域是每一个对象实例**私有**的值，它们构成了对象的**状态**。通过实例方法可以读取/更改实例域的值。  
可以将实例域定义为 `final` ， `final` 修饰的域在构建对象时**必须初始化**。也就是说，必须确保在每一个**构造器执行之后**，这个域的值被设置，并且在后面的操作中，**不能够再对它进行修改**。

### 构造器
构造器与类同名。在构造类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。构造器与其他的方法有一个重要的不同。**构造器总是伴随着new操作符的执行被调用（反射除外），而不能对一个已经存在的对象调用构造器方法来达到重新设置实例域的目的**。直接调用构造器将产生编译错误。构造器有以下特征：
+ 构造器与类同名
+ 每个类可以有一个以上的构造器
+ 构造器可以有0个、1个或多个参数
+ 构造器没有返回值
+ 构造器总是伴随着new操作一起调用

如果在构造器中没有显式地给域赋予初值，那么就会根据域的类型被自动地赋为默认值：**数值为0、布尔值为false、对象引用为null。**然而，只有缺少程序设计经验的人才会这样做。这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，**使用未初始化的局部变量会产生编译错误。但是，如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。**

如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。**仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。**

通过重载类的构造器方法，可以采用多种形式设置类的**实例域**的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。

初始化实例的方法有以下几种：
+ 可以在类定义中，声明域时直接将一个值赋给它。在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。
  ```
  class Person{
      private String name = "";
      private int age = 0;
  }
  ```
+ 在构造器中显示初始化各个域。
  如果有多个重载的构造器，且想在一个构造器中调用另一个构造器，可以在构造器的**第一行**使用 `this(...)` 的形式调用另一个构造器。
+ 初始化块，在一个类的定义中，可以包含一个或多个初始化代码块。只要构造类的对象，这些初始化代码块就会被执行。

### 实例方法
要完整地描述一个方法，需要指出**方法名**以及**参数类型**。这叫做**方法签名**（signature），返回类型不是方法签名的一部分。也就是说，**不能有两个名字相同、参数类型也相同却返回不同类型值的方法**。

如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数(参数个数或者类型不同)，便产生了**重载**。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为**重载解析**（overloading resolution））。

**按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量的地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。**

如何理解这句话呢，以C与语言为例，方法调用时可以传递一个变量的值 `a` ，这个值在被调方法以一个拷贝的局部变量 `pa` 表示，被调方法中改变 `pa` 的值不会改变 `a` 的值。C语言也可以传递指针，即将 `a` 的内存地址 `&a` 传递给被调方法，这时，在被调方法中就可以修改 `a` 的值。请注意，这里时修改传递过来的**参数本身的值**。

Java 只支持按值调用，Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。复制的是对象引用，这个复制的对象引用与原始对象引用指向同一个对象。  
说它是按值调用是因为，**你不能够在被调方法中修改传过来的参数值，使它引用另一个对象**。实际上，形参只是一个局部变量，如果是一个引用类型，那么它只是与传递过来的实参指向同一个对象，因此可以通过它修改实参指向对象的状态，**但是你不能通过改变形参的引用指向来改变实参的引用指向**。如下：

```
void foo(){
  a = new Object();
  bar(a);
}

void bar(Object b){
  b = new Object();
}
```
`a` 始终指向最开始的对象引用。

下面总结一下Java中方法参数的使用情况：
+ 一个方法不能修改一个基本数据类型的实参参数（即数值型或布尔型）。
+ 一个方法可以改变一个对象参数所引用的对象的状态。
+ 一个方法不能让原始对象变量引用一个新的对象。

Java中实例方法会有一个隐含参数 `this` ，代表着对当前对象的引用的。于是，实例方法可以通过这个引用来访问/操作对象的状态值。

### 静态域与静态方法
如果将域定义为 `static` ，则这个域不会保存在每个对象中，这样的域也称为**静态域（类域）**。而每一个对象对于类所有的实例域都有自己的一份拷贝。  
如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。将代码放在一个块中，并标记关键字 `static` ：
```
calss Person{
  static{
    .....
  }
}
```

**静态方法**是一种不能向对象实施操作的方法。可以认为静态方法是没有 `this` 参数的方法（在一个非静态的方法中， `this` 会作为一个隐式参数传递到方法中以供使用， `this` 指向当前执行方法的对象）。因为缺少对象的引用，所以静态方法没有操作对象的能力。但是，静态方法可以访问自身类中的静态域。

## 类与对象的初始化
下边通过一个实例来了解 java 初始化类和对象的大致过程：
<center><img src="pics/init_seq.png" width="30%"></center>

上述圆圈标注的数字代表程序运行时各个语句的执行顺序。  
请注意， `static` 类型的域变量初始化相关代码甚至在 `main` 方法执行前就开始执行了。这主要是因为 jvm 执行时包含了类初始化和对象初始化的流程。

### 类初始化-clinit
<center><img src="pics/class-lifecycle.png" alt="类的生命周期" width="60%"></center>

类"初始化"阶段，它是一个类或接口被首次使用的前阶段中的最后一项工作，本阶段负责**为类变量赋予正确的初始值**。类初始化由JVM负责。

**Java 编译器把所有的类变量(`static` 变量)初始化语句和类型的静态初始化语句(`static{...}` 初始化块)通通收集到 `<clinit>` 方法内，该方法只能被 Jvm 调用，专门承担初始化工作。执行顺序和语句出现的先后顺序保持一致。**

除接口以外，初始化一个类之前必须保证其**直接超类已被初始化**，并且该初始化过程是由 Jvm 保证线程安全的。另外，并非所有的类都会拥有一个 `<clinit>()` 方法，在以下条件中该类不会拥有 `<clinit>()` 方法：

+ 该类既没有声明任何**类变量**，也没有**静态初始化语句**；
+ 该类声明了类变量，但没有明确使用**类变量初始化语句**或**静态初始化语句初始化**；也就是说只声明，但是未初始化赋值
+ 该类仅包含静态 `final` 变量的类变量初始化语句，并且类变量初始化语句是编译时常量表达式,比如： `final static int x = 0;` 。

总结：
<b>
1. 类加载的时候如果发现其有父类，则先加载父类。
2. 类加载时候，会先初始化类变量（如果定义类变量时初始化了的话）和静态初始化块中的初始化语句，两者的顺序以出现的先后次序为准。因为原因1，所以总是先执行父类的初始化（一直追溯到Object）然后才执行子类的初始化。类初始化只会在类加载过程中初始化一次，后续驻留在内存中，不再初始化。
</b>

### 对象初始化-init
在类被装载、连接和初始化，这个类就随时都可能使用了。对象实例化和初始化是就是对象生命的起始阶段的活动，在这里我们主要讨论对象的初始化工作的相关特点。
<b>
1. 实例化对象时，系统首先会为对象分配内存，虚拟机将为新⽣对象分配内存，分配⽅式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。
2. 然后初始化整块内存为0、null、false。
3. 设置对象头: 初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。
4. 然后，执行初始化代码和成员变量声明语句中的初始化，两者顺序以出现先后顺序为准。最后，调用相应的构造器执行初始化。
5. 第2步只是在没有父类情况下的初始化，如果有父类，则会从根类开始执行上述步骤直到执行初始化的类。
</b>

**Java 编译器在编译每个类时都会为该类至少生成一个实例初始化方法--即 ``<init>()`` 方法。此方法与源代码中的每个构造方法相对应，如果类没有明确地声明任何构造方法，编译器则为该类生成一个默认的无参构造方法，这个默认的构造器仅仅调用父类的无参构造器，与此同时也会生成一个与默认构造方法对应的 ``<init>()`` 方法.**

通常来说，`<init>()` 方法内包括的代码内容大概为：
+ 调用另一个 `<init>()` 方法；
+ 对实例变量初始化；
+ 与其对应的构造方法内的代码。

如果构造方法是明确地从调用同一个类中的另一个构造方法开始，那它对应的 `<init>()` 方法体内包括的内容为：一个对本类的 `<init>()` 方法的调用；对应构造方法内的所有字节码。

如果构造方法不是通过调用自身类的其它构造方法开始，并且该对象不是 Object 对象，那 `<init>()` 法内则包括的内容为：一个对父类 `<init>()` 方法的调用；对实例变量初始化方法的字节码；最后是对应构造方法的方法体字节码。

如果这个类是 Object，那么它的 `<init>()` 方法则不包括对父类 `<init>()` 方法的调用。

总结起来，构造对象时的一般过程如下：
1. 所有数据域被初始化为默认值（0、false或null），这是JVM在给对象分配内存时自动将内存清0。
2. 按照在类声明中出现的次序，依次执行所有域初始化语句(声明域时的初始化)和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。