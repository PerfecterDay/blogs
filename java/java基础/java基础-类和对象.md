# 类和对象
{docsify-updated}

- [类和对象](#类和对象)
  - [类](#类)
  - [对象](#对象)
    - [实例域](#实例域)
    - [构造器](#构造器)
    - [实例方法](#实例方法)
    - [静态域与静态方法](#静态域与静态方法)


### 类
类（class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造（construct）对象的过程称为**创建类的实例（instance）**。

封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个类中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为**实例域（instance field）**，操纵数据的过程称为**方法（method）**。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

OOP的另一个原则：继承，会让用户自定义Java类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上，在Java中，所有的类都源自于一个“神通广大的超类”，它就是Object。

在类之间，最常见的关系有
+ 依赖（“uses-a”）:如果一个类的方法操纵另一个类的对象，那么这个类就依赖操纵的类
+ 聚合（“has-a”）：类A的对象包含类B的对象。例如，订单对象Order包含购买的商品对象Item
+ 继承（“is-a”）：表示特殊与一般的关系。

从语法的角度静态的分析一个类，我们说一个 Java 类通常由以下几个部分组成：
1. 实例域（如果有赋值语句，则在构造时会赋值）
2. 类域（静态域，如有赋值语句，则在类加载时会赋值）
3. 构造器
4. 初始化块(构造对象时执行) 
5. 静态初始化块（类加载时执行）
6. 实例方法
7. 类方法（静态方法）

如果说程序=数据结构+算法，那么我们可以认为类中的域是用来描述数据结构的，类中的方法就是用来操作数据结构的算法，类将他们封装在一起。限定了能够访问数据结构的算法（代码）的范围。

从动态的角度来看，**类是构造对象的模板。当从内存中构造对象时，每个对象都会有一个私有的实例域，而静态域属于类域，是一个类下所有实例变量共享的。**

从内存分布的角度看，实例域真切代表一个对象的状态，存储在堆中。而静态变量和方法代码通常存储在方法区。  

### 对象
要想使用对象，就必须首先构造对象，并指定其初始状态。然后，通过调用方法来改变/访问对象的状态。

在Java程序设计语言中，使用**构造器（constructor）**构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。

#### 实例域
实例域是每一个对象实例私有的值，它们构成了对象的状态。通过实例方法可以读取/更改实例域的值。  
可以将实例域定义为final，final 修饰的域在构建对象时必须初始化。也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。

#### 构造器
构造器与类同名。在构造类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。构造器与其他的方法有一个重要的不同。**构造器总是伴随着new操作符的执行被调用（反射除外），而不能对一个已经存在的对象调用构造器方法来达到重新设置实例域的目的**。直接调用构造器将产生编译错误。构造器有以下特征：
+ 构造器与类同名
+ 每个类可以有一个以上的构造器
+ 构造器可以有0个、1个或多个参数
+ 构造器没有返回值
+ 构造器总是伴随着new操作一起调用

如果在构造器中没有显式地给域赋予初值，那么就会根据域的类型被自动地赋为默认值：**数值为0、布尔值为false、对象引用为null。**然而，只有缺少程序设计经验的人才会这样做。这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，**使用未初始化的局部变量会产生编译错误**。但是，如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。

如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。**仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。**

通过重载类的构造器方法，可以采用多种形式设置类的**实例域**的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。

初始化实例的方法有以下几种：
+ 可以在类定义中，声明域时直接将一个值赋给任何域。在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。
  ```
  class Person{
      private String name = "";
      private int age = 0;
  }
  ```
+ 在构造器中显示初始化各个域。
  如果有多个重载的构造器，且想在一个构造器中调用另一个构造器，可以在构造器的**第一行**使用 `this(...)` 的形式调用另一个构造器。
+ 初始化块，在一个类的定义中，可以包含一个或多个初始化代码块。只要构造类的对象，这些初始化代码块就会被执行。
  ```
  class Employee{
      private int id;
      private String name;
      private int age;
      {
          id = -1;
      }
      public Employee(){
          name = "";
          age = 0;
      }
      public Employee(String name, int age){
          this.name = name;
          this.age = age;
      }
  }
  ```
  无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化为 -1 。首先运行初始化块，然后才运行构造器的主体部分。

总结起来，构造对象时的一般过程如下：
1. 所有数据域被初始化为默认值（0、false或null），这是JVM在给对象分配内存时自动将内存清0。
2. 按照在类声明中出现的次序，依次执行所有域初始化语句(声明域时的初始化)和初始化块。
3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。
4. 执行这个构造器的主体。

#### 实例方法
要完整地描述一个方法，需要指出方法名以及参数类型。这叫做**方法签名**（signature），返回类型不是方法签名的一部分。也就是说，**不能有两个名字相同、参数类型也相同却返回不同类型值的方法**。如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为重载解析（overloading resolution））。

**按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。**

如何理解这句话呢，以C与语言为例，方法调用时可以传递一个变量的值 a，这个值在被调方法以一个拷贝的局部变量 pa 表示，被调方法中改变 pa 的值不会改变 a 的值。C语言也可以传递指针，即将 a 的内存地址 &a 传递给被调方法，这时，在被调方法中就可以修改 a 的值。请注意，这里时修改传递过来的**参数本身的值**。

Java 只支持按值调用，Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。复制的是对象引用，这个复制的对象引用与原始对象引用指向同一个对象。  
说它是按值调用是因为，**你不能够在被调方法中修改传过来的参数值，使它引用另一个对象**。实际上，形参只是一个局部变量，如果是一个引用类型，那么它只是与传递过来的实参指向同一个对象，因此可以通过它修改实参指向对象的状态，但是你不能通过改变形参的引用指向来改变时参的引用指向。

```
void foo(){
  a = new Object();
  bar(a);
}

void bar(Object b){
  b = new Object();
}
```
a始终指向最开始的对象引用。

下面总结一下Java中方法参数的使用情况：
+ 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
+ 一个方法可以改变一个对象参数所引用的对象的状态。
+ 一个方法不能让原始对象变量引用一个新的对象。

Java中实例方法会有一个隐含参数 this ，代表着对当前对象的引用的。于是，实例方法可以通过这个引用来访问/操作对象的状态值。

#### 静态域与静态方法
如果将域定义为static，则这个域不会保存在每个对象中，这样的域也称为**静态域（类域）**。而每一个对象对于类所有的实例域都有自己的一份拷贝。  
如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。将代码放在一个块中，并标记关键字 static ：
```
calss Person{
  static{
    .....
  }
}
```

**静态方法**是一种不能向对象实施操作的方法。可以认为静态方法是没有this参数的方法（在一个非静态的方法中，this会作为一个隐式参数传递到方法中以供使用，this 指向当前执行方法的对象）。因为缺少对象的引用，所以静态方法没有操作对象的能力。但是，静态方法可以访问自身类中的静态域。