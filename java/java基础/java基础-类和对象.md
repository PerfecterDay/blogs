# 类和对象
{docsify-updated}

## 类
类（class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类构造（construct）对象的过程称为**创建类的实例（instance）**。

封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个类中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为**实例域（instance field）**，操纵数据的过程称为**方法（method）**。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前**状态（state）**。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。

OOP的另一个原则：**继承**，会让用户自定义Java类变得轻而易举，这就是：**可以通过扩展一个类来建立另外一个新的类**。事实上，在Java中，所有的类都源自于一个“神通广大的超类”，它就是 `Object` 。

在类之间，最常见的关系有
+ 依赖（“uses-a”）:如果一个类的方法操纵另一个类的对象，那么这个类就依赖操纵的类
+ 聚合（“has-a”）：类A的对象包含类B的对象。例如，订单对象 `Order` 包含购买的商品对象 `Item`
+ 继承（“is-a”）：表示特殊与一般的关系。

从语法的角度静态的分析一个类，我们说一个 Java 类通常由以下几个部分组成：
1. **实例域**（如果有赋值语句，则在**构造时**会赋值）
2. **类域**（ `static` 修饰的静态域，如有赋值语句，则在**类加载时**会赋值）
3. **构造器**
4. **初始化块** (**构造对象**时执行) 
5. **静态初始化块** （**类加载时**执行）
6. **实例方法**
7. **类方法** （静态方法）

如果说 **程序=数据结构+算法** ，那么我们可以认为类中的域是用来描述数据结构的，类中的方法就是用来操作数据结构的算法，类将他们封装在一起。限定了能够访问数据结构的算法（代码）的范围。

+ 从动态的角度来看，**类是构造对象的模板。当从内存中构造对象时，每个对象都会有一个私有的实例域，而静态域属于类域，是一个类下所有实例变量共享的。**
+ 从内存分布的角度看，**实例域真切代表一个对象的状态，存储在堆中。而静态变量和方法代码通常存储在方法区。**

## 对象
要想使用对象，就必须首先构造对象，并指定其初始状态。然后，通过调用方法来改变/访问对象的状态。

在Java程序设计语言中，使用**构造器（constructor）**构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。  
一个对象变量并没有实际包含一个对象，而仅仅**引用**一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的**引用**。new操作符的返回值也是一个**引用**。

### 实例域
实例域是每一个对象实例**私有**的值，它们构成了对象的**状态**。通过实例方法可以读取/更改实例域的值。  
可以将实例域定义为 `final` ， `final` 修饰的域在构建对象时**必须初始化**。也就是说，必须确保在每一个**构造器执行之后**，这个域的值被设置，并且在后面的操作中，**不能够再对它进行修改**。

### 构造器
构造器与类同名。在构造类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。构造器与其他的方法有一个重要的不同。**构造器总是伴随着new操作符的执行被调用（反射除外），而不能对一个已经存在的对象调用构造器方法来达到重新设置实例域的目的**。直接调用构造器将产生编译错误。构造器有以下特征：
+ 构造器与类同名
+ 每个类可以有一个以上的构造器
+ 构造器可以有0个、1个或多个参数
+ 构造器没有返回值
+ 构造器总是伴随着new操作一起调用

如果在构造器中没有显式地给域赋予初值，那么就会根据域的类型被自动地赋为默认值：**数值为0、布尔值为false、对象引用为null。**然而，只有缺少程序设计经验的人才会这样做。这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，**使用未初始化的局部变量会产生编译错误。但是，如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。**

如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。**仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。**

通过重载类的构造器方法，可以采用多种形式设置类的**实例域**的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。

初始化实例的方法有以下几种：
+ 可以在类定义中，声明域时直接将一个值赋给它。在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。
  ```
  class Person{
      private String name = "";
      private int age = 0;
  }
  ```
+ 在构造器中显示初始化各个域。
  如果有多个重载的构造器，且想在一个构造器中调用另一个构造器，可以在构造器的**第一行**使用 `this(...)` 的形式调用另一个构造器。
+ 初始化块，在一个类的定义中，可以包含一个或多个初始化代码块。只要构造类的对象，这些初始化代码块就会被执行。

### 实例方法
要完整地描述一个方法，需要指出**方法名**以及**参数类型**。这叫做**方法签名**（signature），返回类型不是方法签名的一部分。也就是说，**不能有两个名字相同、参数类型也相同却返回不同类型值的方法**。

如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数(参数个数或者类型不同)，便产生了**重载**。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为**重载解析**（overloading resolution））。

**按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量的地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。**

如何理解这句话呢，以C与语言为例，方法调用时可以传递一个变量的值 `a` ，这个值在被调方法以一个拷贝的局部变量 `pa` 表示，被调方法中改变 `pa` 的值不会改变 `a` 的值。C语言也可以传递指针，即将 `a` 的内存地址 `&a` 传递给被调方法，这时，在被调方法中就可以修改 `a` 的值。请注意，这里时修改传递过来的**参数本身的值**。

Java 只支持按值调用，Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。复制的是对象引用，这个复制的对象引用与原始对象引用指向同一个对象。  
说它是按值调用是因为，**你不能够在被调方法中修改传过来的参数值，使它引用另一个对象**。实际上，形参只是一个局部变量，如果是一个引用类型，那么它只是与传递过来的实参指向同一个对象，因此可以通过它修改实参指向对象的状态，**但是你不能通过改变形参的引用指向来改变实参的引用指向**。如下：

```
void foo(){
  a = new Object();
  bar(a);
}

void bar(Object b){
  b = new Object();
}
```
`a` 始终指向最开始的对象引用。

下面总结一下Java中方法参数的使用情况：
+ 一个方法不能修改一个基本数据类型的实参参数（即数值型或布尔型）。
+ 一个方法可以改变一个对象参数所引用的对象的状态。
+ 一个方法不能让原始对象变量引用一个新的对象。

Java中实例方法会有一个隐含参数 `this` ，代表着对当前对象的引用的。于是，实例方法可以通过这个引用来访问/操作对象的状态值。

### 静态域与静态方法
如果将域定义为 `static` ，则这个域不会保存在每个对象中，这样的域也称为**静态域（类域）**。而每一个对象对于类所有的实例域都有自己的一份拷贝。  
如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。将代码放在一个块中，并标记关键字 `static` ：
```
calss Person{
  static{
    .....
  }
}
```

**静态方法**是一种不能向对象实施操作的方法。可以认为静态方法是没有 `this` 参数的方法（在一个非静态的方法中， `this` 会作为一个隐式参数传递到方法中以供使用， `this` 指向当前执行方法的对象）。因为缺少对象的引用，所以静态方法没有操作对象的能力。但是，静态方法可以访问自身类中的静态域。

## 类与对象的初始化
下边通过一个实例来了解 java 初始化类和对象的大致过程：
<center><img src="pics/init_seq.png" width="30%"></center>

上述圆圈标注的数字代表程序运行时各个语句的执行顺序。  
请注意， `static` 类型的域变量初始化相关代码甚至在 `main` 方法执行前就开始执行了。这主要是因为 jvm 执行时包含了类初始化和对象初始化的流程。

### 类初始化-`<clinit>`
<center><img src="pics/class-lifecycle.png" alt="类的生命周期" width="60%"></center>

类"初始化"阶段，它是一个类或接口被首次使用的前阶段中的最后一项工作，本阶段负责**为类变量赋予正确的初始值**。类初始化由JVM负责。

**Java 编译器把所有的类变量(`static` 变量)初始化语句和类型的静态初始化语句(`static{...}` 初始化块)通通收集到 `<clinit>` 方法内，该方法只能被 Jvm 调用，专门承担初始化工作。执行顺序和语句出现的先后顺序保持一致。**

除接口以外，初始化一个类之前必须保证其**直接超类已被初始化**，并且该初始化过程是由 Jvm 保证线程安全的。另外，并非所有的类都会拥有一个 `<clinit>()` 方法，在以下条件中该类不会拥有 `<clinit>()` 方法：

+ 该类既没有声明任何**类变量**，也没有**静态初始化语句**；
+ 该类声明了类变量，但没有明确使用**类变量初始化语句**或**静态初始化语句初始化**；也就是说只声明，但是未初始化赋值
+ 该类仅包含静态 `final` 变量的类变量初始化语句，并且类变量初始化语句是编译时常量表达式,比如： `final static int x = 0;` 。

总结：
<b>
1. 类加载的时候如果发现其有父类，则先加载父类。
2. 类加载时候，会先初始化类变量（如果定义类变量时初始化了的话）和静态初始化块中的初始化语句，两者的顺序以出现的先后次序为准。因为原因1，所以总是先执行父类的初始化（一直追溯到Object）然后才执行子类的初始化。类初始化只会在类加载过程中初始化一次，后续驻留在内存中，不再初始化。
</b>

### 对象分配与初始化-`<init>`
在类被装载、连接和初始化，这个类就随时都可能使用了。对象实例化和初始化是就是对象生命的起始阶段的活动，在这里我们主要讨论对象的初始化工作的相关特点。
<b>
1. 实例化对象时，系统首先会为对象分配内存，虚拟机将为新⽣对象分配内存，分配⽅式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。
2. 然后初始化整块内存为0、null、false。
3. 设置对象头: 初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。
4. 然后，执行初始化代码和成员变量声明语句中的初始化，两者顺序以出现先后顺序为准。最后，调用相应的构造器执行初始化。这整个过程在 `<init>` 方法中完成
5. 第2步只是在没有父类情况下的初始化，如果有父类，则会从根类开始执行上述步骤直到执行初始化的类。
</b>

**Java 编译器在编译每个类时都会为该类至少生成一个实例初始化方法--即 `<init>()` 方法。此方法与源代码中的每个构造方法相对应，如果类没有明确地声明任何构造方法，编译器则为该类生成一个默认的无参构造方法，这个默认的构造器仅仅调用父类的无参构造器，与此同时也会生成一个与默认构造方法对应的 `<init>()` 方法.**

通常来说，`<init>()` 方法内包括的代码内容大概为：
+ 调用另一个 `<init>()` 方法；
+ 对实例变量初始化；
+ 与其对应的构造方法体字节码。

如果构造方法是明确地从调用同一个类中的另一个构造方法开始，那它对应的 `<init>()` 方法体内包括的内容为：一个对本类的 `<init>()` 方法的调用；对应构造方法内的所有字节码。

如果构造方法不是通过调用自身类的其它构造方法开始，并且该对象不是 `Object` 对象，那 `<init>()` 法内则包括的内容为：一个对父类 `<init>()` 方法的调用；对实例变量初始化方法的字节码；最后是对应构造方法的方法体字节码。

如果这个类是 `Object` ，那么它的 `<init>()` 方法则不包括对父类 `<init>()` 方法的调用。

#### 对象的内存分配
1. 指针碰撞  
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为**指针碰撞**（Bump The Pointer）。

2. 空闲列表  
但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为**空闲列表（Free List）**。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。

#### TLAB
除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：
+ 一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；
+ 另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，**分配新的缓存区时才需要同步锁定**。虚拟机是否使用TLAB，可以通过 `-XX：+/-UseTLAB` 参数来设定。

内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始---->构造函数，即Class文件中的 `<init>()` 方法还没有执行。

### ### 对象的内存布局
在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

HotSpot虚拟机对象的对象头部分包括两类信息。

第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。

对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。

接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（`-XX：FieldsAllocationStyle`参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为 `longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）`，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的`+XX：CompactFields`参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。

对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。