#继承
{docsify-updated}

- [继承](#继承)
	- [super 与 this 类比](#super-与-this-类比)
	- [理解方法调用](#理解方法调用)
	- [final 类和方法](#final-类和方法)
	- [抽象类 （abstract）](#抽象类-abstract)


Java关键字 **extends** 表明正在构造的新类派生于一个已存在的类。已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。

在构造子类对象时，如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。可以使用 **super** 关键字调用超类的方法或构造器。

### super 与 this 类比

关键字this有两个用途：
+ 一是作为方法的隐式隐式参数，调用执行方法的当前对象本身
+ 二是在某个构造器中调用该类其他的构造器，必须第一行。

同样，super 也有两个用途：
+ 调用超类的重载方法，
+ 调用超类的构造器，必须第一行。

在调用构造器的时候，这两个关键字的使用方式很相似，调用构造器的语句只能作为另一个构造器的**第一条语句**出现。构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。  
有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。

一个对象引用变量（例如，变量e）可以指示多种实际类型的现象被称为**多态**（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定（dynamic binding）**。在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有动态绑定，可以将它标记为final。

有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是超类的对象。例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之不然，并不是每一名雇员都是经理。

“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。

### 理解方法调用
弄清楚如何在对象上应用方法调用非常重要。下面假设要调用x.f（args），隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：
1. 编译器查看对象的声明类型和方法名。C中有可能存在多个名字为f，但参数类型不一样的方法。例如，可能存在方法f（int）和方法f（String）。编译器将会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。需要注意的是这步看的是**声明类型**的方法而不是实际类型。
2. 接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析**（overloading resolution）。例如，对于调用x.f（“Hello”）来说，编译器将会挑选f（String），而不是f（int）。由于允许类型转换（int可以转换成double，Manager可以转换成Employee，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。

    前面曾经说过，方法的名字和参数列表称为方法的签名。例如，f（int）和f（String）是两个具有相同名字，不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。**允许子类将覆盖方法的返回类型定义为原返回类型的子类型**。覆盖方法具有可协变的返回类型。在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。  
    至此，编译器已获得需要调用的方法名字和参数类型。注意，这一步只是确定了方法名字和参数（方法签名），具体调用哪个方法还要看方法的绑定类型。

3. 如果是**private方法、static方法、final方法（有关final修饰符的含义将在下一节讲述）或者构造器**，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定（static binding）**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现**动态绑定**。也就是说，前两步只是确定了方法签名，其实就是一个符号引用，这个符号引用具体绑定到哪个方法，还要看方法的绑定类型。

4. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f（String），就直接调用它；否则，将在D类的超类中寻找f（String），以此类推直到定义时声明的C类为止。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个**方法表（method table）**，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。也就是说编译器事先就将D中每个方法实际上绑定到的方法记录在方法表中，这样，在声明D类型的对象并调用方法时就可以直接查表找到要执行的方法。在前面的例子中，虚拟机搜索D类的方法表，以便寻找与调用f（Sting）相匹配的方法。这个方法既有可能是D.f（String），也有可能是X.f（String），这里的X是D的超类，不过不管是D.f(String)或者X.f(String)，都是记录在方法表中了的。需要提醒一点的是，如果调用super.f（param），编译器将直接在超类的方法表进行搜索。

覆盖方法时，子类方法不能低于父类方法得可见性。

### final 类和方法
有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。  
类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）。

### 抽象类 （abstract）
用 abstract 修饰的方法称为抽象方法，抽象方法没有方法体，只有方法声明（方法名+参数+返回值）。
**包含一个或多个抽象方法的类本身必须被声明为抽象的，用 abstract 修饰。除了抽象方法之外，抽象类也可以包含具体数据和具体方法。**  
类即使不含抽象方法，也可以将类声明为抽象类。抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。