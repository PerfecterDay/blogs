# 继承与方法调用
{docsify-updated}

Java关键字 **extends** 表明正在构造的新类派生于一个已存在的类。已存在的类称为**超类（superclass）、基类（base class）或父类（parent class）**；新类称为**子类（subclass）、派生类（derived class）或孩子类（child class）**。

在构造子类对象时，如果子类的构造器没有显式地调用超类的构造器，则将**自动地调用超类默认（没有参数）的构造器**。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将**报告错误**。可以使用 **super** 关键字调用超类的方法或构造器。

## super 与 this 类比

关键字 `this` 有两个用途：
+ 一是作为方法的隐式**隐式参数**，引用当前调用执行方法的对象本身
+ 二是在某个构造器中调用**该类其他的构造器**，必须第一行。

同样，super 也有两个用途：
+ 调用超类的方法
+ 调用**超类的构造器**，必须第一行。

在调用构造器的时候，这两个关键字的使用方式很相似，调用构造器的语句只能作为另一个构造器的**第一条语句**出现。构造参数既可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器。  
有些人认为 `super` 与 `this` 引用是类似的概念，实际上，这样比较并不太恰当。这是因为 `super` 不是一个对象的引用，不能将 `super` 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。**但是 `this` 可以当作引用赋值给另一个类型兼容的引用变量**。

一个对象引用变量（例如，变量e）可以引用多种实际类型对象的现象被称为**多态**（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为**动态绑定（dynamic binding）**。在Java中，不需要将方法声明为虚拟方法。动态绑定是默认的处理方式。如果不希望让一个方法具有动态绑定，可以将它标记为 `final` 。

有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a”规则，它表明子类的每个对象也是超类的对象。例如，每个经理都是雇员，因此，将Manager类设计为Employee类的子类是显而易见的，反之不然，并不是每一名雇员都是经理。

“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。

## 理解方法调用
弄清楚如何在对象上应用方法调用非常重要。下面假设要调用 `x.f(args)`，隐式参数`x`声明为类`C`的一个对象。下面是调用过程的详细描述：
1. 编译器查看对象的声明类型和方法名。声明类型是`C`，调用方法名是`f`. `C` 中有可能存在多个名字为`f`，但参数类型不一样的方法。例如，可能存在方法 `f(int)` 和方法 `f(String)` 。编译器将会一一列举所有`C`类中名为`f`的方法和其超类中访问属性为 `public/protected` 且名为 `f` 的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。需要注意的是这步看的是**声明类型**的方法而不是实际类型。
2. 接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析**（overloading resolution）。例如，对于调用 `x.f("Hello")` 来说，编译器将会挑选 `f(String)` ，而不是 `f(int)` 。由于允许类型转换（ `int` 可以转换成 `double` ， `Manager` 可以转换成 `Employee` ，等等），所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。

    前面曾经说过，方法的名字和参数列表称为方法的签名。例如，`f(int)` 和 `f(String)` 是两个具有相同名字，不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。不过，返回类型不是签名的一部分，因此，在覆盖方法时，一定要保证返回类型的兼容性。**允许子类将覆盖方法的返回类型定义为原返回类型的子类型**。覆盖方法具有可协变的返回类型。在覆盖一个方法的时候，**子类方法不能低于超类方法的可见性**。  
    至此，编译器已获得需要调用的方法名字和参数类型。注意，这一步只是确定了方法名字和参数（方法签名），具体调用哪个方法还要看方法的绑定类型。

3. 如果是**private方法、static方法、final方法（有关final修饰符的含义将在下一节讲述）或者构造器**，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定（static binding）**。与此对应的是，调用的方法依赖于隐式参数 `this` 的实际类型，并且在运行时实现**动态绑定**。也就是说，前两步只是确定了方法签名，其实就是一个符号引用，这个符号引用具体绑定到哪个方法，还要看方法的绑定类型。

4. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与 `x` 所引用对象的实际类型最合适的那个类的方法。假设 `x` 的实际类型是 `D`，它是 `C` 类的子类。如果 `D` 类定义了方法 `f(String)` ，就直接调用它；否则，将在 `D` 类的超类中寻找 `f(String)`，以此类推直到定义时声明的C类为止。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个**方法表（method table）**，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。也就是说编译器事先就将 `D` 中每个方法实际上绑定到的方法记录在方法表中，这样，在声明`D` 类型的对象并调用方法时就可以直接查表找到要执行的方法。在前面的例子中，虚拟机搜索 `D` 类的方法表，以便寻找与调用 `f(String)` 相匹配的方法。这个方法既有可能是 `D.f(String)`，也有可能是 `X.f(String)` ，这里的 `X` 是 `D` 的超类，不过不管是 `D.f(String)` 或者 `X.f(String)`，都是记录在方法表中了的。需要提醒一点的是，如果调用 `super.f(param)`，编译器将直接在超类的方法表进行搜索。

<center><img src="pics/vtable.webp" alt=""></center>

## final 类和方法
有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。  
类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）。

## 抽象类 （abstract）
用 abstract 修饰的方法称为抽象方法，抽象方法没有方法体，只有方法声明（方法名+参数+返回值）。
**包含一个或多个抽象方法的类本身必须被声明为抽象的，用 abstract 修饰。除了抽象方法之外，抽象类也可以包含具体数据和具体方法。**  
类即使不含抽象方法，也可以将类声明为抽象类。抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。