# G1 垃圾收集器
{docsify-updated}


## 堆内存布局
<center><img src="pics/g1-heap-layout.png" width="50%"></center>
如图所示，G1 将堆划分为一组大小相等的堆区域（region），每个堆区域都是一段连续的虚拟内存。 区域是内存分配和内存回收的基本单位。 在任何时候，每个区域都可能是空的（浅灰色），或者分配给某个分代（年轻代或者老年代）。 随着内存请求的到来，内存管理器会分配空闲区域。 内存管理器将这些区域分配给某个分代，然后作为空闲空间返回给应用程序，应用程序然后可以自行分配这些内存。

年轻代包含 Eden regions（红色）和 survivor region（红色带 "S"）。 这些区域的功能与其他GC中相应区域一样，不同的是，在 G1 中，这些区域通常以非连续的模式布局在内存中。 浅蓝色的 regions 组成老年代堆。 有些特殊的老年代 regions 是比较巨大的（带 "H "的浅蓝色块），用于存放跨越多个 region 的大对象。

应用程序的内存分配总是在年轻代（Eden区域）进行，但是大的巨型对象会直接在老年代区域分配内存（H块）。

## 垃圾收集周期
从高层次来看，G1 垃圾回收器在两个阶段之间交替运行。
+ 仅年轻代阶段（Young-Only phase）：在该阶段，垃圾回收会逐渐填满当前可用的内存，并将对象逐步晋升到老年代。
+ 空间回收阶段（Space-Reclamation phase）：在这一阶段，G1 在处理年轻代的同时，逐步回收老年代的空间。

然后，垃圾回收周期重新开始，进入新的仅年轻代阶段。

以下是 G1 垃圾回收周期各个阶段的详细描述，包括它们的暂停和阶段之间的转换：

### 仅年轻代阶段（Young-Only phase）：
该阶段以几次普通年轻代（Normal young）回收开始，这些回收会将对象晋升到老年代。当老年代的占用率达到**触发堆占用率阈值（Initiating Heap Occupancy threshold）时，G1 不再执行普通年轻代回收，而是安排一次并发启动（Concurrent Start）年轻代回收，由此进入空间回收（Space-Reclamation）**阶段。

并发启动（Concurrent Start）：
这种回收不仅执行普通年轻代回收，还启动并发标记（Concurrent Marking），用于识别老年代中所有仍然可达（存活）的对象，以备后续的空间回收阶段使用。在标记完成之前，可能仍会发生普通年轻代回收。标记结束时，会有两个特殊的全局停顿（stop-the-world，STW）暂停：重新标记（Remark）和清理（Cleanup）。

如果并发启动阶段判断不需要继续进行标记，则会进入并发标记撤销（Concurrent Mark Undo）阶段，这个阶段较短，并且系统会继续处于仅年轻代阶段，不会触发**重新标记（Remark）和清理（Cleanup）**暂停。

重新标记（Remark）：
此暂停用于最终完成标记过程，同时执行引用处理（Reference Processing）和类卸载（Class Unloading），并回收完全空闲的区域，同时清理内部数据结构。在重新标记与清理暂停之间，G1 还会计算相关信息，以便稍后在清理暂停中并发回收选定的老年代区域中的空闲空间。

清理（Cleanup）：
此暂停决定是否需要进入空间回收阶段。如果需要，则仅年轻代阶段会以准备混合回收（Prepare Mixed）年轻代回收结束，并进入空间回收阶段。

### 空间回收阶段（Space-Reclamation phase）：
此阶段由多次**混合回收（Mixed collections）**组成，这些回收不仅会处理年轻代区域，还会同时回收部分老年代区域中的存活对象。空间回收阶段的结束条件是：G1 认为进一步回收老年代区域的收益不足以抵消成本。

在空间回收阶段结束后，垃圾回收周期重新开始，回到仅年轻代阶段。

如果应用在计算对象存活率时耗尽了内存，G1 作为备用措施，会执行一次全堆（Full GC）的停顿式内存压缩（stop-the-world full heap compaction），类似于其他垃圾回收器的全局回收方式。

## 垃圾收集的暂停和回收集
G1 在全局停顿（stop-the-world，STW）期间执行垃圾回收和空间回收。存活的对象通常会从源区域（source regions）复制到堆中的一个或多个目标区域（destination regions），并调整对这些移动对象的引用。

对于非巨型（non-humongous）区域，对象的目标区域由其所在的源区域决定：
+ 年轻代（伊甸园区 Eden 和幸存者区 Survivor）中的对象会被复制到幸存者区或老年代，具体取决于对象的年龄。
+ 老年代（Old）中的对象会被复制到其他老年代区域。

对于**巨型（humongous）**区域中的对象，G1 的处理方式有所不同：
+ G1 仅计算它们的存活状态，如果对象不存活，则直接回收其占用的空间。
+ G1 不会在常规回收过程中移动巨型对象，只有在极端情况下（作为最后的补救措施）才会尝试移动它们。

### 记忆集
为了回收回收集（collection set），G1 维护了一个记忆集（remembered set）。这个集合记录了回收集之外的所有位置，这些位置包含指向回收集内部对象的引用。当垃圾回收期间回收集中的对象被移动时，所有来自回收集外部的引用都需要更新，以指向对象的新位置。

记忆集的条目是近似位置，这样可以减少内存占用，因为通常相邻的引用会指向相邻的对象。G1 逻辑上将堆划分为卡片（cards），默认大小为512 字节。记忆集中的条目是这些卡片的压缩索引。

G1 最初按区域（region）管理记忆集：
+ 每个区域都包含一个按区域存储的记忆集，记录了可能包含指向该区域对象的引用的位置。
+ 在垃圾回收过程中，G1 从这些区域级别的记忆集中生成整个回收集的记忆集。

G1 主要采用惰性创建（lazy creation）的方式维护记忆集：
+ 在重新标记（Remark）和清理（Cleanup）暂停之间，G1 会重建所有标记回收集候选区域的记忆集。
+ 除此之外，G1 始终维护年轻代区域的记忆集，因为这些区域在每次垃圾回收时都会被回收。

### 回收集
回收集（Collection Set，CSet）是垃圾回收期间用于回收空间的源区域集合。无论垃圾回收类型如何，回收集都由不同类型的区域组成：
+ 年轻代区域（Young generation regions）
+ 巨型对象（Humongous regions）（详见“巨型对象”部分的限制）
+ 回收集候选区域（Collection set candidate regions）：这些是 G1 认为回收效率较高的老年代区域，因此被选入回收集。

回收效率的计算方式：
+ 主要依据空闲空间的大小，存活数据较少的区域优先于存活数据较多的区域。
+ 还考虑区域之间的连接性，低连接性的区域优先于高连接性的区域。

老年代的回收集候选区域来源有两个：
1. 全堆分析（whole heap analysis），即并发标记（Concurrent Marking）阶段。此时，G1 已经获得了所有老年代区域的存活数据和连接性信息，可以准确计算回收效率。
2. 发生撤离失败（Evacuation Failure）的区域。在垃圾回收过程中，如果 G1 无法成功移动对象，这些对象通常数量很少，因此这些区域默认被认为是高效的回收目标。

### 垃圾回收的过程
垃圾回收由四个阶段组成：

1. 预撤离收集集阶段（Pre Evacuate Collection Set phase） 
该阶段执行垃圾回收前的准备工作，包括：
+ 断开 线程本地分配缓冲区（TLABs）与**应用线程（mutator threads）**的连接。
+ 选择当前回收的收集集（collection set），具体方法详见Java 堆大小调整（Java Heap Sizing）。
+ 其他小型准备工作。

2. 合并堆根阶段（Merge Heap Roots phase）

G1 创建一个统一的记忆集，以便后续的并行处理更加高效：
+ 该记忆集来自收集集中的各个区域。
+ 这一过程可以移除许多重复项，避免稍后在更昂贵的阶段进行过滤，提高回收效率。

3. 撤离收集集阶段（Evacuate Collection Set phase）

这是整个垃圾回收中工作量最大的阶段：
+ G1 从根对象（roots）开始移动对象。
+ 根对象（Root References）是指来自收集集外部的对象引用，包括：
+ 外部根（External Roots）：来自 JVM 内部数据结构的引用。
+ 代码根（Code Roots）：来自 JIT 编译代码的引用。
+ 堆根（Heap Roots）：来自 Java 堆中其他区域的引用。
+ 对于所有根对象，G1 会将其引用的对象从收集集中复制到目标区域，并继续处理其指向收集集的其他引用，直到所有对象都被处理完毕。
+ 可以使用 -Xlog:gc+phases=debug 选项，查看该阶段的各个子阶段的时间，包括：
+ 外部根扫描（Ext Root Scanning）
+ 代码根扫描（Code Root Scan）
+ 堆根扫描（Scan Heap Roots）
+ 对象复制（Object Copy）
+ G1 可能会重复执行主要的撤离阶段，以便处理额外的收集集（可选）。

4. 后撤离收集集阶段（Post Evacuate Collection Set phase）

该阶段负责清理和准备下一个应用线程运行阶段（mutator phase），主要包括：
+ 引用处理（Reference Processing）。
+ 设置下一阶段的运行环境。

这些阶段的执行情况可以使用 `-Xlog:gc+phases=info` 选项查看。