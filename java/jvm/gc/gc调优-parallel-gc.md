# The Parallel Collector GC
{docsify-updated}

parallel collector（此处也称为  throughput collector）是一种与serial collector类似的分代收集器。 serial collector 和 parallel collector 的主要区别在于：并行收集器有多个线程，用于加快垃圾收集速度。

并行收集器通过命令行选项 `-XX:+UseParallelGC` 启用。 默认情况下，使用该选项时，minor and major gc 将并行运行，以进一步减少垃圾收集的开销。

## Parallel GC 的线程数
在具有 $N$ 个硬件线程（其中 $N>8$）的机器上，并行收集器使用固定的分数乘以 $N$ 作为垃圾收集器线程数。

当 $N$ 的值较大时，分数约为 $5/8$。 当 $N<8$ 时，使用的数字是 $N$。 在特定的平台上，该分数会降至 $5/16$。 垃圾收集器线程的具体数量可以通过命令行选项进行调整（稍后会介绍）。 在只有一个处理器的主机上，并行收集器的性能可能不如串行收集器，因为并行执行需要开销（例如同步）。 不过，当运行具有中型到大型堆的应用程序时，在有两个处理器的计算机上，并行收集器的性能通常会略微优于串行收集器，而当有两个以上处理器时，并行收集器的性能通常会明显优于串行收集器。

可以使用命令行选项 `-XX:ParallelGCThreads=<N>` 控制垃圾收集器线程的数量。 如果使用命令行选项来调整堆，那么并行收集器所需的堆大小与串行收集器所需的堆大小相同，这样才能获得良好的性能。 不过，启用并行收集器应该会缩短收集暂停时间。 

由于多个垃圾收集线程都参与了 minor gc，因此在收集过程中可能会出现从年轻代向老年代升级的碎片。 参与minor gc的每个垃圾收集线程都会保留一部分老年代内存空间用于保存从年轻代晋升过来的对象，这些 "晋升缓冲区 "可能会造成碎片。 减少垃圾回收线程的数量和增大老年代的大小可以减少这种碎片效应。

## Parallel GC 分代的排布
Serial GC 的分代排布：
<center><img src="pics/jsgct_dt_001_armgnt_gn_new.png" width=""></center>


Parallel GC 的分代排布与 Serial GC 的不同：
<center><img src="pics/jsgct_dt_002_armgnt_gn_pl_new.png" width=""></center>


## Parallel GC 的自适应优化
当使用 `-XX:+UseParallelGC` 选择 Parallel GC 时，它将启用一种自动调优的方法，允许你指定行为目标来调优，而不是指定详细的分代大小和其他细节的低级调优参数。

### 指定行为目标
可以指定垃圾收集的最大暂停时间、吞吐量和占用空间（堆大小）。
+ 最大垃圾收集暂停时间： 最大暂停时间目标通过命令行选项 `-XX:MaxGCPauseMillis=<N>` 指定（毫秒）。 默认情况下，没有最大暂停时间目标。 如果指定了暂停时间目标，堆大小和其他与垃圾收集相关的参数都会进行调整，以尽量使垃圾收集暂停时间小于指定值；但是，所需的暂停时间目标不一定总能实现。 这些调整可能会导致垃圾收集器降低应用程序的整体吞吐量。
+ 吞吐量： 吞吐量目标是根据垃圾收集时间与垃圾收集之外的时间（即应用时间）比例来衡量的。 该目标由命令行选项 `-XX:GCTimeRatio=<N>` 指定，它将垃圾收集时间与应用时间的比率设置为 `1/(1+<N>)`。  
  例如，-XX:GCTimeRatio=19 设置的目标是垃圾回收总时间的 1/20 或 5%。 默认值为 99，目标值为垃圾回收时间的 1%。
+ 占用空间：使用选项 `-Xmx<N>` 可指定堆的最大占用空间 。 此外，收集器还有一个隐含的目标，即在满足其他目标的前提下，会尽量减小堆的大小。

### 目标的优先级
首先要实现最长暂停时间目标， 只有在达到目标后，才会考虑吞吐量目标。 同样，只有在实现了前两个目标后，才会考虑堆内存占用的大小。

### 分代大小的调节
每次收集结束后，收集器都会更新统计数据，如平均暂停时间，然后测试是否达到目标，并对分代的大小进行必要的调整。 但是，显式垃圾收集（例如调用 System.gc()）行为不会被统计。

分代的增大和缩小是通过百分比增量来实现的，增量百分比是相对于分代大小的一个固定百分比，这样分代的大小就会逐步增大或缩小。 增长和缩小的速度各不相同。 默认情况下，分代的增长的步长是 20% ，收缩步长是 5% 。 年轻代增长的百分比由命令行选项 `-XX:YoungGenerationSizeIncrement=<Y>` 控制，而 `-XX:TenuredGenerationSizeIncrement=<T>` 控制老年代增长的百分比。 分代缩减的百分比由命令行标志 `-XX:AdaptiveSizeDecrementScaleFactor=<D>` 进行调整。 如果增长的增量为 $X%$，则缩小的减量为 $X/D%$。

如果GC收集器决定在启动时增加分代大小，则会在增量中加入一个补充百分比大小。 这种补充会随着采集次数的增加而减少，不会产生长期影响。 补充的目的是提高启动性能，尽快增加堆大小。 收缩百分比没有补充量。

**如果没有达到最大暂停时间目标，则每次只缩小一个分代的大小。 如果两个分代的暂停时间都超过目标值，则先缩小暂停时间较长的分代。**

如果没有达到吞吐量目标，则会同时增加两代的大小。 每一代的大小都会根据各自对总垃圾收集时间的贡献按比例增加。 例如，如果年轻代的垃圾收集时间占总收集时间的 25%，如果年轻代的增量步长是 20%（`-XX:YoungGenerationSizeIncremen` 指定），那么年轻代的最终增量为 5%。

### Parallel Collector 默认堆大小
除非在命令行中指定了初始堆大小和最大堆大小，否则它们都是根据机器上的物理内存量计算的。

**默认的最大堆大小是物理内存的 $1/4$ ，而初始堆大小是物理内存的 $1/64$。 分配给年轻代的最大空间是堆总大小的 $1/3$。**


## 并行收集器时间过长和内存不足错误
如果垃圾收集（GC）耗时过长，并行收集器就会抛出 `OutOfMemoryError` 。

如果垃圾回收所花费的时间超过总时间的 98%，而回收的堆空间却少于 2%，则会抛出 `OutOfMemoryError` （内存不足错误）。 该功能旨在防止应用程序由于堆太小而长时间缓慢运行，把大量时间花费在 GC上。 如有必要，可在命令行中添加选项 `-XX:-UseGCOverheadLimit` ，禁用该功能。