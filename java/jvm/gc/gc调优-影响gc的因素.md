# 影响GC性能的因素
{docsify-updated}

影响垃圾回收性能的两个最重要因素是:
1. 可用内存总量
2. 专门用于年轻代的堆的比例。

## Total Heap
影响垃圾收集性能的最重要因素是可用内存总量。 因为当分代内存填满时就会进行收集，所以吞吐量与内存大小相关。

### 影响堆分代区大小的选项
有许多选项会影响生成大小。 下图说明了堆中committed space 和 virtual space的区别。 虚拟机初始化时，堆的整个空间都被保留。 保留空间的大小可通过 `-Xmx` 选项指定。 如果 `-Xms` 参数的值小于 `-Xmx` 参数的值，则并非所有预留空间都会立即提交给虚拟机。 未提交的空间在图中标注为 "virtual"。 堆的不同部分，即老年代和年轻代，可以根据需要增长到虚拟空间的极限。

<center><img src="pics/jsgct_dt_006_prm_gn_sz_new.png" alt=""></center>

参数 `-XX:NewRatio` 表示老年代与年轻代的比例关系。

### 堆大小的默认选项值
默认情况下，虚拟机会在每个分代中增大或缩小堆，以尽量将每个分代中可用空间与实时对象占用的空间的比例控制在特定范围内。

该目标范围由选项 `-XX:MinHeapFreeRatio=<minimum>` 和 `-XX:MaxHeapFreeRatio=<maximum>` 以百分比形式设置，总大小的下限为 `-Xms<min>`，上限为 `-Xmx<max>`。

在这些选项中，如果分代中的可用空间百分比低于 40%，那么分代就会扩展，以保持 40% 的可用空间，但不超过分代允许的最大大小。 同样，如果可用空间超过 70%，则分代会收缩，只保留 70% 的可用空间，但以分代的最小大小为限。

以下是有关服务器应用程序堆大小的一般指导原则：
+ 除非存在暂停问题，否则应尽量为虚拟机分配更多内存。 
+ 将 `-Xms` 和 `-Xmx` 设置为相同的值可提高可预测性，因为虚拟机无需做出最重要的大小决定。 
+ 一般来说，随着处理器数量的增加而增加内存，因为可以并行分配。

## 年轻代
除了可用堆内存总量，影响垃圾收集性能的第二大因素是堆中专门用于年轻代的内存比例。 年轻代越大，minor gc 发生的频率就越低。 但是，在堆大小一定的情况下，年轻代越大，意味着老年代越小，这将增加 major gc 的频率。 最佳选择取决于应用程序所分配对象的生命周期分布。

### 年轻代大小配置选项
默认情况下，年轻一代的大小由选项 `-XX:NewRatio` 控制。 

例如，设置 `-XX:NewRatio=3` 意味着年轻一代和老一代的比例是 `1:3`。 选项 `-XX:NewSize` 和 `-XX:MaxNewSize` 可以设置年轻代的最大和最小值。 将这两个选项设置为相同的值，就能固定年轻代的大小，就像将 `-Xms` 和 `-Xmx` 设置为相同的值，就能固定堆的总大小一样。 这样可以提供比 `-XX:NewRatio` 选项提供的比例控制更细粒度调整年轻代大小。

### Survivor 大小配置
可以使用选项 `-XX:SurvivorRatio` 来调整 Survivor 空间的大小，但通常这对性能并不重要。

例如，`-XX:SurvivorRatio=6` 将 Eden 区和一个 Survivor 空间的比例设定为 1:6。 换句话说，每个 Survivor 空间的大小是 Eden 区的六分之一，因此也是年轻代的八分之一（不是七分之一，因为有两个 Survivor 空间）。

如果 Survivor 空间太小，那么 minor gc 后存活的对象就直接溢出到老年代中。 如果生存空间过大，则会无用地空出来。 每次垃圾回收时，虚拟机都会选择一个阈值数来指定一个对象在被复制多少次后会被升级到老年代。 选择这个阈值的目标是让Survivor 区保持半满状态。 可以使用日志配置 `-Xlog:gc,age` 来显示这一阈值和年轻代对象的年龄。 这对观察应用程序的生命周期分布也很有用。


## 一般原则
以下是服务器应用程序的一般指导原则：
+ 首先确定虚拟机所能承受的最大堆大小。 
  + 请注意，最大堆大小应始终小于计算机上安装的内存量，以避免过多的页面故障和中断。 
+ 如果总堆大小是固定的，那么增加年轻代大小就需要减少老年代大小。 保持老年代内存足够大，以容纳应用程序在任何给定时间内使用的所有实时数据，外加一定量的闲置空间（10% 到 20% 或更多）。 
+ 在遵守前面所述的老年代内存限制的前提下：
  + 为年轻一代内存提供足够大的内存。 
  + 随着处理器数量的增加，年轻代内存的大小也会增加，因为分配可以并行化。