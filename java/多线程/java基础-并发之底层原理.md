# 并发的底层原理
{docsify-updated}


## 处理器如何实现原子操作
处理器提供 Lock 前缀的指令，Lock 前缀指令在多核处理器下会引发两件事情：
1. 将当前数据所在的处理器缓存行写回内存。
2. 缓存行写回内存操作在 MESI(修改、独占、共享、无效) 协议下，会使其他处理器里缓存了该数据的缓存行失效，导致重新从内存加载。

### 使用总线锁
处理器提供的一个 `LOCK#` 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

（有个疑问，多线程时，有可能同一个处理器上并发呀，那么处理器级别的独享内存并不能隔离线程？）。
跑在同一个CPU上的线程，共享变量缓存，修改对所有线程可见。

### 使用缓存锁
总线锁会阻塞其他处理器所有的总线请求，假设其他处理器请求访问的不是同一个地址，也会被阻塞，开销会比较大。缓存锁定是指内存如果被缓存到缓存行中的话，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不会在总线上声言 `LOCK#` 信号，缓存一致性机制会使其他处理器缓存的该缓存行失效。

但是有两种情况不会使用缓存锁定：
1. 当操作的数据不能缓存到 cache 中，或操作数跨多个缓存行时，处理器会调用总线锁定。
2. 处理器不支持缓存锁定时。

### 锁
Java SE 1.6 中，锁一共有四种状态，从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁可以升级但不能降级。

#### 偏向锁
HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

#### 轻量级锁


## Java实现原子操作的方式
Java 中可以使用 CAS 和锁来实现原子操作。

### 循环CAS实现原子操作
CMPXCHG:比较交换原子操作指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。多处理器安全，在80486及以上CPU中支持。

比较后交换原子操作原语：

    long __stdcall CompareExchange(long volatile*Destination,long Exchange,long Comperand) 
    { 
        __asm 
        { 
            mov     ecx, Destination; 
            mov     edx, Exchange; 
            mov     eax, Comperand; 
            lock cmpxchg [ecx], edx; 
        } 
    }
注意上述 [ecx] 代表的是共享内存。比较并交换其实是一个 RMW (Read-Modify-Write)操作，若不能保证原子性，就不能保证执行的安全性。
JVM 中如果循环调用上述原语函数，直到 [ecx] 内存处的值被更新为 edx 寄存器中的值，就能提供原子更新的方法。

#### CAS的三大问题
1. ABA 问题


### 使用锁机制实现原子操作
锁机制保证了只有获得了锁的线程才能进入临界区操作锁定的内存区域。JVM 内部实现了多种锁：偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了 CAS，即当一个线程想进入同步块的时候使用循环CAS获取锁，当它退出时，使用循环CAS释放锁。