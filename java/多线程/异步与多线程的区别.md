## 异步编程与多线程编程的关系
{docsiify-updated}

- [异步编程与多线程编程的关系](#异步编程与多线程编程的关系)
	- [同步与异步的概念](#同步与异步的概念)
	- [示例](#示例)


### 同步与异步的概念
Synchronous/Asynchronous HAS NOTHING TO DO WITH MULTI-THREADING. 同步/异步与多线程无关。

Synchronous或Synchronized的意思是以某种方式 "连接 "或 "依赖"。换句话说，两个同步任务必须相互了解，其中一个任务的执行必须以某种方式依赖于另一个任务，如等待另一个任务完成后再开始执行。
异步意味着它们是完全独立的，无论是在启动还是执行过程中，任何一方都不得以任何方式考虑另一方。

Synchronous (单线程):
```
1 thread ->   |<---A---->||<----B---------->||<------C----->|
```

Synchronous (多线程):
```
thread A -> |<---A---->|   
                        \  
thread B ------------>   ->|<----B---------->|   
                                              \   
thread C ---------------------------------->   ->|<------C----->| 
```

Asynchronous (单线程):
```
A-Start ------------------------------------------ A-End   
| B-Start -----------------------------------------|--- B-End   
|    |      C-Start ------------------- C-End      |      |   
|    |       |                           |         |      |
V    V       V                           V         V      V      
1 thread->|<-A-|<--B---|<-C-|-A-|-C-|--A--|-B-|--C-->|---A---->|--B-->| 
```

Asynchronous (多线程):
```
thread A ->     |<---A---->|
thread B ----->     |<----B---------->| 
thread C --------->     |<------C--------->|
```
+ 任务 A、B、C 的起点和终点用 <, > 字符表示。
+ CPU 时间片用竖条表示 |

从技术上讲，同步/异步的概念实际上与线程无关。虽然一般来说，在同一线程上运行异步任务的情况并不多见，但这是有可能的（请参阅下面的示例），而且在不同线程上同步执行两个或多个任务的情况也很常见......不，同步/异步的概念只与第二个或后续任务是否可以在另一个（第一个）任务完成之前启动或是否必须等待有关。仅此而已。至于任务是在什么线程、进程、CPU 或硬件上执行的，都与此无关。事实上，为了说明这一点，我对图形进行了编辑。


### 示例
同步是指调用者等待响应或完成，异步是指调用者继续调用，稍后才有响应（如适用）。

举个例子
```
static void Main(string[] args)
{
    Console.WriteLine("Before call")；
    doSomething()；
    Console.WriteLine("After call")；
}

private static void doSomething()
{
    Console.WriteLine("In call")；
}
```
这将始终输出：
```
Before call
In call
After call
```
但是，如果我们将 doSomething() 设置为异步（有多种实现方式），那么输出结果可能会变为
```
Before call
After call
In call
```

因为进行异步调用的方法会立即继续执行下一行代码。我说 "可以"，是因为异步操作无法保证执行顺序。根据线程时序等因素，它也可能像原来一样执行。