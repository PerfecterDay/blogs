# Shell 脚本
{docsify-updated}

### 基础
在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为:
```
#!/bin/bash
```
在通常的shell脚本中，井号(#)用作注释行。shell并不会处理shell脚本中的注释行。然而，shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本。
```
chmod u+x test1
```

反斜线允许shell脚本将美元符解读为实际的美元符，而不是变量。

#### 定义变量
定义变量时，变量名不加美元符号（$），引用一个变量值时需要使用美元符。如：
```
value1=10
value2=${value1}
```
用户变量区分大小写，使用等号将值赋给用户变量，在变量、等号和值之间不能出现空格。变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界,推荐给所有变量加上花括号，这是个好的编程习惯。  
shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，shell脚本中定义的变量 会一直保持着它们的值，但在shell脚本结束时会被删除掉。

除了显式地直接赋值，还可以用语句给变量赋值，如：
```
for file in `ls /etc`
```

#### 命令执行的结果赋值
shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。
有两种方法可以将命令输出赋给变量:
+ 反引号字符(`)
+ $()格式

```
testing=`date`
testing=$(date)
echo $testing
```

#### 字符串
字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别：
+ 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的
+ 单引号字串中不能出现单引号（对单引号使用转义符后也不行）
+ 双引号里可以有变量
+ 双引号里可以出现转义字符

```
str='this is a string'
your_name='qinjx'
str="Hello, I know your are \"$your_name\"! \n"
```
### 管道
+ 批处理命令连接执行，使用 `|`，前一条指令的输出作为后一条指令的输入
+ 串联: 使用分号 `;`，前一条指令的输出与后一条指令的输入没有关系
+ 前面成功，则执行后面一条，否则，不执行:`&&`
+ 前面失败，则后一条执行: `||`

### 重定向
Linux用文件描述符(file descriptor)来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开 的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文 件描述符(0、1和2):
<center><img src="pics/std-desc.jpg" width="50%" style="inline"></center>

最基本的重定向将命令的标准输出发送到一个文件中。bash shell用大于号(`>`)来完成这项功能：
```
date > test
```
重定向操作符创建了一个文件test6(通过默认的umask设置)，并将date命令的输出重定向 到该文件中。如果输出文件test已经存在了，重定向操作符会用新的文件数据覆盖已有文件。如果不想覆盖文件内容而是追加到文件末尾可以用 `>>`	 追加数据。

标准输入重定向是 `<` ：输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。
+ 标准输入重定向：`<`
+ 标准输出重定向：`>`、`1>`
+ 标准错误输出重定向：`2>`
+ 标准输出和错误重定向：`&>`
+ 标准输出重定向到标准错误：`>&2`
+ 标准错误重定向到标准输出：`2>&1`
+ 在Linux系统上null文件的标准位置是`/dev/null`。你重定向到该位置的任何数据都会被丢掉，不会显示:`ls -al > /dev/null`

在脚本中重定向：
1. 临时重定向：
2. 永久重定向：

默认情况下， `mktemp` 会在本地目录中创建一个文件。要用 `mktemp` 命令在本地目录中创建一 个临时文件，你只要指定一个文件名模板就行了。模板可以包含任意文本文件名，在文件名末尾加上6个X就行了。`-t`选项会强制 `mktemp` 命令来在系统的临时目录`\tmp`来创建该文件。在用这个特性时， `mktemp` 命令会返回用来创建临时文件的全路径，而不是只有文件名。

### 以后台模式运行脚本
以后台模式运行shell脚本非常简单。只要在命令后加个`&`符就行了。当`&`符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后台进程运行。
注意，当后台进程运行时，它仍然会使用终端显示器来显示STDOUT和STDERR消息。

有时你会想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退 出了终端会话。这可以用nohup命令来实现。
nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会 3 话时阻止进程退出。  
由于nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为 nohup.out的文件中。


Linux提供了一个专门的变量`$?`来保存上个已执行命令的退出状态码。一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态码就是一个正数值。
<center><img src="pics/linux-errcode.jpg" width="50%" style="inline"></center>

默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出。exit命令允许你在脚本结束时指定一个退出状态码。
```
exit 0
```
