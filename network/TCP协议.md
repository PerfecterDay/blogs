#  TCP 协议
{docsify-updated}

> https://mp.weixin.qq.com/s/cOXUH8knOomVLGE6YWs9Mg
> https://xiaodongq.github.io/2024/05/18/tcp_connect/

- [TCP 协议](#tcp-协议)
	- [TCP服务概述](#tcp服务概述)
	- [最大报文段长度](#最大报文段长度)
	- [TCP首部](#tcp首部)
	- [TCP连接的建立与关闭——三次握手与四次挥手](#tcp连接的建立与关闭三次握手与四次挥手)
		- [三次握手建立连接](#三次握手建立连接)
		- [四次挥手断开连接](#四次挥手断开连接)
		- [TCP半关闭](#tcp半关闭)
		- [TCP状态变迁](#tcp状态变迁)
		- [2MSL（TIME\_WAIT）等待状态](#2msltime_wait等待状态)
	- [复位报文段](#复位报文段)
	- [TCP的服务器设计](#tcp的服务器设计)
		- [连接队列 （https://www.alibabacloud.com/blog/tcp-syn-queue-and-accept-queue-overflow-explained\_599203）](#连接队列-httpswwwalibabacloudcomblogtcp-syn-queue-and-accept-queue-overflow-explained_599203)
	- [延迟确认与Nagle算法](#延迟确认与nagle算法)
	- [TCP超时重传](#tcp超时重传)


## TCP服务概述
TCP提供一种面向连接的、可靠的字节流服务。
面向连接意味着两个使用TCP的应用在彼此交换数据之前必须先建立一个TCP连接
TCP通过下列方式来提供可靠性：

      1. 应用数据被分割成TCP认为最适合发送的数据块，对比UDP，UDP不会处理应用程序产生的数据报。
      2. 确认机制：接收方收到一个报文段后会向发送方发送一个确认，告诉对方收到了报文段。
      3. 超时重传：TCP发出一个报文段后，启动一个定时器，如果在超时之前没有收到接收方的确认，将会重发这个报文段。TCP协议有自适应的超时及重传策略。
      4. 校验机制：TCP将检查它首部和数据的检验和。如果收到段的检验和有差错，TCP将丢弃这个报文段，也不确认收到此报文段（希望发送端超时并重发）
      5. 保证有序：IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序，如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
      6. 保证无重复：IP数据报会发生重复， TCP的接收端会丢弃重复的数据。
      7. 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

## 最大报文段长度
最大报文段长度(MSS)表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。我们已经见过MSS都是1024。这导致IP数据报通常是40字节长:20字节的TCP首部和20字节的IP首部。
在有些书中，将它看作可“协商”选项。它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项(**MSS选项只能出现在SYN报文段中**)。如果一方不接收来自另一方的MSS值，则MSS就定为默认值**536字节**(这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)。

一般说来，如果没有分段发生，MSS还是越大越好(这也并不总是正确)。报文段越大允许每个报文段传送的数据就越多，相对IP和TCP首部有更高的网络利用率。当TCP发送一个SYN时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它能将MSS值设置为外出接口上的MTU长度减去固定的IP首部和TCP首部长度。对于一个以太网，MSS值可达1460字节。使用IEEE802.3的封装(参见2.2节)，它的MSS可达1452字节。

如果目的IP地址为“非本地的(nonlocal)”，MSS通常的默认值为536。而区分地址是本地还是非本地是简单的，如果目的IP地址的网络号与子网号都和我们的相同，则是本地的;如果目的IP地址的网络号与我们的完全不同，则是非本地的;如果目的IP地址的网络号与我们的相同而子网号与我们的不同，则可能是本地的，也可能是非本地的。大多数TCP实现版都提供了一个配置选项，让系统管理员说明不同的子网是属于本地还是非本地。这个选项的设置将确定MSS可以选择尽可能的大(达到外出接口的MTU长度)或是默认值536。

## TCP首部
<center><img src="pics/tcp.png" alt="" width=40%></center>

+ URG：紧急指针有效
+ ACK：确认序号有效。
+ PSH：接收方应该尽快将这个报文段交给应用层。
+ RST：重建连接。
+ SYN：同步序号用来发起一个连接。
+ FIN：发送端完成发送任务。

## TCP连接的建立与关闭——三次握手与四次挥手
<center><img src="pics/tcp_open_close.png" alt="" width=40%></center>


### 三次握手建立连接

<center><img src="pics/three-handshake.png" alt="" width=40%></center>
1. 请求端（通常称为客户）发送一个 SYN段指明客户打算连接的服务器的端口，以及初始序号。这个SYN段为报文段1。
2. 服务器发回包含服务器的初始序号的 SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。**一个SYN将占用一个序号。**
3.  客户必须将确认序号设置为服务器的 ISN加1以对服务器的SYN报文段进行确认（报文段3）。

### 四次挥手断开连接

<center><img src="pics/four-close.png" alt="" width=40%></center>

1. 首先进行关闭的一方发送第一个 FIN执行主动关闭，而另一方（收到这个 FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭（也可以双方都执行主动关闭）。
2. 当服务器收到这个 FIN，它发回一个ACK，确认序号为收到的序号加 1（报文段5）。**和SYN一样，一个FIN将占用一个序号。**
3. 接着这个服务器程序就关闭它的连接，导致它的 TCP端发送一个FIN（报文段6），客户必须发回一个确认，并将确认序号设置为收到序号加1（报文段7）。

发送FIN将导致应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的。

### TCP半关闭
TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是所谓的半关闭。
<center><img src="pics/half-close.jpg" alt="" width=40%></center>

初始端发出的FIN，接着是另一端对这个FIN的ACK报文段。接收半关闭FIN的一方仍能发送数据。我们只显示一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段。当收到半关闭的一端在完成它的数据传送后，将发送一个FIN关闭这个方向的连接，这将传送一个文件结束符给发起这个半关闭的应用进程。当对第二个FIN进行确认后，这个连接便彻底关闭了。

没有半关闭，需要其他的一些技术让客户通知服务器,客户端已经完成了它的数据传送，但仍要接收来自服务器的数据。使用两个TCP连接也可作为一个选择，但使用半关闭的单连接更好。

### TCP状态变迁
<center><img src="pics/tcp-status.png" alt="" width=45%></center>

### 2MSL（TIME_WAIT）等待状态
TIME_WAIT 状态也称为 2MSL 等待状态。每个具体 TCP实现必须选择一个报文段最大生存时间MSL(Maximum Segment Lifetime) 。它是任何报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为 TCP 报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的 TTL字段。RFC 793 指出MSL为2分钟。然而，实现中的常用值是30秒，1分钟，或2分钟。

为什么需要 2MSL ?  
当 TCP 执行一个主动关闭，并发回最后一个ACK，该连接必须在 TIME_WAIT 状态停留的时间为2倍的MSL。**这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的 FIN）。**

这种2MSL等待的另一个结果是**这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的 IP地址和端口号）不能再被使用。**这个连接只能在 2MSL结束后才能再被使用。大多数 TCP实现（如伯克利版）强加了更为严格的限制。在 2MSL等待期间，插口中使用的本地端口在默认情况下不能再被使用。

大多数TCP实现(如伯克利版)强加了更为严格的限制。在2MSL等待期间，插口中使用的**本地端口在默认情况下不能再被使用。（端口占用）**
某些实现和API提供了一种避开这个限制的方法。使用插口API时，可说明其中`SO_REUSEADDR`选项。它将让调用者对处于2MSL等待的本地端口进行赋值，但我们将看到TCP原则上仍将避免使用仍处于2MSL连接中的端口。

## 复位报文段
TCP首部中的RST比特是用于“复位”的。一般说来，无论何时一个报文段发往基准的连接(referencedconnection)出现错误，TCP都会发出一个复位报文段(这里提到的“基准的连接”是指由目的IP地址和目的端口号以及源IP地址和源端口号指明的连接。)

产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在听。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息。而TCP则使用复位。

产生这个例子也很容易，我们可使用Telnet客户程序来指明一个目的端口没在使用的情况:
<center><img src="pics/rst.jpg"></center>

## TCP的服务器设计
初始 Listen 状态：
<center><img src="pics/tcp-listen.jpg" width="60%"></center>
接收到若干请求后：
<center><img src="pics/tcp_listen_est.jpg" width="60%"></center>

TCP使用由本地地址和远端地址组成的4元组:**目的IP地址、目的端口号、源IP地址和源端口号来处理传入的多个请求。TCP仅通过目的端口号无法确定哪个进程应该处理一个TCP请求。**另外，在三个使用端口23的进程中，只有处于LISTEN的进程能够接收新的连接请求（SYN）。处于ESTABLISHED的进程将不能接收SYN报文段，而处于LISTEN的进程将不能接收数据报文段。

### 连接队列 （https://www.alibabacloud.com/blog/tcp-syn-queue-and-accept-queue-overflow-explained_599203）
当服务器正处于忙时，TCP是如何处理这些呼入的连接请求?
<center><img src="pics/tcp-queue.png" width="50%"></center>

+ 半连接队列，也称 SYN 队列: /proc/sys/net/ipv4/tcp_max_syn_backlog(linux)
+ 全连接队列，也称 accepet 队列:  /proc/sys/net/core/somaxconn(linux)


1. 正等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被TCP接受(即三次握手已经完成)，但还没有被应用层所接受。注意区分TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。
2. 应用层将指明该队列的最大长度，这个值通常称为 **积压值(backlog)** 。它的取值范围是0~5之间的整数，包括0和5(大多数的应用程序都将这个值说明为5)
3. 当一个连接请求(即SYN)到达时，TCP使用一个算法，根据当前连接队列中的连接数来确定是否接收这个连接。我们期望应用层说明的积压值为这一端点所能允许接受连接的最大数目，但情况不是那么简单。注意，积压值说明的是TCP监听的端点已被TCP接受而等待应用层接受的最大连接数。这个积压值对系统所允许的最大连接数，或者并发服务器所能并发处理的客户数，并无影响。
4. 如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间，TCP模块将对SYN进行确认并完成连接的建立。但应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接时。另外，当客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了(如果发生这种情况，服务器的TCP仅将接收的数据放入缓冲队列)。
5. 如果对于新的连接请求，连接队列中已没有空间，TCP将不理会收到的SYN。也不发回任何报文段(即不发回RST)。如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。

## 延迟确认与Nagle算法
通常TCP在接收到数据时并不立即发送ACK;相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送(有时称这种现象为数据捎带ACK)。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送。

在一个Rlogin连接上客户一般每次发送一个字节到服务器，这就产生了一些41字节长的分组:20字节的IP首部、20字节的TCP首部和1个字节的数据。在局域网上，这些小分组(被称为微小分组(tinygram))通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，这些小分组则会增加拥塞出现的可能。一种简单和好的方法就是采用RFC896[Nagle1984]中所建议的Nagle算法。  
该算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的:确认到达得越快，数据也就发送得越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。

但是在有些场景下，必须要实时发送数据，TCP一般提供API选项关闭 Nagle 算法。

## TCP超时重传
对每个连接，TCP管理4个不同的定时器：
1. **重传定时器**使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及一些相关的问题，如拥塞避免。
2. **坚持(persist)定时器**使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。第22章将讨论这个问题。
3. **保活(keepalive)定时器**可检测到一个空闲连接的另一端何时崩溃或重启。
4. **2MSL定时器**测量一个连接处于TIME_WAIT状态的时间。

