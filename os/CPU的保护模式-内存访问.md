## CPU保护模式
{docsify-updated}

- [CPU保护模式](#cpu保护模式)
	- [CPU原理及寄存器](#cpu原理及寄存器)
	- [实模式](#实模式)
	- [保护模式](#保护模式)
			- [CPU进入保护模式的步骤：](#cpu进入保护模式的步骤)
		- [保护模式下的内存访问过程：](#保护模式下的内存访问过程)
			- [分段内存访问（段部件功能）](#分段内存访问段部件功能)
			- [内存分页](#内存分页)
			- [TLB（translation lookaside buffer）](#tlbtranslation-lookaside-buffer)
			- [进程全局空间和局部空间](#进程全局空间和局部空间)


### CPU原理及寄存器
<center>
<img src="pics/cpu.png" width="30%" >
<img src="pics/common-regiisters.png" width="50%">
</center>

### 实模式
实模式等同于8086 模式，在本书中，实模式和16 位保护模式统称16 位模式。在16 位模式下，数据的大小是8 位或者16 位的；控制转移和内存访问时，偏移量也是16 位的。

x86架构的cpu在启动时都是进入的实模式，实模式的特点是：

0. 段式内存访问机制（段基址+段内偏移），操作数一般16位。内存访问方式是段地址*16+偏移地址构成内存的物理地址，且可以通过在程序中修改段基址来访问任意的**真实物理内存**，并修改。这样用户程序与系统程序一样，拥有至高无上的权利甚至，可以修改操作系统的内存。
1. 16位的寄存器，20位地址线，最大只能访问1M内存。
2. 因为只有16位寄存器，所以一个段最多只能是64KB大小，超过这个大小就要**切换段基址**来访问更大范围的内存区域。
3. 一次只能运行一个程序。

写一个实模式的程序，你要了解你的程序将会被加载到内存的什么位置，然后将合适的段加载到内存中合适的位置（没有被他人占用），并且初始化各个数据段寄存器的值，以保证其正确地指向各个段基址。**恶意程序可以访问任意的物理地址，包括更改操作系统占用内存**。

### 保护模式
32 位模式特指IA-32 处理器上的32位保护模式。不存在所谓的32 位实模式，实模式的概念实质上就是8086 模式。

保护模式的一些特性：  

1. 指令寻址方式扩展，操作数扩展到32位。
2. 除段寄存器外，通用寄存器、指令指针寄存器、标志寄存器等都扩展到32位，地址总线和数据总线为32位。
<center>
	<img src="pics/register-extend.png" width="30%">
</center>

3. 通过**段描述符**来描述一段内存，包括段基址、段大小、特权级、权限、属性等等。一系列段描述符组成**全局段描述符表**，存储在内存中。 每个段描述符8个字节，具体格式见下图11-4。
4. GDTR：48位寄存器保存**GDT全局描述符表在内存中的段基址及大小，前32位为GDT在内存中的起始地址，后16位为GDT的大小。所以段描述符表最多存储2^16/2^3=2^13个段**。
5. 对CPU而言，每个程序都可以在全局描述符表中定义自己的段描述符，但是对开发者来说，一般只有操作系统才能访问GDT，普通的用户程序无法访问，核心数据被操作系统保护。处理器规定，GDT 中的第一个描述符必须是空描述符。
6. 保护模式下的段寄存器叫做段选择子，0~1位用来存储RPL（请求特权级），第2位是TI（Table Indicator）标志位，代表段描述符是在GDT还是LDT中（0->GDT，1->LDT），高13位（3-15）位为索引，表示在GDT或者LDT表中的索引。除了段选择子之外，每个段寄存器还包括一个不可见部分，称为**描述符高速缓存器**，里面缓存了从GDT加载的段描述符。这部分内容程序不可访问，由处理器自动使用。这样的话，只要段选择子不变，就可以直接使用缓存的描述符去访问内存，而不需要每次都根据段选择子去GDT/LDT中去获取段描述符，然后访问内存。

<center>
	<img src="pics/segment-descriptor.jpg" width="50%">
</center>

段描述符格式：
+ 32位字段Base Address是段的基址，未开启分页时，就是指明了段在内存中的起始地址
+ 字段DPL是段的权限,指定要访问该段所必须具有的最低特权级
+ S 位用于指定描述符的类型（Descriptor Type）。当该位是“0”时，表示是一个系统段；为“1”时，表示是一个代码段或者数据段（栈段也是特殊的数据段）。
+ 字段Segment Limit表示段的长度，其单位依赖于另外一个字段G（Granularity）。如果字段G的值是0，那么段的长度以字节为单位，最大长度为2^20 × 1字节，即1MB；如果字段G的值是1，那么段的长度以4KB为单位，段的最大长度可达2^20 × 4KB，即4GB。64位CPU可寻址的长度要远远大于4GB，那么这怎么应对呢？事实上，虽然不是完全的，但64位CPU基本上禁用了段模式，忽略段界限的检查
+ P 是段存在位（Segment Present）。P 位用于指示描述符所对应的段是否存在。一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的P 位清零，表示段并不存在。另外，同样是在内存空间紧张的情况下，会把很少用到的段换出到硬盘中，腾出空间给当前急需内存的程序使用（当前正在执行的），这时，同样要把段描述符的P 位清零。当再次轮到它执行时，再装入内存，然后将P位置1。
+ D/B 位是“默认的操作数大小”（Default Operation Size）或者“默认的栈指针大小” （Default Stack Pointer Size ），又或者“ 上部边界”（Upper Bound）标志。  
  该标志位对不同的段有不同的效果。对于代码段，此位称做“D”位，用于指示指令中默认的偏移地址和操作数尺寸。D＝0 表示指令中的偏移地址或者操作数是16 位的；D＝1，指示32 位的偏移地址或者操作数。  
  对于栈段来说，该位被叫做“B”位，用于在进行隐式的栈操作时，是使用SP 寄存器还是ESP 寄存器。隐式的栈操作指令包括push、pop 和call 等。如果该位是“0”，在访问那个段时，使用SP 寄存器，否则就是使用ESP 寄存器。同时，B 位的值也决定了栈的上部边界。如果B＝0，那么栈段的上部边界（也就是SP 寄存器的最大值）为0xFFFF；如果B＝1 ， 那么栈段的上部边界（也就是ESP寄存器的最大值）为0xFFFFFFFF。
+ L 位是64 位代码段标志（64-bit Code Segment），保留此位给64位处理器使用
+ TYPE 字段共4 位，用于指示描述符的子类型，或者说是类别，结合S位和下表中的E位就可以识别是代码段还是数据段：S=1, E=0 -> 数据段； S=1, E=1 -> 代码段
  <center>
	<img src="pics/segment-type.jpg" width="50%"></img>
  </center>

##### CPU进入保护模式的步骤：
1. 打开A20地址线(将端口 0x92 的第1位置1)
2. 填写GDT表并将其加载到 GDTR
3. 将CR0寄存器的PE位置1。

#### 保护模式下的内存访问过程：

##### 分段内存访问（段部件功能）
<center>
<img src="pics/segment.png" width="80%"><br/>
</center>

因为
1. 段描述符（段描述符表）是在内存中，访问内存比较慢
2. 段描述符格式怪异（历史原因），CPU需要额外操作对其进行整合才能根据其中的内容访问内存。
所以，有个**段描述符缓冲寄存器**，根据局部性原理，访问一个断后一段时间内将会继续访问该段，段描述符缓冲寄存器用来缓存段描述符避免重复计算。

每个段描述符都对应着一个内存段。很显然，在一个任务的全局地址空间上，可以划分出2^13 个段，也就是8192 个段。因为GDT 的0 号描述符不能使用，故实际上是8191 个段，但这无关紧要。又因为段内偏移是32 位的，段的长度最大的4GB，因此，一个任务的全局地址空间，其总大小为2^13 ×2^32 ＝2^45 字节，即32TB。

同样的道理，局部描述符表LDT 可以定义2^13 个，也就是8192 个描述符，每个段的最大长度也是4GB，故，一个任务的局部地址空间为2^13×2^32 ＝2^45 字节，同样是32TB。这样一来，每个任务的总地址空间为64TB。在一个只有32 根地址线的处理器上，无论如何也不可能提供这样巨大的存储空间，但是，不要紧张，这只是虚假的，或者说虚拟的地址空间。操作系统允许程序的编写者使用该地址空间来写程序，即，使用虚拟地址或者逻辑地址来访问内存，就像他真的拥有这么巨大的地址空间一样。

上面一段话可以这样理解：编译器不考虑处理器可寻址空间的大小，也不考虑物理内存的大小，它只是负责编译程序。当程序编译时，编译器允许生成非常巨大的程序。但是，当程序超出了物理内存的大小时，或者操作系统无法分配这么大的物理内存空间时，怎么办呢？同一块物理内存，可以让多个任务，或者每个任务的不同段来使用。当执行或者访问一个新的段时，如果它不在物理内存中，而且也没有空闲的物理内存空间来加载它，那么，操作系统将挑出一个暂时用不到的段，把它换出到磁盘中，并把那个腾出来的空间分配给马上要访问的段，并修改段的描述符，使之指向这段内存空间。下一次，当被换出的那个段马上又要用到时，再按相同的办法换回到物理内存。所有这一切，任务（如果它有思维的话）和程序的编写者是不必关心的，这就是虚拟内存管理的一般方法。

总体上看，一个进程在分页机制下的物理表现就是在GDT（内核进程）或LDT（用户进程），分配了一些段描述符用于描述程序的代码/数据/栈等内存段。

##### 内存分页
当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后，到真正开始加载程序时，再把原本属于段的数据按页的尺寸拆开，分开写入对应的页中。

从段部件输出的是线性地址，或者叫虚拟地址。为了根据线性地址找到页的物理地址，操作系统必须维护一张页表，把**线性地址转换成物理地址**，这是一个反过程。一级页表概念如下：
<center>
	<img src="pics/page-table.jpg" width="30%">
</center>

32位线性地址的高20位是页表索引，页表物理地址（CR3中）+索引值x4就可以获得页表项的物理地址，每一个页表项保存了当前页在内存中的物理地址，使用该地址就能访问到对应的物理页表。低12位是页内偏移量，用来在4KB的页中进行页内索引。


开启二级分页后的内存访问：
<center>
	<img src="pics/secondary-page-table.png" width="50%">
</center>

既然有了一级页表，为什么还 要搞个二级页表呢?理由如下。
1. 一级页表中最多可容纳 1M(2的20次方)个页表项，每个页表项是 4 字节，如果页表项全满的话， 便是 4MB 大小，而且也必须要求是连续的内存空间，很难找到。使用二级页表的话，页目录表4KB，二级页表4KB，只需要4KB即可分配（但是完全4GB的话，也需要4MB一、二级页表来存储，但是可以离散存储）。
2. 一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB， 用户进程要占用低 3GB。
3. 每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了。 
归根结底，我们要解决的是:不要一次性地将全部页表项建好，需要时动态创建页表项。
4. 分页存储管理系统是离散分配，页表是连续存储，所以单个页表大小不得超过系统最大连续可分配单元，这个单元就是单个页面的大小。如果一个页表的大小超过了一个页面（假如是两个页面），那么分页存储管理系统只能分配两个离散的页面存储这个页表，可是PTR（页表寄存器）只有页表始址和页表长度，它默认页表是连续的。为了可以检索两个页面大小的页表，需要另外一个页表来索引这两个离散的页表页面，这就是二级页表。当然如果二级页表也超过了单个页面的大小，那么就需要三级页表，以此类推。

启用分页机制:
1. 准备好页目录表及页表。 
2. 将页表地址写入控制寄存器 cr3（页目录基址寄存器PDTR）。 
3. 寄存器 cr0 的 PG 位置 1。

##### TLB（translation lookaside buffer）
开启了分页后，由于在地址转换过程中需要经历好几张表的查询，效率比较低。为了提高效率，CPU内部做了一个表，称为**TLB表**，用来记录相应的虚拟地址和物理地址。**TLB表在CPU内部，所以和读写寄存器的速度一样**。
TLB的结构如下图：

<center>
<img src="pics/tlb.jpg" width="40%"/>
</center>


##### 进程全局空间和局部空间
分页后每个进程都会有一个页表与之对应：

<center>
<img src="pics/process_page_table.png" width="20%"/>
</center>

每个进程实际上包括两个部分：全局部分和私有部分。全局部分是所有任务共有的，含有操作系统的软件和库程序，以及可以调用的系统服务和数据；私有部分则是每个任务各自的数据和代码，与任务所要解决的具体问题有关，彼此并不相同。  
实际上是在内存中运行的，所以，所谓的全局部分和私有部分，其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间。
地址空间的访问是依靠分段机制来进行的。具体地说，需要先在描述符表中定义各个段的描述符，然后再通过描述符来访问它们。因此，全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间则是由每个任务私有的局部描述符表（LDT）来定义的。

任务的全局空间包含了操作系统的段，是由别人编写的，但是他可以调用这些段的代码，或者获取这些段中的数据；任务局部空间的内容是由程序员自己创建的。通常，任务会在自己的局部空间运行，当它需要操作系统提供的服务时，转入全局空间执行。