## CPU保护模式
{docsify-updated}

- [CPU保护模式](#cpu保护模式)
  - [特权级](#特权级)
    - [特权级深入浅出](#特权级深入浅出)
    - [普通应用程序/进程的特权级](#普通应用程序进程的特权级)
    - [RPL](#rpl)
      - [调用门](#调用门)


### 特权级
1. CPU分为4个特权级 ring0/1/2/3，现代操作系统一般只用了0和3，不同特权级下的权限不同，比如一些特权指令只能在0下运行。
2. 每个特权级下都有一个独立的栈，所以最多有4个特权级栈，切换特权级时，也要切换栈。所以说**系统调用是需要开销的**(除了栈切换，还有参数传递和上下文切换的开销)

#### 特权级深入浅出
+ CPL:(Current Privilege Level):处理器的当前特权级，CS 中选择子的最低两位就是当前特权级的数值。
+ DPL:(Descriptor Privilege Level):描述符特权级，即段描述符中DPL字段指定的该段的特权级。

对于数据段的访问，DPL 决定了访问它们所应当具备的最低特权级别。如果有一个数据段，其描述符的DPL 字段为2，那么，只有特权级为0、1 和2 的程序才能访问它。当一个特权级为3 的程序也试图去读写该段时，将会被处理器阻止，并引发异常中断。对任何段的访问都要先把它的描述符加载到段寄存器，所以这种保护手段很容易实现。

代码段的特权级检查是很严格的。一般来说，控制转移只允许发生在两个特权级相同的代码段之间。如果当前特权级为2，那么，它可以转移到另一个DPL 为2 的代码段接着执行，但不允许转移到DPL 为0、1 和3 的代码段执行。不过，为了让特权级低的应用程序可以调用特权级高的操作系统例程，处理器也提供了相应的解决办法。
+ 第一种方法是将高特权级的代码段定义为依从的。段描述符的TYPE 字段。代码段描述符的TYPE字段有C 位，如果C＝0，这样的代码段只能供同特权级的程序使用；否则，如果C＝1，则这样的代码段称为依从的代码段，可以从特权级比它低的程序调用并进入。  
  但是，即使是将控制转移到依从的代码段，也是有条件的，要求当前特权级CPL 必须低于或者等于目标代码段描述符的DPL。即，在数值上：CPL >= 依从代码段的DPL  
  依从的代码段不是在它的DPL 特权级上运行，而是在调用程序的特权级上运行。就是说，当控制转移到依从的代码段上执行时，不改变当前特权级CPL，段寄存器CS 的CPL 字段不发生变化，被调用过程的特权级依从于调用者的特权级，这就是为什么它被称为“依从的”代码段。
+ 另一种在特权级之间转移控制的方法是使用门。门（Gate）是另一种形式的描述符，称为门描述符，简称门。和段描述符不同，段描述符用于描述内存段，门描述符则用于描述可执行的代码，比如一段程序、一个过程（例程）或者一个任务。

除了从高特权级别的例程（通常是系统调用）返回外，**不允许从特权级高的代码段将控制转移到特权级低的代码段**，因为操作系统不会引用可靠性比自己低的代码。

#### 普通应用程序/进程的特权级
普通的应用程序则工作在特权级别3 上。没有人愿意将自己的程序放在特权级3 上，但是，只要你在某个操作系统上面写程序，这就由不得你。应用程序编写时，不需要考虑GDT、LDT、分段、描述符这些东西，它们是在程序加载时，由操作系统负责创建的，应用程序的编写者只负责具体的功能就可以了。应用程序的加载和开始执行，也是由操作系统所主导的，而操作系统一定会将它放在特权级3 上。当应用程序开始执行时，当前特权级CPL 自然就会是3。

这实际上就是把一个任务分成特权级截然不同的两个部分，全局部分是特权级0 的，而局部空间则是特权级3 的。这种划分是有好处的，全局空间是为所有任务服务的，其重要性不言而喻。为了保证它的安全性，并能够访问所有软硬件资源，应该使它拥有最高的特权级别。当任务在自己的局部空间内执行时，当前特权级CPL 是3；当它通过调用系统服务，进入操作系统内核，在全局空间执行时，当前特权级CPL 就变成了0。总之，很重要的一点是，不能僵化地看待任务和任务的特权级别。


#### RPL
考虑下面的问题：  
假如我们现在需要调用系统调用读取硬盘数据到一块内存，需要向系统调用提供若干参数，其中一个参数指明读出的数据存放到内存地址（内存段选择子），正常情况下用户所提交的缓冲区的选择子指向用户自己的数据段。但是，倘若用户程序怀着一颗有非法企图的心，将参数—缓冲区所在数据段的选择子，用内核数据段的选择子代替(用多个选择子测试几次数据便可推测内核数据段)，这样就把内核破坏了。

<center>
   <img src="pics/cheat-rpl.png" width="60%"/>
</center>


这就需要RPL来解决了：  
RPL（Request Privilege Level):请求者特权级，保存在选择子的低两位。当用户程序请求操作系统服务，如果需要提交选择子作为参数，为安全起见，操作系统会把选择子中的 RPL 改为用户程序的 CPL，为此，处理器还提供了修改 rpl 的相关指令。
用户程序的 CPL 是不会骗人的，不可能伪造，它起始是由操作系统在加载用户程序时赋予的，记录在段 寄存器 CS 中的低 2 位，就是 RPL 的位置，而 CS 寄存器只能通过 call、jmp、ret、int、sysenter 等指令修改， 即使改的话，用户程序也只能在 3 级特权下折腾，只要用户进程不请求操作系统服务，它的 CPL 是不会变的， 当它申请了系统服务，如果提交了选择子作为参数，选择子中的 RPL 也会被操作系统修改为用户进程的 CPL。 所以，即使用户程序提交了个伪造的选择子也没用，其 RPL 会被操作系统用其 CPL 替换，还其“真身”。

有了RPL，特权检查时要求如下：
1. 数据段  
	`数值上 CPL <= DPL 并且 RPL <= DPL`
2. 代码段  
	在不通过调用门、直接访问代码段时：
   + 如果目标为非一致性代码段，要求:
   	`数值上 CPL=RPL=目标代码段 DPL`
   + 如果目标为一致性代码段，要求:
   	`数值上(CPL>= 目标代码段 DPL && RPL >= 目标代码段 DPL)`
     受访者若为代码，只有在特权级转移时才会被用到，所以有关代码的特权检查都发生在能够改变代码 段寄存器 CS 和指令指针寄存器 EIP 的指令中，即这些指令要么改变 EIP，要么改变 CS 和 EIP。例如 call、 jmp、int、ret、sysexit 等能改变程序执行流的指令。
3. 栈段  
	栈段的特权级检查比较特殊，因为在各个特权级下，处理器都要有相应的栈(后面会说到)，也就是说栈的特权等级要和 CPL 相同。所以往段寄存器 SS 中赋予数据段选择子时，处理器要求 CPL 等于栈段 选择子对应的数据段的 DPL，即数值上 `CPL = RPL = 用作栈的目标数据段 DPL`。

##### 调用门
调用门（Call-Gate）用于在不同特权级的程序之间进行控制转移。本质上，它只是一个描述符，一个不同于代码段和数据段的描述符，可以安装在GDT 或者LDT 中。
<center>
<img src="pics/call-gate.jpg" width="40%">
</center>

+ 调用门描述符给出了例程所在代码段的选择子
+ 例程在代码段中的偏移量也是在描述符中直接指定的，只是被分成了两个16 位的部分
+ 描述符中的TYPE 字段用于标识门的类型，共4 比特，值“1100”表示调用门。
+ 通过调用门实施特权级之间的控制转移时，可以使用jmp far 指令，也可以使用call far 指令。如果是后者，会改变当前特权级CPL。因为栈段的特权级必须同当前特权级保持一致，因此，还要切换栈，即，从低特权级的栈切换到高特权级的栈。比如，一个特权级为3 的程序必须使用自己的3 特权级栈工作。当它通过调用门进入0 特权级的代码段执行时，当前特权级由3 变为0。此时，栈也要跟着切换，从3 特权级的栈切换到0特权级的栈。这主要是为了防止因栈空间不足而产生不可预料的问题，同时也是为了防止栈数据的交叉引用。  
  因此，为了切换栈，每个任务除了自己固有的栈之外，还必须额外定义几套栈，具体数量取决于任务的特权级别。这些额外的栈，也会由操作系统加载程序时自动创建。
+ 通过调用门使用高特权级的例程服务时，调用者会传递一些参数给例程。如果是通过寄存器传送，这没有什么可说的。不过，要传递的参数很多时，更经常的做法是通过栈进行。调用者把参数压入栈，例程从栈中取出参数。在高级语言里，这是一贯的做法。因此，门描述符中有个参数个数字段。
+ 调用门描述符中的DPL 和目标代码段描述符的DPL 用于决定哪些特权级的程序可以访问此门。具体的规则是必须同时符合以下两个条件才行：
  1. 当前特权级CPL 和请求特权级RPL 高于，或者和调用门描述符特权级DPL 相同。即，在数值上: `CPL <= 门描述符的DPL 且 RPL <= 门描述符的DPL`
  2. 当前特权级CPL 低于，或者和目标代码段描述符特权级DPL 相同。即，在数值上：`CPL >= 目标代码段描述符的DPL`

<center>
   <img src="pics/door.png" width="50%">
</center>

