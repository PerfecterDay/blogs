# 内存映射 mmap
{docsify-updated}

mmap()系统调用在调用进程的虚拟地址空间中创建一个新内存映射。映射分为两种：

+ 文件映射：文件映射将一个文件的一部分直接映射到调用进程的虚拟内存中。一旦一个文件被映射之后就可以通过在相应的内存区域中操作字节来访问文件内容了。映射的分页会在需要的时候从文件中（自动）加载。这种映射也被称为基于文件的映射或内存映射文件。 
+ 匿名映射：一个匿名映射没有对应的文件。相反，这种映射的分页会被初始化为 0。另一种看待匿名映射的角度（并且也接近于事实）是把它看成是一个内容总是被初始化为 0 的虚拟文件的映射。

一个进程的映射中的内存可以与其他进程中的映射共享（即各个进程的页表条目指向RAM中相同分页）。这种行为会在两种情况下发生：

+ 当两个进程映射了一个文件的同一个区域时它们会共享物理内存的相同分页。
+ 通过 fork()创建的子进程会继承其父进程的映射的副本，并且这些映射所引用的物理内存分页与父进程中相应映射所引用的分页相同。

当两个或更多个进程共享相同分页时，每个进程都有可能会看到其他进程对分页内容做出的变更，当然这要取决于映射是私有的还是共享的。

+ 私有映射（MAP_PRIVATE）：**在映射内容上发生的变更对其他进程不可见，对于文件映射来讲，变更将不会在底层文件上进行**。尽管一个私有映射的分页在上面介绍的情况中初始时是共享的，但对映射内容所做出的变更对各个进程来讲则是私有的。**内核使用了写时复制（copy-on-write）技术完成了这个任务。这意味着每当一个进程试图修改一个分页的内容时，内核首先会为该进程创建一个新分页并将需修改的分页中的内容复制到新分页中（以及调整进程的页表）。正因为这个原因，MAP_PRIVATE 映射有时候会被称为私有、写时复制映射**。
+ 共享映射（MAP_SHARED）：**在映射内容上发生的变更对所有共享同一个映射的其他进程都可见，对于文件映射来讲，变更将会发生在底层的文件上。**

## 创建内存映射

```C
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
```
addr 参数指定了映射被放置的虚拟地址。如果将 addr 指定为 NULL，那么内核会为映射选择一个合适的地址。这是创建映射的首选做法。或者在 addr 中指定一个非 NULL 值时，内核会在选择将映射放置在何处时将这个参数值作为一个提示信息来处理。在实践中，内核至少会将指定的地址舍入到最近的一个分页边界处。不管采用何种方式，内核会选择一个不与任何既有映射冲突的地址。（如果在 flags 包含了 MAP_FIXED，那么 addr 必须是分页对齐的。）

成功时 mmap()会返回新映射的起始地址。发生错误时 mmap()会返回 `MAP_FAILED` 。

length 参数指定了映射的字节数。尽管 length 无需是一个系统分页大小（sysconf(_SC_PAGESIZE)返回值）的倍数，但内核会以分页大小为单位来创建映射，因此实际上 length 会被向上提升为分页大小的下一个倍数。 

prot 参数是一个位掩码，它指定了施加于映射之上的保护信息，其取值要么是PROT_NONE，要么是表 49-2 中列出的其他三个标记的组合（取 OR, |）。
<center><img src="pics/mmap1.png" width="60%"></center>

如果一个进程在访问一个内存区域时违反了该区域上的保护位，那么内核会向该进程发送一个 `SIGSEGV` 信号。内存保护信息驻留在**进程私有的虚拟内存表(页表)中**。因此，不同的进程可能会使用不同的保护位来映射同一个内存区域。

flags 参数是一个控制映射操作各个方面的选项的位掩码。这个掩码必须只包含下列值中一个:
+ `MAP_PRIVATE`
+ `MAP_SHARED`

剩余的参数fd 和 offset 是用于文件映射的（匿名映射将忽略它们）。fd 参数是一个标识被映射的文件的文件描述符。offset 参数指定了映射在文件中的起点，它必须是系统分页大小的倍数。要映射整个文件就需要将 offset 指定为 0 并且将 length 指定为文件大小。

## 取消内存映射 munmap()

```C
#include <sys/mman.h>
void munmap(void *addr, size_t length)
```
addr 参数是待解除映射的地址范围的起始地址，它必须与一个分页边界对齐。（SUSv3 规定 addr 必须是分页对齐的。SUSv4 表示一个实现可以要求这个参数是分页对齐的。）  
length 参数是一个非负整数，它指定了待解除映射区域的大小（字节数）。范围为系统分页大小的下一个倍数的地址空间将会被解除映射。

一般来讲通常会解除整个映射。因此可以将 addr 指定为上一个 mmap()调用返回的地址，并且 length 的值与 mmap()调用中使用的 length 的值一样。

或者也可以解除一个映射中的部分映射，这样原来的映射要么会收缩，要么会被分成两个，这取决于在何处开始解除映射。还可以指定一个跨越多个映射的地址范围，这样的话所有在范围内的映射都会被解除。

如果在由 addr 和 length 指定的地址范围中不存在映射，那么 munmap()将不起任何作用并返回 0（表示成功）。

在解除映射期间，内核会删除进程持有的在指定地址范围内的所有内存锁。（内存锁是通过 mlock()或 mlockall()来建立的，50.2 节将会对此予以介绍。）

当一个进程终止或执行了一个 exec()之后进程中所有的映射会自动被解除。

为确保一个共享文件映射的内容会被写入到底层文件中，在使用 munmap()解除一个映射之前需要调用 msync()。

## 文件映射
要创建一个文件映射需要执行下面的步骤。

1. 获取文件的一个描述符，通常通过调用 open()来完成。
2. 将文件描述符作为 fd 参数传入 mmap()调用。

执行上述步骤之后 mmap()会将打开的文件的内容映射到调用进程的地址空间中。一旦mmap()被调用之后就能够关闭文件描述符了，而不会对映射产生任何影响。但在一些情况下，将这个文件描述符保持在打开状态可能是有用的。
<center><img src="pics/filemap.png" width="30%"></center>

在 Linux 上，一个文件映射的分页会在首次被访问时被映射进内存。这意味着如果在mmap()调用之后修改了文件区域，但映射的对应部分（即分页）还没有被访问过，那么如果相应分页还没有被加载进内存的话，变更对这个进程可能是可见的。这个行为是依赖于实现的，可移植的应用程序应该避免依赖某个特定内核在这种场景中的行为。如下代码：

```C
int main(int argc, char const *argv[])
{
    int fd = open("c.txt", O_RDWR);
    // printf("%d",fd);
    char *ptr = mmap(NULL, 128, PROT_WRITE, MAP_SHARED, fd, 0);
    sleep(20);
    if (ptr == MAP_FAILED)
    {
       printf("失败");
    }
    
    close(fd);
    write(1,ptr,128);
    ptr[0] = 'x';
    ptr[1] = 'y';
    ptr[2] = 'z';
    return 0;
}
```
sleep(20) 之后，如果修改了文件 c.txt 的内容，会导致输出的内容是修改后的内容。

### 私有文件映射
私有文件映射最常见的两个用途如下所述：
+ 允许多个执行同一个程序或使用同一个共享库的进程共享同样的（只读的）文本段，它是从底层可执行文件或库文件的相应部分映射而来的。
+ 映射一个可执行文件或共享库的初始化数据段。这种映射会被处理成私有使得对映射数据段内容的变更不会发生在底层文件上。

mmap()的这两种用法通常对程序是不可见的，因为这些映射是由程序加载器和动态链接器创建的。可以在 `/proc/PID/maps` 的输出中发现这两种映射。

### 共享文件映射
当多个进程创建了同一个文件区域的共享映射时，它们会共享同样的内存物理分页。此外，对映射内容的变更将会反应到文件上。实际上，这个文件被当成了该块内存区域的分页存储:
<center><img src="pics/share-mmap.png" width="30%"></center>

共享文件映射存在两个用途：内存映射 I/O 和 IPC。

#### 内存映射 I/O
由于共享文件映射中的内容是从文件初始化而来的，并且对映射内容所做出的变更都会自动反应到文件上，因此可以简单地通过访问内存中的字节来执行文件 I/O，而依靠内核来确保对内存的变更会被传递到映射文件中。（一般来讲，一个程序会定义一个结构化数据类型来与磁盘文件中的内容对应起来，然后使用该数据类型来转换映射的内容。）这项技术被称为**内存映射 I/O**，它是使用 read()和 write()来访问文件内容这种方法的替代方案。

内存映射 I/O 具备两个潜在的优势。
+ 使用内存访问来取代 read()和 write()系统调用能够简化一些应用程序的逻辑。
+ 在一些情况下，它能够比使用传统的 I/O 系统调用执行文件 I/O 这种做法提供更好的性能。

内存映射 I/O 之所以能够带来性能优势的原因如下：
+ 正常的 read()或 write()需要两次传输：一次是在文件和内核高速缓冲区之间，另一次是在高速缓冲区和用户空间缓冲区之间。使用 mmap()就无需第二次传输了。对于输入来讲，一旦内核将相应的文件块映射进内存之后用户进程就能够使用这些数据了。对于输出来讲，用户进程仅仅需要修改内存中的内容，然后可以依靠内核内存管理器来自动更新底层的文件。
+ 除了节省了内核空间和用户空间之间的一次传输之外，mmap()还能够通过减少所需使用的内存来提升性能。当使用 read()或 write()时，数据将被保存在两个缓冲区中：一个位于用户空间，另一个位于内核空间。当使用 mmap()时，内核空间和用户空间会共享同一个缓冲区。此外，如果多个进程正在在同一个文件上执行 I/O，那么它们通过使用 mmap()就能够共享同一个内核缓冲区，从而又能够节省内存的消耗。

**内存映射 I/O 所带来的性能优势在在大型文件中执行重复随机访问时最有可能体现出来**。如果顺序地访问一个文件，并假设执行I/O 时使用的缓冲区大小足够大以至于能够避免执行大量的I/O 系统调用，那么与 read()和 write()相比，mmap()带来的性能上的提升就非常有限或者说根本就没有带来性能上的提升。性能提升的幅度之所以非常有限的原因是不管使用何种技术，整个文件的内容在磁盘和内存之间只传输一次，效率的提高主要得益于减少了用户空间和内核空间之间的一次数据传输，并且与磁盘I/O 所需的时间相比，内存使用量的降低通常是可以忽略的。

#### 使用共享文件映射的 IPC
由于所有使用同样文件区域的共享映射的进程共享同样的内存物理分页，因此共享文件映射的第二个用途是作为一种（快速的）IPC 方法。这种共享内存区域与System V 共享内存对象之间的区别在于区域中内容上的变更会反应到底层的映射文件上。这种特性对那些需要共享内存内容在应用程序或系统重启时能够持久化的应用程序来讲是非常有用的。

### 边界情况
<center>
<img src="pics/mmap-boundary1.png" width="40%"> <img src="pics/mmap-boundary2.png" width="40%">
</center>
