# 定时器与休眠
{docsify-updated}

## 间隔定时器
系统调用 setitimer()创建一个间隔式定时器(interval timer)，这种定时器会在未来某个时间点到期，并于此后(可选择地)每隔一段时间到期一次。
```
#include<sys/time.h>
int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);

struct  itimerval {
	struct  timeval it_interval;    /* timer interval */
	struct  timeval it_value;       /* current value */
};

struct timeval
{
	time_t         tv_sec;         /* seconds */
    suseconds_t    tv_usec;        /* and microseconds */
};
```
过在调用 setitimer()时为 which 指定以下值，进程可以创建 3 种不同类型的定时器:
+ ITIMER_REAL
  创建以真实时间倒计时的定时器。到期时会产生 SIGALARM 信号并发送给进程。
+ ITIMER_VIRTUAL
  创建以进程虚拟时间(用户模式下的 CPU 时间)倒计时的定时器。到期时会产生信号 SIGVTALRM。
+ ITIMER_PROF
  创建一个 profiling 定时器，以进程时间(用户态与内核态 CPU 时间的总和)倒计时。到期时，则会产生 SIGPROF 信号。

对所有这些信号的默认处置(disposition)均会终止进程。除非真地期望如此，否则就需要针对这些定时器信号创建处理器函数。

参数 new_value 的下属结构 it_value 指定了距离定时器到期的延迟时间。另一下属结构 it_interval 则说明该定时器是否为周期性定时器。如果 it_interval 的两个字段值均为 0，那么该定时器就属于在 it_value 所指定的时间间隔后到期的一次性定时器。只要 it_interval 中的任一 字段非 0，那么在每次定时器到期之后，都会将定时器重置为在指定间隔后再次到期。

若参数 old_value 不为 NULL，则以其所指向的 itimerval 结构来返回定时器的前一设置。 如果 old_value.it_value 的两个字段值均为 0，那么该定时器之前处于屏蔽状态。如果 old_value.it_interval 的两个字段值均为 0，那么该定时器之前被设置为历经 old_value.it_value 指定 时间而到期的一次性定时器。对于需要在新定时器到期后将其还原的情况而言，获取定时器的 前一设置就很重要。如果不关心定时器的前一设置，可以将 old_value 置为 NULL。

```
#include<sys/time.h>
int getitimer(int which, struct itimerval *curr_value)
```
系统调用 getitimer()返回由 which 指定定时器的当前状态，并置于由 curr_value 所指向的 缓冲区中。这与 setitimer()借参数 old_value 所返回的信息完全相同，区别则在于 getitimer()无需为 了获取这些信息而改变定时器的设置。子结构 curr_value.it_value 返回距离下一次到期所剩余 的总时间。该值会随定时器倒计时而变化，如果设置定时器时将 it_interval 置为非 0 值，那么 会在定时器到期时将其重置。子结构 curr_value.it_interval 返回定时器的间隔时间，除非再次 调用 setitimer()，否则该值一直保持不变。

## 定时器的调度及精度
取决于当前负载和对进程的调度，系统可能会在定时器到期的瞬间(通常是几分之一秒) 之后才去调度其所属进程。尽管如此，由 setitimer()或本章后续介绍的其他接口所创建的周 期性定时器，在到期后依然会恪守其规律性。例如，假设设置一个实时定时器每两秒到期一 次，虽然上述延迟可能会影响每个定时器事件的送达，但系统对后续定时器到期的调度依然 会严格遵循两秒的时间间隔。换言之，间隔式定时器不受潜在错误左右。

虽然 setitimer()使用的 timeval 结构提供有微秒级精度，但是传统意义上定时器精度还是受 制于软件时钟(10.6 节)频率。如果定时器值未能与软件时钟间隔的倍数严格匹配，那么定时器 值则会向上取整。也就是说，假如有一个间隔为 19100 微秒(刚刚超过 19 毫秒)的定时器，如果 jiffy(软件时钟周期)为 4 毫秒，那么定时器实际上会每隔 20 毫秒过期一次。

对于现代 Linux 内核而言，适才关于定时器分辨率受限于软件时钟频率的论断已经不再成立。自版本 2.6.21 开始，Linux 内核可选择是否支持高分辨率定时器。如果选择支持(通过内核配置选项CONFIG_HIGH_RES_TIMERS)，那么本章各种定时器以及休眠接口的的精度则不再受内核 jiffy(软件时钟周期)的影响，可以达到底层硬件所支持的精度。在现代硬件平台上，精度达到微秒级是司空见惯的事情。函数 clock_getres()，可以用其返回值来判断系统是否支持高分辨率定时器。