## 文件IO
{docsify-updated}

- [文件IO](#文件io)
  - [通用 I/O 模型的系统调用API](#通用-io-模型的系统调用api)
  - [设置文件读写位置](#设置文件读写位置)
    - [文件空洞](#文件空洞)
  - [通用 I/O 模型以外的操作:ioctl()](#通用-io-模型以外的操作ioctl)
  - [文件描述符和打开文件之间的关系](#文件描述符和打开文件之间的关系)


### 通用 I/O 模型的系统调用API
+ `fd = open(pathname, flags, mode)`  
    函数打开 pathname 所标识的文件，并返回文件描 述符，用以在后续函数调用中指代打开的文件。如果文件不存在，open()函数可以 创建之，这取决于对位掩码参数 flags 的设置。flags 参数还可指定文件的打开方式:只 读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限， 如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。
+ `numread = read(fd, buffer, count)`  
    调用从 fd 所指代的打开文件中读取至多 count 字节的 数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节 可读(例如:读到文件结尾符 EOF 时)，则返回值为 0。
+ `numwritten = write(fd, buffer, count)`  
    调用从 buffer 中读取多达 count 字节的数据写入由 fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可 能小于 count。
+ `status = close(fd)`  
    在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及 与之相关的内核资源。

### 设置文件读写位置
对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏 移量或指针。文件偏移量是指执行下一个 read()或 write()操作的文件起始位置，会以相对于文 件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。  

文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动 对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按 顺序递进，对文件进行操作。
```
off_t lseek(int fd, off_t offset, int whence)
```  
offset 参数指定了一个以字节为单位的数值，表示偏移量（多少字节），可以为负数或0；whence 参数则表明应参照哪个基点来解释 offset 参数。应为下列其中之一:
+ SEEK_SET: 将文件偏移量设置为从文件头部起始点开始的 offset 个字节。 
+ SEEK_CUR: 相对于当前文件偏移量，将文件偏移量调整 offset 个字节1。
+ SEEK_END: 将文件偏移量设置为起始于文件尾部的 offset 个字节
<center><img src="pics/lseek.png" width="60%"></center>
<!-- <center><img src="pics/file-flags.png" width="40%"></center> -->

#### 文件空洞
如果程序的文件偏移量已然跨越了文件结尾，然后再执行 I/O 操作，将会发生什么情况?   
read()调用将返回 0，表示文件结尾。有点令人惊讶的是，write()函数可以在文件结尾后的任意 位置写入数据。
从文件结尾后到新写入数据间的这段空间被称为**文件空洞**。从编程角度看，文件空洞中 是存在字节的，读取空洞将返回以 0(空字节)填充的缓冲区。
然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块 相比，稀疏填充的文件会占用较少的磁盘空间。

当文件包含空洞时，文件系统会将这些空洞的大小计算在文件大小中。因此，即使文件中有空洞，文件系统仍会记录文件大小为分配给文件的存储空间大小。

例如，假设你创建了一个大小为1GB的文件，并在其中创建一个空洞，文件系统可能仍然会将文件大小记录为1GB，即使实际上只有一小部分数据被写入了磁盘。
这种行为可能会导致文件大小看起来比实际存储的数据量要大。但是要注意的是，尽管文件大小增大了，但实际上并没有占用额外的磁盘空间，因为空洞部分并不存储在磁盘上。

### 通用 I/O 模型以外的操作:ioctl()
```
int  ioctl(int fd, unsigned long request, ...);
```

fd 参数为某个设备或文件已打开的文件描述符，request 参数指定了将在 fd 上执行的控制操 作。具体设备的头文件定义了可传递给 request 参数的常量。
ioctl()调用的第三个参数采用了标准 C 语言的省略符号(...)来表示(称之为 argp)，可以 是任意数据类型。ioctl()根据 request 的参数值来确定 argp 所期望的类型。通常情况下，argp 是指向整数或结构的指针，有些情况下，不需要使用 argp。


### 文件描述符和打开文件之间的关系 
文件描述符和打开的文件之间似乎呈现出一一对应的关系。然而，实际并非如此。多个文件描述符指向同一打开文件，这既有可能，也属必要。这些文件描述符可在相同或不同的进程中打开。 
要理解具体情况如何，需要查看由内核维护的 3 个数据结构: 
+ 进程级的文件描述符表。 
+ 系统级的打开文件表。 
+ 文件系统的 i-node 表。
 
针对**每个进程**，内核为其维护**打开文件的描述符**（open file descriptor）表。该表的每一条目都记录了单个文件描述符的相关信息，如下所示。 
+ 控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即close-on-exec 标志，将在 27.4 节予以介绍。） 
+ 对打开文件句柄的引用。 

内核对所有打开的文件维护有一个**系统级的描述表格**（open file description table）。有时，也称之为**打开文件表**（open file table），并将表中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示。 
+ 当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。 
+ 打开文件时所使用的状态标志（即，open()的 flags 参数）。 
+ 文件访问模式（如调用 open()时所设置的只读模式、只写模式或读写模式）。 
+ 与信号驱动 I/O 相关的设置。 
+ 对该文件 i-node 对象的引用。 

每个文件系统都会为驻留其上的所有文件建立一个 i-node 表。第 14 章将详细讨论 i-node 结构和文件系统的总体结构。这里只是列出每个文件的 i-node 信息，具体如下：
+ 文件类型（例如，常规文件、套接字或 FIFO）和访问权限。 
+ 一个指针，指向该文件所持有的锁的列表。 
+ 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。 

<center><img src="pics/file-table.png" width="60%"></center>
