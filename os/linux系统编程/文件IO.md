# 文件IO
{docsify-updated}

## 通用 I/O 模型的系统调用API
```
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags, ...../* mode_t mode */);

#include <unistd.h>
ssize_t read(int fd, void *buffer, size_t count);
ssize_t write(int fd, void *buffer, size_t count);
int close(int fd);
```

+ `fd = open(pathname, flags, mode)`  
    函数打开 pathname 所标识的文件，并返回文件描 述符，用以在后续函数调用中指代打开的文件。如果文件不存在，open()函数可以 创建之，这取决于对位掩码参数 flags 的设置。flags 参数还可指定文件的打开方式:只 读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限， 如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。
+ `numread = read(fd, buffer, count)`  
    调用从 fd 所指代的打开文件中读取至多 count 字节的 数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节 可读(例如:读到文件结尾符 EOF 时)，则返回值为 0。
+ `numwritten = write(fd, buffer, count)`  
    调用从 buffer 中读取多达 count 字节的数据写入由 fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可 能小于 count。
+ `status = close(fd)`  
    在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及 与之相关的内核资源。

### 标准输入输出
<center><img src="pics/stdio.png" width="60%"></center>

### flags参数
<center><img src="pics/filemode.png" width="60%"></center>

表 4-3 中常量分为如下几组：
+ 文件访问模式标志：先前描述的 O_RDONLY、O_WRONLY 和O_RDWR 标志均在此列，调用 open()时，上述三者在flags 参数中不能同时使用，只能指定其中一种。调用fcntl()的 F_GETFL 操作能够检索文件的访问模式（见 5.3 节）。 
+ 文件创建标志：这些标志在表4-3 中位于第二部分，其控制范围不拘于open()调用行为的方方面面，还涉及后续I/O 操作的各个选项。这些标志不能检索，也无法修改。 
+ 已打开文件的状态标志：这些标志是表 4-3 中的剩余部分，使用fcntl()的F_GETFL 和 F_SETFL 操作可以分别检索和修改此类标志。有时干脆将其称之为文件状态标志。

## 设置文件读写位置
对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏 移量或指针。文件偏移量是指执行下一个 read()或 write()操作的文件起始位置，会以相对于文 件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。  

文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动 对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按 顺序递进，对文件进行操作。
```
off_t lseek(int fd, off_t offset, int whence)
```  
offset 参数指定了一个以字节为单位的数值，表示偏移量（多少字节），可以为负数或0；whence 参数则表明应参照哪个基点来解释 offset 参数。应为下列其中之一:
+ SEEK_SET: 将文件偏移量设置为从文件头部起始点开始的 offset 个字节。 
+ SEEK_CUR: 相对于当前文件偏移量，将文件偏移量调整 offset 个字节1。
+ SEEK_END: 将文件偏移量设置为起始于文件尾部的 offset 个字节
<center><img src="pics/lseek.png" width="60%"></center>

## 在文件特定偏移量处的 I/O:pread()和 pwrite()
系统调用 pread()和 pwrite()完成与 read()和 write()相类似的工作，只是前两者会在 offset 参数 所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。
```
ssize_t	pread(int fd, void *buff, size_t count, off_t offset)
ssize_t	pwrite(int fd, const void *buff, size_t count, off_t offset)
```

`pread()`调用等同于将如下调用纳入同一原子操作:
```
off_t orig;
orig=lseek(fd,0,SEEK_CUR);
lseek(fd,offset,SEEK_SET);
s=read(fd,buf,len);
lseek(fd,orig,SEEK_SET);
```

多线程应用为这些系统调用提供了用武之地，进程下辖的所有线程将共享同一文件描述符表。这也意味着每个已打开文件的文件偏移量为所有线程所共享。当调用 `pread()` 或 `pwrite()` 时，多个线程可同时对同一文件描述符执行 I/O 操作，且不会因其他线程修 改文件偏移量而受到影响。如果还试图使用 lseek()和 read()(或 write())来代替 pread()(或 pwrite())，那么将引发竞争状态，这类似于 5.1 节讨论 O_APPEND 标志时的描述(当多个进 程的文件描述符指向相同的打开文件句柄时，使用 pread()和 pwrite()系统调用同样能够避免进 程间出现竞争状态)。

如果需要反复执行 lseek()，并伴之以文件 I/O，那么 pread()和 pwrite()系统调用在某些 情况下是具有性能优势的。这是因为执行单个 pread()(或 pwrite())系统调用的成本要低于 执行 lseek()和 read()(或 write())两个系统调用。然而，较之于执行 I/O 实际所需的时间，系统调用的开销就有些相形见绌了。

### 文件空洞
如果程序的文件偏移量已然跨越了文件结尾，然后再执行 I/O 操作，将会发生什么情况?   
read()调用将返回 0，表示文件结尾。有点令人惊讶的是，write()函数可以在文件结尾后的任意 位置写入数据。
从文件结尾后到新写入数据间的这段空间被称为**文件空洞**。从编程角度看，文件空洞中 是存在字节的，读取空洞将返回以 0(空字节)填充的缓冲区。
然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块 相比，稀疏填充的文件会占用较少的磁盘空间。

当文件包含空洞时，文件系统会将这些空洞的大小计算在文件大小中。因此，即使文件中有空洞，文件系统仍会记录文件大小为分配给文件的存储空间大小。

例如，假设你创建了一个大小为1GB的文件，并在其中创建一个空洞，文件系统可能仍然会将文件大小记录为1GB，即使实际上只有一小部分数据被写入了磁盘。
这种行为可能会导致文件大小看起来比实际存储的数据量要大。但是要注意的是，尽管文件大小增大了，但实际上并没有占用额外的磁盘空间，因为空洞部分并不存储在磁盘上。

## 通用 I/O 模型以外的操作:ioctl()
```
int  ioctl(int fd, unsigned long request, ...);
```

fd 参数为某个设备或文件已打开的文件描述符，request 参数指定了将在 fd 上执行的控制操 作。具体设备的头文件定义了可传递给 request 参数的常量。
ioctl()调用的第三个参数采用了标准 C 语言的省略符号(...)来表示(称之为 argp)，可以 是任意数据类型。ioctl()根据 request 的参数值来确定 argp 所期望的类型。通常情况下，argp 是指向整数或结构的指针，有些情况下，不需要使用 argp。


## 文件描述符和打开文件之间的关系 
文件描述符和打开的文件之间似乎呈现出一一对应的关系。然而，实际并非如此。多个文件描述符指向同一打开文件，这既有可能，也属必要。这些文件描述符可在相同或不同的进程中打开。 
要理解具体情况如何，需要查看由内核维护的 3 个数据结构: 
+ 进程级的文件描述符表。 
+ 系统级的打开文件表。 
+ 文件系统的 i-node 表。
 
针对**每个进程**，内核为其维护**打开文件的描述符**（open file descriptor）表。该表的每一条目都记录了单个文件描述符的相关信息，如下所示。 
+ 控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即close-on-exec 标志，将在 27.4 节予以介绍。） 
+ 对打开文件句柄的引用。 

内核对所有打开的文件维护有一个**系统级的描述表格**（open file description table）。有时，也称之为**打开文件表**（open file table），并将表中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示。 
+ 当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。 
+ 打开文件时所使用的状态标志（即，open()的 flags 参数）。 
+ 文件访问模式（如调用 open()时所设置的只读模式、只写模式或读写模式）。 
+ 与信号驱动 I/O 相关的设置。 
+ 对该文件 i-node 对象的引用。 

每个文件系统都会为驻留其上的所有文件建立一个 **i-node 表**。第 14 章将详细讨论 i-node 结构和文件系统的总体结构。这里只是列出每个文件的 i-node 信息，具体如下：
+ 文件类型（例如，常规文件、套接字或 FIFO）和访问权限。 
+ 一个指针，指向该文件所持有的锁的列表。 
+ 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。 

<center>
<img src="pics/file-table.png" width="60%" id="file">
</center>

由上图可知：
+ 两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量(由调用 read()、write()或 lseek() 所致)，那么从另一文件描述符中也会观察到这一变化。无论这两个文件描述符分属 于不同进程，还是同属于一个进程，情况都是如此。
+ 要获取和修改打开的文件标志(例如，O_APPEND、O_NONBLOCK 和 O_ASYNC)，可 执行 fcntl()的 F_GETFL 和 F_SETFL 操作，其对作用域的约束与上一条颇为类似。
+ 相形之下，文件描述符标志(亦即，close-on-exec 标志)为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符。

## 大文件 I/O
通常将存放文件偏移量的数据类型 off_t 实现为一个有符号的长整型。(之所以采用有符 号数据类型，是要以−1 来表示错误情况。)在 32 位体系架构中(比如 x86-32)，这将文件大小 置于 $2^{31}-1$ 个字节(即 2GB)的限制之下。  
然而，磁盘驱动器的容量早已超出这一限制，因此 32 位 UNIX 实现有处理超过 2GB 大小 文件的需求，这也在情理之中。由于问题较为普遍，UNIX 厂商联盟在大型文件峰会(Large File Summit)上就此进行了协商，并针对必需的大文件访问功能，形成了对 SUSv2 规范的扩展。 本节将概述 LFS 的增强特性。  
应用程序可使用如下两种方式之一以获得 LFS 功能:
+ 使用支持大文件操作的备选 API。该 API 由 LFS 设计，意在作为 SUS 规范的“过渡型扩展”。因此，尽管大部分系统都支持这一 API，但这对于符合 SUSv2 或 SUSv3 规范的系统其实并非必须。这一方法现已过时。
+ 在编译应用程序时，将宏 `_FILE_OFFSET_BITS` 的值定义为 64。这一方法更为可取，因为符合 SUS 规范的应用程序无需修改任何源码即可获得 LFS 功能。

## /dev/fd目录
对于每个进程，内核都提供有一个特殊的虚拟目录 `/dev/fd` 。该目录中包含`/dev/fd/n`形 式的文件名，其中 n 是与进程中的打开文件描述符相对应的编号。因此，例如，/dev/fd/0 就对 应于进程的标准输入。

方便起见，系统还提供了 3 个符号链接: `/dev/stdin`、`/dev/stdout` 和`/dev/stderr`，分别链接到`/dev/fd/0`、`/dev/fd/1` 和`/dev/fd/2`。

也就是说在程序中使用上述这些虚拟目录时，程序访问的就是标准输入/输出和错误文件。
