# 进程创建
{docsify-updated}

## 进程体系
+ **空闲进程(idle process)**:当没有其他进程在运行时，内核所运行的进程一它的pid是**0**。
+ **init进程**:在启动后，内核运行的第一个进程称为**init进程**，它的pid是**1**。一般来说，Linux中init进程就是init程序。我们将会使用“init”术语表示内核运行的第一个进程和完成相应目的特定程序。
+ 其它进程：在内核交出控制后，init会接着完成后续的启动过程。典型的情况是init会初始化系统，启动各种服务和启动登陆进程。

创建新进程的那个进程称为**父进程**，而新进程被称为**子进程**。每个进程都是由其他进程创建的（除了init进程），因此每个子进程都有一个父进程。这种关系保存在每个进程的**父进程ID号（ppid）**中。

每个进程都被一个用户和组所拥有。这种从属关系是用来实现访问控制的。对于内核来说，用户和组仅仅是一些整数值。通过 `/etc/passwd` 和 `/etc/group` 两个文件，这些整数被映射成为人们易读的形式。Unix用户应该对这些比较熟悉了，比如root用户、wheel组（通常来说，内核不关心这些易读的字符串，它更喜欢用整数来标示它们）。每个子进程都继承了父进程的用户和组。

每个进程都是某个进程组的一部分，它简单的表明了自己和其他进程之间的关系，但是不要和上面的用户、组的概念混淆了。子进程通常属于其父进程所在的那个进程组。此外当shell建立了一个管道（例如：用户输入了这样的命令ls|less），所有与管道有关的命令都是同一个进程组的。进程组使得与管道相关的进程间发送和获取信息变得很容易，这同样也适用于管道中的子进程。从用户角度看，进程组更像一个任务。

## 创建进程
在Unix中，载入内存并执行程序映像的操作与创建一个新进程的操作是分离的。Unix有一个系统调用（实际上是一系列系统调用之一）是可以将二进制文件的程序映像载入内存，替换原先进程的地址空间，并开始运行它。这个过程称为运行一个新的程序，而相应的系统调用称为 `exec` 系统调用。

同时，另一个不同的系统调用是创建一个新的进程，它基本上就是复制父进程。通常情况下新的进程会立刻执行一个新的程序。完成创建新进程的这种行为叫做 `fork` ，完成这个功能的系统调用就是 `fork()` 。这两种操作:
1. 首先fork，即创建新的进程；
2. 然后运行，即将一个镜像载入
都要求在新的进程中运行新的程序。

### exec
```
int execl (const char *path, const char *arg,
...);
```
对 `execl()` 的调用会将path所指路径的映像载入内存，替换当前进程的映像。通常情况下 `execl()` 不会返回。成功的调用会以跳到新的程序的入口点作为结束，而刚才被运行的代码(启动新进程的代码)是不会存在于进程的地址空间中的。但错误发生时， `execl()` 返回-1，并且设置的值，指示出了什么样的错误。

`execl()` 成功的调用不仅仅改变了地址空间和进程的映像，还改变了进程的一些属性：
+ 任何挂起的信号都会丢失。
+ 捕捉的任何信号会还原为缺省的处理方式，因为信号处理函数已经不存在于地址空间中了。
+ 任何内存的锁定（参看第八章）会丢失。
+ 多数线程的属性会还原到缺省值。
+ 多数关于进程的统计信息会复位。
+ 与进程内存相关的任何数据都会丢失，包括映射的文件。
+ 包括C语言库的一些特性(例如 `atexit()`)等独立存在于用户空间的数据都会丢失。

然而也有很多进程的属性没有改变，例如pid、父进程的pid、优先级、所属的用户和组。

通常打开的文件描述符也通过 `exec` 继承下来。如果新进程知道原进程打开的文件描述符的话，这意味着新的进程可以访问原先进程所打开。然而，这通常不是理想的处理方法。所以实际操作中一般会在 `exec` 调用前关闭打开的文件，当然，这也可以通过 `fcntl()` 来让内核去自动完成。

### fork
```
pid_t fork (void);
```

成功调用 `fork()` 会创建一个新的进程，它几乎与调用 `fork()` 的进程一模一样。这两个进程都会继续运行，调用者从 `fork()` 返回后，就好像没有什么特别的事情发生过。但是两个进程收到的 `fork()` 调用的返回值不同，在子进程中，成功的 `fork()` 调用会返回0。在父进程中 `fork()` 返回子进程的 `pid` 。可以基于返回值判断当前进程是父进程还是子进程。

新的进程成为原来进程的子进程，原来进程自然就是父进程。除了必要的一些方面，父进程和子进程之间在每个方面都非常相近：
+ 显然子进程的pid是新分配的，它是与父进程不同的。
+ 子进程的ppid会设置为父进程的pid。
+ 子进程中的资源统计信息（Resource statistics）会清零。
+ 任何挂起的信号会清除，也不会被子进程继承。
+ 任何文件锁都不会被子进程所继承。
  
调用出错时，不会创建子进程， `fork()` 返回 `-1` 。常见的用法如下：
```
pid_t pid;
pid = fork ();
if (pid > 0)
    printf (”I am the parent of pid=%d!\n”, pid);
else if (!pid){
    printf (”I am the baby!\n”);
    const char *args[] = { ”windlass”, NULL };
    int ret;
    ret = execv (”/bin/windlass”, args);
    if (ret == -1) {
        perror (”execv”);
        exit (EXIT_FAILURE);
    }
}
else if (pid == -1)
    perror (”fork”);
```
除了创建一个子进程外，父进程会没有任何改变的继续运行下去。 `execv()` 会使子进程去执行 `/bin/windlass` 。

## 写时复制(COW-Copy On Write)
