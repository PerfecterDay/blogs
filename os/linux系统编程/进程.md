# 进程
{docsify-updated}

### 进程与程序
程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容如下所示:
+ 二进制格式标识:每个程序文件都包含用于描述可执行文件格式的元信息 (metainformation)。内核(kernel)利用此信息来解释文件中的其他信息。历史上，UNIX 可执行文件曾有两种广泛使用的格式，分别为最初的 a.out(汇编程序输出)和更加复 杂的 COFF(通用对象文件格式)。现在，大多数 UNIX 实现(包括 Linux)采用可执行连接格式(ELF)，这一文件格式比老版本格式具有更多优点。 
+ 机器语言指令:对程序算法进行编码。 
+ 程序入口地址:标识程序开始执行时的起始指令位置。 
+ 数据:程序文件包含的变量初始值和程序使用的字面常量(literal constant)值(比 如字符串)。 
+ 符号表及重定位表:描述程序中函数和变量的位置及名称。这些表格有多种用途，其 中包括调试和运行时的符号解析(动态链接)。 
+ 共享库和动态链接信息:程序文件所包含的一些字段，列出了程序运行时需要使用的 共享库，以及加载共享库的动态链接器的路径名。 
+ 其他信息:程序文件还包含许多其他信息，用以描述如何创建进程。

可以用一个程序来创建许多进程，或者反过来说，许多进程运行的可以是同一程序。

**进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源。** 从内核角度看，进程由用**户内存空间(user-space memory)**和**一系列内核数据结构（PCB-Process Control Block）**组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。 记录在内核数据结构中的信息包括许多与进程相关的**标识号**(IDs)、**虚拟内存表**、**打开文件的描述符表**、**信号传递及处理的有关信息**、**进程资源使用及限制**、**当前工作目录**和大量的**其他信息**。这些信息大部分保存在进程控制块PCB(Process Control Block)中。

### 进程号和父进程号
每个进程都有一个唯一进程标识号(process ID)，并保存有对其父进程号的记录。  
系统调用 getpid()返回调用进程的进程号。
```
#include <unistd.h>
int getPid();
int getppid()
```

### 进程内存布局
<center><img src="pics/process.jpg" width="30%"></center>

每个进程所分配的内存由很多部分组成，通常称之为段(segment)。如下所示:
+ **文本段包含了进程运行的程序机器语言指令**。文本段具有**只读**属性，以防止进程通过错 误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为**可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中**。
+ **初始化数据段包含显式初始化的全局变量和静态变量**。当程序加载到内存时，从可执行文件中读取这些变量的值。
+ **未初始化数据段包含了未进行显式初始化的全局变量和静态变量**。程序启动之前，系统将本段内所有内存初始化为 0。出于历史原因，此段常被称为 **BSS 段**，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未经初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，**没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间。**
+ **栈(stack)是一个动态增长和收缩的段，由栈帧(stack frames)组成**。系统会为每个 当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量(所谓自动变量)、实参和返回值。
+ **堆(heap)是可在运行时(为变量)动态进行内存分配的一块区域**。堆顶端称作programbreak。

对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化数据段(user-initialized data segment)和零初始化数据段(zero-initialized data segment)。
`size`命令可显示二进制可执行文件的文本段、初始化数据段、非初始化数据段(bss)的段大小。

#### 命令行参数(argc, argv)
要想从程序内任一位置访问这些信息的部分或者全部内容，还有两个方法，但是会破坏程序的可移植性。
+ 通过 linux 系统专有的 `/proc/{PID}/cmdline` 文件可以读取任一进程的命令行参数，每个参数都以空(null)字节终止。(程序可以通过/proc/self/cmdline 文件访问自己的命令行参数）。
+ GNU C 语言库提供有两个全局变量，可在程序内任一位置使用以获取调用该程序时的 程序名称(即命令行的第一个参数)。第一个全局变量 `program_invocation_name` ，提 供了用于调用该程序的完整路径名。第二个全局变量 `program_invocation_short_name` ， 提供了不含目录的程序名称，即路径名的基本名称(basename)部分，定义`_GNU_SOURCE`宏后即可从<errno.h>中获得对这两个全局变量的声明。

argv 和 environ 数组，以及这些参数最初指向的字符串，都驻留在进程栈之上的一个单一、连续的内存区域。(下一节将描述 environ 参数，该参数用于存储程序的环 境列表。)此区域可存储的字节数有上限要求，SUSv3 规定使用 ARG_MAX 常量(定义于 <limits.h>)或者调用syscon(f _SC_ARG_MAX)函数以确定该上限值(将在11.2节描述sysconf() 函数)，并且 SUSv3 还要求 ARG_MAX 常量的下限为_POSIX_ARG_MAX(4096)个字节，而 大多数 UNIX 实现的限制都远高于此。但 SUSv3 并未规定对 ARG_MAX 限制的实现中是否要将 一些开销字节计算在内(比如终止空字符、字节对齐、argv 和 environ 指针数组)。


#### 环境变量
每一个进程都有与其相关的称之为环境列表(environment list)的字符串数组，或简称为环境(environment)。其中每个字符串都以名称=值(name=value)形式定义。因此，环境是“名称-值”的成对集合，可存储任何信息。常将列表中的名称称为**环境变量**(environment variables)。

新进程在创建之时，会继承其父进程的环境副本。这是一种原始的进程间通信方式，却颇为常用。环境(environment)提供了将信息从父进程传递给子进程的方法。由于子进程只有在创建时才能获得其父进程的环境副本，所以这一信息传递是单向的、一次性的。子进程 创建后，父、子进程均可更改各自的环境变量，且这些变更对对方而言不再可见。

##### 获取环境变量
通过 Linux 专有的 `/proc/{PID}/environ` 文件检查任一进程的环境列表，每一个“NAME=value” 对都以空字节终止。  
在 C 语言程序中:
+ 可以使用全局变量 `char **environ` 访问环境列表。(C 运行时启动代码 定义了该变量并以环境列表位置为其赋值。)environ 与 argv 参数类似，指向一个以 NULL 结尾 的指针列表，每个指针又指向一个以空字节终止的字符串。
+ 另外，还可以通过声明 main()函数中的第三个参数来访问环境列表: `int main(int argc, char const *argv[], char *envp[])`该参数随即可被视为 environ 变量来使用，所不同的是，该参数的作用域在 main()函数内。
+ `char	*getenv(const char *)` 函数能够从进程环境中检索单个值。

##### 操作环境变量
+ `int putenv(char *string)`   
  参数 string 是一指针，指向 name=value 形式的字符串。调用 putenv()函数后，该字符串就成为环境的一部分，换言之，putenv 函数将设定 environ 变量中某一元素的指向与 string 参数的指向位置相同，而非 string 参数所指向字符串的复制副本。因此，如果随后修改 string 参 数所指的内容，这将影响该进程的环境。出于这一原因，string 参数不应为自动变量(即在栈 中分配的字符数组1)，因为定义此变量的函数一旦返回，就有可能会重写这块内存区域。
  putenv()函数调用失败将返回非 0 值，而非−1。

+ `int	 setenv(const char *name, const char *value, int overwrite)`  
  setenv()函数为形如 name=value 的字符串分配一块内存缓冲区，并将 name 和 value 所指 向的字符串复制到此缓冲区，以此来创建一个新的环境变量。注意，不需要(实际上，是绝对不要)在 name 的结尾处或者 value 的开始处提供一个等号字符，因为 setenv()函数会在向环境添加新变量时添加等号字符。
  若以 name 标识的变量在环境中已经存在，且参数 overwrite 的值为 0，则 setenv()函数将不改变环境，如果参数 overwrite 的值为非 0，则 setenv()函数总是改变环境。
  setenv()函数复制其参数(到环境中)— 意味着与 putenv()函数不同，之后 对 name 和 value 所指字符串内容的修改将不会影响环境。此外，使用自动变量作为 setenv() 函数的参数也不会有任何问题。

+ `int unsetenv(const char *name)`  
  unsetenv()函数从环境中移除由 name 参数标识的变量。

+ `int clearenv()`  
  清空环境变量，也可以通过将 environ 变量赋值为 NULL 来清除环境：`environ = NULL`。
  在某些情况下，使用 setenv()函数和 clearenv()函数可能会导致程序内存泄露。前面已然提 及:setenv()函数所分配的一块内存缓冲区，随之会成为进程环境的一部分。而调用 clearenv() 时则没有释放该缓冲区(clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放)。反 复调用这两个函数的程序，会不断产生内存泄露。实际上，这不大可能成为一个问题，因为 程序通常仅在启动时调用 clearenv()函数一次，用于移除继承自其父进程(即调用 exec()函数 来启动当前程序的程序)环境中的所有条目。