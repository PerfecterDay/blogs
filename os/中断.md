## 中断
{docsify-updated}

> https://stackoverflow.com/questions/47294418/what-is-the-kernel-timer-system-and-how-is-it-related-to-the-scheduler
- [中断](#中断)
  - [外部硬件中断（外部中断）](#外部硬件中断外部中断)
    - [非屏蔽中断](#非屏蔽中断)
    - [可屏蔽中断](#可屏蔽中断)
      - [8259 芯片](#8259-芯片)
  - [实模式下的中断向量表与中断处理过程](#实模式下的中断向量表与中断处理过程)
  - [内部软中断](#内部软中断)
  - [BIOS 中断](#bios-中断)

中断就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。

### 外部硬件中断（外部中断）
就是从处理器外面来的中断信号，它可以分为可屏蔽中断和非屏蔽中断。中断信号的来源，或者说，产生中断的设备，称为中断源。
<center><img src="pics/interrupt.jpg" width="30%"></center>

当一个中断发生时，处理器将会通过中断引脚NMI 和INTR 得到通知。除此之外，它还应当知道发生了什么事，以便采取适当的处理措施。每种类型的中断都被统一编号，这称为**中断类型号、中断向量或者中断号**，每个中断号就代表一个中断事件。

#### 非屏蔽中断
所有的严重事件都必须无条件地加以处理，这种类型的中断是不会被阻断和屏蔽的，称为**非屏蔽中断（Non Maskable Interrupt，NMI）**。

由于不可屏蔽中断的特殊性——几乎所有触发NMI 的事件对处理器来说都是致命的，甚至是不可纠正的。比如内存访问电路发现了一个校验错误、电源断电等。在这种情况下，努力去搞清楚发生了什么，通常没有太大的意义，这样的事最好留到事后，让专业维修人员来做。

因此，在实模式下，NMI 被赋予了统一的中断号2，不再进行细分。一旦发生2号中断，处理器和软件系统通常会放弃继续正常工作的“念头”，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。

#### 可屏蔽中断
这类中断有两个特点，第一是数量很多，毕竟有很多外部设备；第二是它们可以被屏蔽，这样处理器就像是没听见、没看见一样，不会对它们进行处理。所以，这类硬件中断称为**可屏蔽中断**。

可屏蔽中断是通过INTR 引脚进入处理器内部的，像NMI 一样，不可能为每一个中断源都提供一个引脚。而且，处理器每次只能处理一个中断。在这种情况下，需要一个**代理**，来接受外部设备发出的中断信号。还有，多个设备同时发出中断请求的几率也是很高的，所以该代理的任务还包括对它们进行**仲裁**，以决定让它们中的哪一个优先向处理器提出服务请求。

在个人计算机中，用得最多的中断代理就是8259 芯片，它就是通常所说的中断控制器，从8086 处理器开始，它就一直提供着这种服务。现代 PC 已开始逐步淘汰 8259，转而采用英特尔 APIC 架构。然而，虽然不再是单独的芯片，但 8259 接口仍然由现代 x86 主板上的平台控制器集线器或南桥芯片组提供。

##### 8259 芯片
Intel 处理器允许256 个中断，中断号的范围是0～255，8259 负责提供其中的15 个，但中断号并不固定。之所以不固定，是因为当初设计的时候，允许软件根据自己的需要灵活设置中断号，以防止发生冲突。该中断控制器芯片有自己的端口号，可以像访问其他外部设备一样用in 和out 指令来改变它的状态，包括各引脚的中断号。正是因为这样，它又叫**可编程中断控制器（Programmable Interrupt Controller，PIC）。**
<center><img src="pics/8259.jpg" width="30%"></center>
<center><img src="pics/interupt.gif" width="30%"></center>

每片8259 只有8 个中断输入引脚，而在个人计算机上使用它，需要两块。第一块8259 芯片的代理输出INT 直接送到处理器的INTR 引脚，这是主片（Master）；第二块8259 芯片的INT 输出送到第一块的引脚2 上，是从片（Slave），两块芯片之间形成级联（Cascade）关系。如此一来，两块8259 芯片可以向处理器提供15 个中断信号。当时，接在8259 上的15 个设备都是相当重要的，如PS/2 键盘和鼠标、串行口、并行口、软磁盘驱动器、IDE 硬盘等。现在，这些设备很多都已淘汰或者正在淘汰中，根据需要，这些中断引脚可以被其他设备使用。8259 的主片引脚0（IR0）接的是系统定时器/计数器芯片；从片的引脚0 （IR0）接的是实时时钟芯片RTC。这两块芯片的固定连接即使是在硬件更新换代非常频繁的今天，也依然没有改变。

在8259 芯片内部，有**中断屏蔽寄存器（Interrupt Mask Register，IMR）**，这是个8 位寄存器，对应着该芯片的8 个中断输入引脚，**对应的位是0 还是1，决定了从该引脚来的中断信号是否能够通过8259 送往处理器（0 表示允许，1 表示阻断，这可能出乎你的意料）**。当外部设备通过某个引脚送来一个中断请求信号时，如果它没有被 IMR 阻断，那么，它可以被送往处理器。注意，8259 芯片是可编程的，**主片的端口号是0x20 和0x21，从片的端口号是0xa0 和0xa1，可以通过这些端口访问8259 芯片，设置它的工作方式，包括IMR 的内容。**

能否被处理，除了要看8259 芯片的脸色外，最终的决定权在处理器手中。在处理器内部，**标志寄存器有一个标志位IF，这就是中断标志（Interrupt Flag）。当IF 为0时，所有从处理器INTR 引脚来的中断信号都被忽略掉；当其为1 时，处理器可以接受和响应中断。**

IF 标志位可以通过两条指令 `cli` 和 `sti` 来改变。这两条指令都没有操作数，`cli`（CLear Interrupt flag）用于清除 IF 标志位来**关中断**，`sti`（SeT Interruptflag）用于置位 IF 标志来**开中断**。

在计算机启动期间，BIOS 会初始化中断控制器，**将主片的中断号设为从0x08 开始，将从片的中断号设为从0x70开始**。所以，计算机启动后，RTC 芯片的中断号默认是0x70。尽管我们可以通过对 8259 编程来改变它，但是没有必要。

### 实模式下的中断向量表与中断处理过程
所谓中断处理，归根结底就是处理器要执行一段与该中断有关的程序（指令）。处理器可以识别256 个中断，那么理论上就需要256 段程序。这些程序的位置并不重要，重要的是，在实模式下，处理器要求将它们的入口点集中存放到内存中从物理地址0x00000 开始，到0x003ff 结束，共 1KB 的空间内，这就是所谓的**中断向量表（Interrupt VectorTable，IVT）**。

每个中断在中断向量表中占2个字（4字节），分别是中断处理程序的**偏移地址和段地址**。中断 0 的入口点位于物理地址0x00000 处，也就是逻辑地址0x0000:0x0000；中断1 的入口点位于物理地址0x00004处，即逻辑地址0x0000:0x0004；其他中断以此类推，总之是按顺序的。

不可屏蔽中断或者可屏蔽中断发生时中断标志位 IF 允许中断，处理器在执行完当前的指令后，会进入**中断周期**，中断周期内，CPU会完成一系列操作：
1. 保护断点的现场  
   首先要将标志寄存器FLAGS 压栈，然后清除它的 IF 位和 TF 位。TF 是陷阱标志，这个以后再讲。接着，再将当前的代码段寄存器CS 和指令指针寄存器IP 压栈。
   注意，由于 IF 标志被清除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用sti 指令开放中断。
2. 寻找中断服服务程序的入口，由中断号和中断向量表来获得

上述操作都是在中断周期内由一条中断隐指令完成的，隐指令是指在指令系统中没有的指令，它是CPU在中断周期内由硬件自动完成的指令。因为在中断周期内，CPU会自动关中断，所以在接下来的中断服务程序中如果想实现嵌套中断响应，必须在中断服务程序中用开中断指令打开中断。

由上可知，CPU中断周期是由硬件自动完成的，用户对中断系统做的就是编排好中断号、填写好中断向量表和安装好中断服务程序。

中断周期结束后，CPU开始执行中断服务程序：

3. 执行中断处理程序  
   由于处理器已经拿到了中断号，它将该号码乘以4（毕竟每个中断在中断向量表中占4 字节），就得到了该中断入口点在中断向量表中的偏移地址。接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到IP 和CS，自然地，处理器就开始执行中断处理程序了。
4. 返回到断点接着执行  
   所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS 和FLAGS 的原始内容，于是转到中断前的程序接着执行。

和可屏蔽中断不同，NMI 发生时，处理器不会从外部获得中断号，它自动生成中断号码2，其他处理过程和可屏蔽中断相同。

中断随时可能发生，中断向量表的建立和初始化工作是由BIOS 在计算机启动时负责完成的。BIOS 为每个中断号填写入口地址，因为它不知道多数中断处理程序的位置，所以，一律将它们指向一个相同的入口地址，在那里，只有一条指令：iret。也就是说，当这些中断发生时，只做一件事，那就是立即返回。当计算机启动后，操作系统和用户程序再根据自己的需要，来修改某些中断的入口地址，使它指向自己的代码。

### 内部软中断
和硬件中断不同，内部软件中断发生在处理器内部，是由执行的指令引起的。比如，当处理器检测到div 或者idiv 指令的除数为零时，或者除法的结果溢出时，将产生中断0（0 号中断），这就是除法错中断。

**内部软件中断不受标志寄存器IF 位的影响，也不需要中断周期，它们的中断类型是固定的（指令给出），可以立即转入相应的处理过程。**

软中断是由int 指令引起的中断处理。这类中断也不需要中断周期，中断号在指令中给出。
```
int3
int imm8
into
```

int3 是断点中断指令，机器指令码为CC。指令都是连续存放的，断点，就是某条指令的起始地址。int3 是单字节指令，这是有意设计的。当需要设置断点时，可以将断点处那条指令的第1 字节改成0xcc，原字节予以保存。当处理器执行到int3 时，即发生3 号中断，转去执行相应的中断处理程序。中断处理程序的执行也要用到各个寄存器，这会破坏它们的内容，但push 指令不会。所以可以在程序内先压栈所有相关寄存器和内存单元，然后分别取出予以显示，它们就是中断前的现场内容。最后，再恢复那条指令的第1 字节，并修改位于栈中的返回地址，执行iret 指令。

int n，其操作码为0xCD，第2 字节的操作数给出了中断号。

into 是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF 位是1，那么，将产生4 号中断。否则，这条指令什么也不做。

### BIOS 中断
编写自己的中断处理程序有相当大的优越之处。不像jmp 和call 指令，int 指令不需要知道目标程序的入口地址。远转移指令jmp 和远调用指令call 必须直接或者间接给出目标位置的段地址和偏移地址，如果所有这一切都是自己安排的，倒也不成问题，但如果想调用别人的代码，比如操作系统的功能，这就很麻烦了。

举个例子来说，假如你想读硬盘上的一个文件，因为操作系统有这样的功能，所以就不必在自己的程序中再写一套代码，直接调用操作系统例程就可以了。但是，操作系统通常不会给出或者公布硬盘读写例程的段地址和偏移地址，因为操作系统也是经常修改的，经常发布新的版本。这样一来，例程的入口地址也会跟着变化。而且，也不能保证每次启动计算机之后，操作系统总待在同一个内存位置。

因为有了软中断，这是个利好条件。每次操作系统加载完自己之后，以中断处理程序的形式提供硬盘读写功能，并把该例程的地址填写到中断向量表中。这样，无论在什么时候，用户程序需要该功能时，直接发出一个软中断即可，不需要知道具体的地址。

BIOS 可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS 中断是由外部设备接口自己建立的。这些中断功能在加载和执行主引导扇区之前，就已经可以使用了。BIOS 中断，又称BIOS 功能调用，主要是为了方便地使用最基本的硬件访问功能。不同的硬件使用不同的中断号。为了区分针对同一硬件的不同功能，使用寄存器AH 来指定具体的功能编号。

首先，每个外部设备接口，包括各种板卡，如网卡、显卡、键盘接口电路、硬件控制器等，都有自己的只读存储器（Read Only Memory，ROM），类似于BIOS 芯片，这些ROM 中提供了它自己的功能调用例程，以及本设备的初始化代码。按照规范，前两个单元的内容是0x55 和0xAA，第三个单元是本ROM 中以512 字节为单位的代码长度；从第四个单元开始，就是实际的ROM 代码。

其次，我们知道，从内存物理地址A0000 开始，到FFFFF 结束，有相当一部分空间是留给外围设备的。如果设备存在，那么，它自带的ROM 会映射到分配给它的地址范围内。

在计算机启动期间，BIOS 程序会以2KB 为单位搜索内存地址C0000～E0000 之间的区域。当它发现某个区域的头两个字节是0x55 和0xAA时，那意味着该区域有ROM 代码存在，是有效的。接着，它对该区域做累加和检查，看结果是否和第三个单元相符。如果相符，就从第四个单元进入。这时，处理器执行的是硬件自带的程序指令，这些指令初始化外部设备的相关寄存器和工作状态，最后，填写相关的中断向量表，使它们指向自带的中断处理过程。

