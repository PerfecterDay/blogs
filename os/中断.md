#  异常控制流与中断
{docsify-updated}

- [异常控制流与中断](#异常控制流与中断)
	- [异常控制流（Exceptional Control Flow，ECF）](#异常控制流exceptional-control-flowecf)
	- [分类](#分类)
		- [中断](#中断)
		- [陷阱和系统调用](#陷阱和系统调用)
		- [故障](#故障)
		- [终止](#终止)
		- [Linux/x86-64 系统中的异常](#linuxx86-64-系统中的异常)
	- [操作系统如何控制CPU的](#操作系统如何控制cpu的)
	- [中断机制](#中断机制)
		- [外部硬件中断（外部中断）](#外部硬件中断外部中断)
			- [非屏蔽中断](#非屏蔽中断)
			- [可屏蔽中断](#可屏蔽中断)
				- [8259 芯片](#8259-芯片)
		- [实模式下的中断向量表与中断处理过程](#实模式下的中断向量表与中断处理过程)
		- [内部软中断](#内部软中断)
		- [BIOS 中断](#bios-中断)

## 异常控制流（Exceptional Control Flow，ECF）
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列:
$$ a_0,a_1,⋯,a_{n−1} $$
​
其中，每个 $a_k$ 是某个相应的指令 $I_k$ 的地址。每次从 $a_k$​ 到 $a_{k+1}$ 的过渡称为控制转移（control transfer）。**这样的控制转移序列叫做处理器的控制流**（flow of control 或 control flow）。

最简单的一种控制流是一个“平滑的”序列，其中每个 $I_k$ ​ 和 $I_{k+1}$ ​ 在内存中都是相邻的。与之对应的是这种平滑流的突变（也就是 $I_k$ ​ 和 $I_{k+1}$​ 不相邻）通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。所以控制流可以有两种表现形式：
+ 平滑的
+ 非平滑的

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为**异常控制流**（Exceptional Control Flow，ECF）。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。—个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。

## 分类
以下内容摘自Intel 的软件开发者手册（software developer mannual):
<center><img src="pics/cpu-interrupt.png" width="70%"></center>

根据手册内容，可以将 CPU 支持的中断机制分为以下几种：
| 类别      | 原因 | 异步/同步 | 返回行为 |
| :---  |  :----:   |   ---: | ---: |
| 中断(interrupt)| 来自I/0设备的信号 | 异步 | 总是返回到下一条指令 |
| 陷阱(trap) | 有意的异常 | 同步 | 总是返回到下一条指令 |
| 故障(fault) | 潜在可恢复的错误 | 同步 | 可能返回到当前指令 |
| 终止(abort) | 不可恢复的错误 | 同步 | 不会返回 |

### 中断
中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序（interrupt handler）。

下图概述了一个中断的处理。I/O 设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。
<center><img src="pics/interrupt.avif" width="50%"></center>

在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令（也即如果没有发生中断，在控制流中会在当前指令之后的那条指令）。结果是程序继续执行，就好像没有发生过中断一样。

剩下的异常类型（陷阱、故障和终止）是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令（faulting instruction）。

### 陷阱和系统调用
陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。

用户程序经常需要向内核请求服务，比如读一个文件（read）、创建一个新的进程（fork），加载一个新的程序（execve），或者终止当前进程（exit）。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 “syscall n” 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。下图概述了一个系统调用的处理。

<center><img src="pics/trap.avif" width="50%"></center>

从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。

### 故障
故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。下图概述了一个故障的处理：

<center><img src="pics/fault.avif" width="50%"></center>

一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟内存的一个连续的块（典型的是 4KB）。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。

### 终止
终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如下图所示，处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。

<center><img src="pics/abort.avif" width="50%"></center>

### Linux/x86-64 系统中的异常
为了使描述更具体，让我们来看看为 x86-64 系统定义的一些异常。有高达 256 种不同的异常类型。0∼31 的号码对应的是由 Intel 架构师定义的异常，因此对任何 x86-64 系统都是一样的。32∼255 的号码对应的是操作系统定义的中断和陷阱。

| 异常号      | 描述 | 异常类别 | 
| :---  |  :----:   |   ---: |
| 0 | 除法错误 | 故障 | 
| 13 | 一般保护故障 | 故障 | 
| 14 | 缺页 | 故障 | 
| 18 | 机器检查 | 终止 | 
| 32~255 | 操作系统定义的异常 | 中断或陷阱 | 

## 操作系统如何控制CPU的
> https://stackoverflow.com/questions/47294418/what-is-the-kernel-timer-system-and-how-is-it-related-to-the-scheduler

我们知道操作系统会将CPU分配给用户的进程使用以执行用户程序，那么客户程序在获取CPU的控制权后，操作系统是如何重新夺回控制权的呢 ？

这就必须依靠现代操作系统普遍使用的中断技术。操作系统是这么做的：
1. 在内核开始执行用户代码之前，会初始化定时器，设置定时器定期的产生中断。 定时器控制是特权指令（需要在内核模式执行）。
2. 定时器中断处理程序是操作系统事先写好的内核程序，中断机制保证这段中断程序会被调用，控制权重新回到内核手中。 

这样就确保了用户进程无法接管系统。 

以下以 linux-0.01 源代码来看看 linux 最初版本是如何安装这个中断的。首先，在 `init/main.c` 中的 `main` 方法：

```
void main(void)
{

	time_init();
	tty_init();
	trap_init();
	sched_init();
	buffer_init();
	hd_init();
	sti();
	move_to_user_mode();
	if (!fork()) {		/* we count on this going ok */
		init();
	}
}
```

跟踪到 `sched_init();` 函数：
```
void sched_init(void)
{
	int i;
	struct desc_struct * p;

	set_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));
	set_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));
	p = gdt+2+FIRST_TSS_ENTRY;
	for(i=1;i<NR_TASKS;i++) {
		task[i] = NULL;
		p->a=p->b=0;
		p++;
		p->a=p->b=0;
		p++;
	}
	ltr(0);
	lldt(0);
	outb_p(0x36,0x43);		/* binary, mode 3, LSB/MSB, ch 0 */
	outb_p(LATCH & 0xff , 0x40);	/* LSB */
	outb(LATCH >> 8 , 0x40);	/* MSB */
	set_intr_gate(0x20,&timer_interrupt);
	outb(inb_p(0x21)&~0x01,0x21);
	set_system_gate(0x80,&system_call);
}
```

有两行代码分别设置了定时器中断（0x20-32）和系统调用中断（0x80-128）:
```
	set_intr_gate(0x20,&timer_interrupt);
	set_system_gate(0x80,&system_call);
```

`timer_interrupt` 中断处理程序是一段汇编代码，位于 `kernel/system_call.s` 文件中，定义如下：
```
.align 2
_timer_interrupt:
	push %ds		# save ds,es and put kernel data space
	push %es		# into them. %fs is used by _system_call
	push %fs
	pushl %edx		# we save %eax,%ecx,%edx as gcc doesn't
	pushl %ecx		# save those across function calls. %ebx
	pushl %ebx		# is saved as we use that in ret_sys_call
	pushl %eax
	movl $0x10,%eax
	mov %ax,%ds
	mov %ax,%es
	movl $0x17,%eax
	mov %ax,%fs
	incl _jiffies
	movb $0x20,%al		# EOI to interrupt controller #1
	outb %al,$0x20
	movl CS(%esp),%eax
	andl $3,%eax		# %eax is CPL (0 or 3, 0=supervisor)
	pushl %eax
	call _do_timer		# 'do_timer(long CPL)' does everything from
	addl $4,%esp		# task switching to accounting ...
	jmp ret_from_sys_call
```

这段汇编代码最终会调用 `call _do_timer` , `_do_timer` 是 `kernel/sched.c` 文件中定义的 `do_timer` 函数：
```
void do_timer(long cpl)
{
	if (cpl)
		current->utime++;
	else
		current->stime++;
	if ((--current->counter)>0) return;
	current->counter=0;
	if (!cpl) return;
	schedule();
}
```

可以看到这个函数调用了调度函数 `schedule();`。至此，其它进程才会得到调度。

## 中断机制
中断就是打断处理器当前的执行流程，去执行另外一些和当前工作不相干的指令，执行完之后，还可以返回到原来的程序流程继续执行。
<center><img src="pics/interupt.gif" width="50%"></center>

### 外部硬件中断（外部中断）
就是从处理器外面来的中断信号，它可以分为可屏蔽中断和非屏蔽中断。中断信号的来源，或者说，产生中断的设备，称为中断源。
<center><img src="pics/interrupt.jpg" width="30%"></center>

当一个中断发生时，处理器将会通过中断引脚NMI 和INTR 得到通知。除此之外，它还应当知道发生了什么事，以便采取适当的处理措施。每种类型的中断都被统一编号，这称为**中断类型号、中断向量或者中断号**，每个中断号就代表一个中断事件。

#### 非屏蔽中断
所有的严重事件都必须无条件地加以处理，这种类型的中断是不会被阻断和屏蔽的，称为**非屏蔽中断（Non Maskable Interrupt，NMI）**。

由于不可屏蔽中断的特殊性——几乎所有触发NMI 的事件对处理器来说都是致命的，甚至是不可纠正的。比如内存访问电路发现了一个校验错误、电源断电等。在这种情况下，努力去搞清楚发生了什么，通常没有太大的意义，这样的事最好留到事后，让专业维修人员来做。

因此，在实模式下，NMI 被赋予了统一的中断号2，不再进行细分。一旦发生2号中断，处理器和软件系统通常会放弃继续正常工作的“念头”，也不会试图纠正已经发生的问题和错误，很可能只是由软件系统给出一个提示信息。

#### 可屏蔽中断
这类中断有两个特点，第一是数量很多，毕竟有很多外部设备；第二是它们可以被屏蔽，这样处理器就像是没听见、没看见一样，不会对它们进行处理。所以，这类硬件中断称为**可屏蔽中断**。

可屏蔽中断是通过INTR 引脚进入处理器内部的，像NMI 一样，不可能为每一个中断源都提供一个引脚。而且，处理器每次只能处理一个中断。在这种情况下，需要一个**代理**，来接受外部设备发出的中断信号。还有，多个设备同时发出中断请求的几率也是很高的，所以该代理的任务还包括对它们进行**仲裁**，以决定让它们中的哪一个优先向处理器提出服务请求。

在个人计算机中，用得最多的中断代理就是8259 芯片，它就是通常所说的中断控制器，从8086 处理器开始，它就一直提供着这种服务。现代 PC 已开始逐步淘汰 8259，转而采用英特尔 APIC 架构。然而，虽然不再是单独的芯片，但 8259 接口仍然由现代 x86 主板上的平台控制器集线器或南桥芯片组提供。

##### 8259 芯片
Intel 处理器允许256 个中断，中断号的范围是0～255，8259 负责提供其中的15 个，但中断号并不固定。之所以不固定，是因为当初设计的时候，允许软件根据自己的需要灵活设置中断号，以防止发生冲突。该中断控制器芯片有自己的端口号，可以像访问其他外部设备一样用in 和out 指令来改变它的状态，包括各引脚的中断号。正是因为这样，它又叫**可编程中断控制器（Programmable Interrupt Controller，PIC）。**
<center><img src="pics/8259.jpg" width="30%"></center>

每片8259 只有8 个中断输入引脚，而在个人计算机上使用它，需要两块。第一块8259 芯片的代理输出INT 直接送到处理器的INTR 引脚，这是主片（Master）；第二块8259 芯片的INT 输出送到第一块的引脚2 上，是从片（Slave），两块芯片之间形成级联（Cascade）关系。如此一来，两块8259 芯片可以向处理器提供15 个中断信号。当时，接在8259 上的15 个设备都是相当重要的，如PS/2 键盘和鼠标、串行口、并行口、软磁盘驱动器、IDE 硬盘等。现在，这些设备很多都已淘汰或者正在淘汰中，根据需要，这些中断引脚可以被其他设备使用。8259 的主片引脚0（IR0）接的是系统定时器/计数器芯片；从片的引脚0 （IR0）接的是实时时钟芯片RTC。这两块芯片的固定连接即使是在硬件更新换代非常频繁的今天，也依然没有改变。

在8259 芯片内部，有**中断屏蔽寄存器（Interrupt Mask Register，IMR）**，这是个8 位寄存器，对应着该芯片的8 个中断输入引脚，**对应的位是0 还是1，决定了从该引脚来的中断信号是否能够通过8259 送往处理器（0 表示允许，1 表示阻断，这可能出乎你的意料）**。当外部设备通过某个引脚送来一个中断请求信号时，如果它没有被 IMR 阻断，那么，它可以被送往处理器。注意，8259 芯片是可编程的，**主片的端口号是0x20 和0x21，从片的端口号是0xa0 和0xa1，可以通过这些端口访问8259 芯片，设置它的工作方式，包括IMR 的内容。**

能否被处理，除了要看8259 芯片的脸色外，最终的决定权在处理器手中。在处理器内部，**标志寄存器有一个标志位IF，这就是中断标志（Interrupt Flag）。当IF 为0时，所有从处理器INTR 引脚来的中断信号都被忽略掉；当其为1 时，处理器可以接受和响应中断。**

IF 标志位可以通过两条指令 `cli` 和 `sti` 来改变。这两条指令都没有操作数，`cli`（CLear Interrupt flag）用于清除 IF 标志位来**关中断**，`sti`（SeT Interruptflag）用于置位 IF 标志来**开中断**。

在计算机启动期间，BIOS 会初始化中断控制器，**将主片的中断号设为从0x08 开始，将从片的中断号设为从0x70开始**。所以，计算机启动后，RTC 芯片的中断号默认是0x70。尽管我们可以通过对 8259 编程来改变它，但是没有必要。

### 实模式下的中断向量表与中断处理过程
所谓中断处理，归根结底就是处理器要执行一段与该中断有关的程序（指令）。处理器可以识别256 个中断，那么理论上就需要256 段程序。这些程序的位置并不重要，重要的是，在实模式下，处理器要求将它们的入口点集中存放到内存中从物理地址0x00000 开始，到0x003ff 结束，共 1KB 的空间内，这就是所谓的**中断向量表（Interrupt VectorTable，IVT）**。

每个中断在中断向量表中占2个字（4字节），分别是中断处理程序的**偏移地址和段地址**。中断 0 的入口点位于物理地址0x00000 处，也就是逻辑地址0x0000:0x0000；中断1 的入口点位于物理地址0x00004处，即逻辑地址0x0000:0x0004；其他中断以此类推，总之是按顺序的。

不可屏蔽中断或者可屏蔽中断发生时中断标志位 IF 允许中断，处理器在执行完当前的指令后，会进入**中断周期**，中断周期内，CPU会完成一系列操作：
1. 保护断点的现场  
   首先要将标志寄存器FLAGS 压栈，然后清除它的 IF 位和 TF 位。TF 是陷阱标志，这个以后再讲。接着，再将当前的代码段寄存器CS 和指令指针寄存器IP 压栈。
   注意，由于 IF 标志被清除，在中断处理过程中，处理器将不再响应硬件中断。如果希望更高优先级的中断嵌套，可以在编写中断处理程序时，适时用sti 指令开放中断。
2. 寻找中断服服务程序的入口，由中断号和中断向量表来获得

上述操作都是在中断周期内由一条中断隐指令完成的，隐指令是指在指令系统中没有的指令，它是CPU在中断周期内由硬件自动完成的指令。因为在中断周期内，CPU会自动关中断，所以在接下来的中断服务程序中如果想实现嵌套中断响应，必须在中断服务程序中用开中断指令打开中断。

由上可知，CPU中断周期是由硬件自动完成的，用户对中断系统做的就是编排好中断号、填写好中断向量表和安装好中断服务程序。

中断周期结束后，CPU开始执行中断服务程序：

3. 执行中断处理程序  
   由于处理器已经拿到了中断号，它将该号码乘以4（毕竟每个中断在中断向量表中占4 字节），就得到了该中断入口点在中断向量表中的偏移地址。接着，从表中依次取出中断程序的偏移地址和段地址，并分别传送到IP 和CS，自然地，处理器就开始执行中断处理程序了。
4. 返回到断点接着执行  
   所有中断处理程序的最后一条指令必须是中断返回指令iret。这将导致处理器依次从栈中弹出（恢复）IP、CS 和FLAGS 的原始内容，于是转到中断前的程序接着执行。

和可屏蔽中断不同，NMI 发生时，处理器不会从外部获得中断号，它自动生成中断号码2，其他处理过程和可屏蔽中断相同。

中断随时可能发生，中断向量表的建立和初始化工作是由BIOS 在计算机启动时负责完成的。BIOS 为每个中断号填写入口地址，因为它不知道多数中断处理程序的位置，所以，一律将它们指向一个相同的入口地址，在那里，只有一条指令：iret。也就是说，当这些中断发生时，只做一件事，那就是立即返回。当计算机启动后，操作系统和用户程序再根据自己的需要，来修改某些中断的入口地址，使它指向自己的代码。

### 内部软中断
和硬件中断不同，内部软件中断发生在处理器内部，是由执行的指令引起的。比如，当处理器检测到 `div` 或者 `idiv` 指令的除数为零时，或者除法的结果溢出时，将产生中断0（0 号中断），这就是除法错中断。

**内部软件中断不受标志寄存器IF 位的影响，也不需要中断周期，它们的中断类型是固定的（指令给出），可以立即转入相应的处理过程。**

软中断是由int 指令引起的中断处理。这类中断也不需要中断周期，中断号在指令中给出。
```
int3
int imm8
into
```

int3 是断点中断指令，机器指令码为CC。指令都是连续存放的，断点，就是某条指令的起始地址。int3 是单字节指令，这是有意设计的。当需要设置断点时，可以将断点处那条指令的第1 字节改成0xcc，原字节予以保存。当处理器执行到int3 时，即发生3 号中断，转去执行相应的中断处理程序。中断处理程序的执行也要用到各个寄存器，这会破坏它们的内容，但push 指令不会。所以可以在程序内先压栈所有相关寄存器和内存单元，然后分别取出予以显示，它们就是中断前的现场内容。最后，再恢复那条指令的第1 字节，并修改位于栈中的返回地址，执行iret 指令。

int n，其操作码为0xCD，第2 字节的操作数给出了中断号。

into 是溢出中断指令，机器码为0xCE，也是单字节指令。当处理器执行这条指令时，如果标志寄存器的OF 位是1，那么，将产生4 号中断。否则，这条指令什么也不做。

### BIOS 中断
编写自己的中断处理程序有相当大的优越之处。不像jmp 和call 指令，int 指令不需要知道目标程序的入口地址。远转移指令jmp 和远调用指令call 必须直接或者间接给出目标位置的段地址和偏移地址，如果所有这一切都是自己安排的，倒也不成问题，但如果想调用别人的代码，比如操作系统的功能，这就很麻烦了。

举个例子来说，假如你想读硬盘上的一个文件，因为操作系统有这样的功能，所以就不必在自己的程序中再写一套代码，直接调用操作系统例程就可以了。但是，操作系统通常不会给出或者公布硬盘读写例程的段地址和偏移地址，因为操作系统也是经常修改的，经常发布新的版本。这样一来，例程的入口地址也会跟着变化。而且，也不能保证每次启动计算机之后，操作系统总待在同一个内存位置。

因为有了软中断，这是个利好条件。每次操作系统加载完自己之后，以中断处理程序的形式提供硬盘读写功能，并把该例程的地址填写到中断向量表中。这样，无论在什么时候，用户程序需要该功能时，直接发出一个软中断即可，不需要知道具体的地址。

BIOS 可能会为一些简单的外围设备提供初始化代码和功能调用代码，并填写中断向量表，但也有一些BIOS 中断是由外部设备接口自己建立的。这些中断功能在加载和执行主引导扇区之前，就已经可以使用了。BIOS 中断，又称BIOS 功能调用，主要是为了方便地使用最基本的硬件访问功能。不同的硬件使用不同的中断号。为了区分针对同一硬件的不同功能，使用寄存器AH 来指定具体的功能编号。

首先，每个外部设备接口，包括各种板卡，如网卡、显卡、键盘接口电路、硬件控制器等，都有自己的只读存储器（Read Only Memory，ROM），类似于BIOS 芯片，这些ROM 中提供了它自己的功能调用例程，以及本设备的初始化代码。按照规范，前两个单元的内容是0x55 和0xAA，第三个单元是本ROM 中以512 字节为单位的代码长度；从第四个单元开始，就是实际的ROM 代码。

其次，我们知道，从内存物理地址A0000 开始，到FFFFF 结束，有相当一部分空间是留给外围设备的。如果设备存在，那么，它自带的ROM 会映射到分配给它的地址范围内。

在计算机启动期间，BIOS 程序会以2KB 为单位搜索内存地址C0000～E0000 之间的区域。当它发现某个区域的头两个字节是0x55 和0xAA时，那意味着该区域有ROM 代码存在，是有效的。接着，它对该区域做累加和检查，看结果是否和第三个单元相符。如果相符，就从第四个单元进入。这时，处理器执行的是硬件自带的程序指令，这些指令初始化外部设备的相关寄存器和工作状态，最后，填写相关的中断向量表，使它们指向自带的中断处理过程。