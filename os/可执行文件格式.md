#  可执行文件格式
{docsify-updated}
> https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/  
> https://man7.org/linux/man-pages/man5/elf.5.html  
> https://bbs.kanxue.com/thread-274573.htm  

- [可执行文件格式](#可执行文件格式)
	- [ELF文件格式](#elf文件格式)
		- [ELF Header](#elf-header)
		- [Program header (Phdr)](#program-header-phdr)
		- [Section Header](#section-header)
			- [常见section](#常见section)
			- [符号表和字符串表](#符号表和字符串表)
	- [Windows PE（Portable-Executable）文件格式](#windows-peportable-executable文件格式)
	- [工具程序](#工具程序)
		- [objdump 和 readelf 的区别](#objdump-和-readelf-的区别)


## ELF文件格式 
目标文件同时参与了链接与运行，ELF文件同时支持两种功能。所以可以从两个视角来看待ELF文件：
<center>
<img src="pics/elf.png" width="40%">
<img src="pics/elf-view.png" width="30%">
</center>

### ELF Header
```
The following types are used for N-bit architectures (N=32,64,ElfN stands for Elf32 or Elf64, uintN_t stands for uint32_t or uint64_t):
ElfN_Addr       Unsigned program address, uintN_t
ElfN_Off        Unsigned file offset, uintN_t
ElfN_Section    Unsigned section index, uint16_t
ElfN_Versym     Unsigned version symbol information, uint16_t
Elf_Byte        unsigned char
ElfN_Half       uint16_t
ElfN_Sword      int32_t
ElfN_Word       uint32_t
ElfN_Sxword     int64_t
ElfN_Xword      uint64_t

#define EI_NIDENT 16

typedef struct {
	unsigned char e_ident[EI_NIDENT];
	uint16_t      e_type;
	uint16_t      e_machine;
	uint32_t      e_version;
	ElfN_Addr     e_entry;
	ElfN_Off      e_phoff;
	ElfN_Off      e_shoff;
	uint32_t      e_flags;
	uint16_t      e_ehsize;
	uint16_t      e_phentsize;
	uint16_t      e_phnum;
	uint16_t      e_shentsize;
	uint16_t      e_shnum;
	uint16_t      e_shstrndx;
} ElfN_Ehdr;
```

+ e_type-标识目标文件的类型：
  1. ET_NONE（0）：未知类型
  2. ET_REL（1）：A relocatable file. 可重定位文件
  3. ET_EXEC（2）：可执行文件
  4. ET_DYN （3）：共享目标文件
  5. ET_CORE（4）：coredump 文件
+ e_entry-该成员给出了启动进程的虚拟地址。如果文件没有相关的入口点，则该成员的值为零。
+ e_phoff-该成员保存program header table 在文件中的偏移量（以字节为单位字节）。如果文件没有程序头表，该值为零。
+ e_shoff-该成员保存section header table 在文件中的偏移量（以字节为单位）。如果文件没有段头表，该值为零。
+ e_ehsize-ELF 头的大小，字节为单位。
+ e_phentsize-指定了 program header table 中每条记录的大小，所有记录大小一样。
+ e_phnum-指定了 program header table 中有多少条记录，最大值为 PN_XNUM (0xffff)，e_phnum*e_phentsize = program header table的大小。如果超过了PN_XNUM，sh_info 会有额外指定
+ e_shentsize-指定了 section header table 中每条记录的大小，所有记录大小一样。
+ e_shnum-指定了 section header table 中有多少条记录，最大值为SHN_LORESERVE (0xff00)，e_shentsize*e_shnum=section header table的大小如果超过了SHN_LORESERVE， sh_size 会有额外指定

### Program header (Phdr)
An ELF file consists of zero or more segments, and describe how to create a process/memory image for runtime execution. When the kernel sees these segments, it uses them to map them into virtual address space, using the mmap(2) system call. In other words, it converts predefined instructions into a memory image. If your ELF file is a normal binary, it requires these program headers. Otherwise, it simply won’t run. It uses these headers, with the underlying data structure, to form a process. This process is similar for shared libraries.
<center>
<img src="pics/elf-program-header-2.png" alt="">
<!-- <img src="pics/elf-program-header.png" alt=""> -->
</center>

An executable or shared object file's program header table is an array of structures, each describing a segment or other information the system needs to prepare the program for execution.  An object file segment contains one or more sections. Program headers are meaningful only for executable and shared object files.  A file specifies its own program header size with the ELF header's e_phentsize and e_phnum members.  The ELF program header is described by the type Elf32_Phdr or Elf64_Phdr depending on the architecture:
```
typedef struct {
	uint32_t   p_type;
	Elf32_Off  p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	uint32_t   p_filesz;
	uint32_t   p_memsz;
	uint32_t   p_flags;
	uint32_t   p_align;
} Elf32_Phdr;
```
+ p_type- segment 的类型或者信息的类别
  1. PT_NULL 未定义或者未使用类型
  2. PT_LOAD 
  3. PT_DYNAMIC
  4. PT_INTERP
  5. PT_NOTE
  6. PT_SHLIB
  7. PT_PHDR 数组元素（如果存在）指定程序头表本身的位置和大小，包括在文件和程序内存映像中的位置和大小。此段类型在一个文件中不能出现多于一次。此外，只有当程序头表是程序内存映像的一部分时，它才可能出现。如果它存在，必须位于任何可加载段条目之前。
  8. PT_LOPROC, PT_HIPROC
  9.  PT_GNU_STACK
  10. GNU_EH_FRAME
+ p_offset- segment在文件中的起始位置
+ p_vaddr- segement 在虚拟内存中的起始位置
+ p_paddr- 关联的物理内存地址，一般为0
+ p_filesz- segment 的大小
+ p_memsz- segment在内存中的大小
+ p_flags- 该segment 的一些属性
  1. PF_X 可执行
  2. PF_W 可写
  3. PF_R 可读
+ p_align- 对齐单位（4字节对齐/8字节对齐）

### Section Header
```
typedef struct {
	uint32_t   sh_name;
	uint32_t   sh_type;
	uint32_t   sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off  sh_offset;
	uint32_t   sh_size;
	uint32_t   sh_link;
	uint32_t   sh_info;
	uint32_t   sh_addralign;
	uint32_t   sh_entsize;
} Elf32_Shdr;
```

1. sh_type 类型
<div><img src="pics/program-header-type.png" alt=""></div>

1. sh_flag 节标志
<div><img src="pics/section-flag.png" alt=""></div>


#### 常见section

<table>
<thead>
<tr class="header">
<th style="border: 1px solid; padding: 0.2rem 1.5rem">名字</th>
<th style="border: 1px solid; padding: 0.2rem 1.5rem">类型</th>
<th style="border: 1px solid; padding: 0.2rem 1.5rem">属性</th>
<th style="border: 1px solid; padding: 0.2rem 1.5rem">意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.init</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC +
SHF_EXECINSTR</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">此节包含进程初始化时要执行的程序指令。当程序开始运行时，系统会在进
入主函数之前执行这一节中的代码。</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.fini</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC +
SHF_EXECINSTR</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">此节包含进程终止时要执行的程序指令。当程序正常退出时，系统会执行这
一节中的代码。</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.bss</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_NOBITS</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC+SHF_WRITE</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节中包含目标文件中未初始化的全局变量。一般情况下，可执行程序在开
始运行的时候，系统会把这一段内容清零。但是，在运行期间的 bss
段是由系统初 始化而成的，在目标文件中.bss 节并不包含任何内容，其长度为
0，所以它的节类 型为 SHT_NOBITS。</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.comment</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">无</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节包含版本控制信息</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.data/.data1</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC+SHF_WRITE</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">这两个节用于存放程序中被初始化过的全局变量。在目标文件中，它们是占
用实际的存储空间的，与.bss 节不同。</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.debug</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">无</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">调试信息，内容格式没有统一规定。所有以”.debug”为前缀的节名
字都是保留</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.line</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">无</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节也是一个用于调试的节，它包含那些调试符号的行号，为程序指令码与
源文件的行号建立起联系。其内容格式没有统一规定。</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.dynamic</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_DYNAMIC</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">见下文</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节包含动态连接信息，并且可能有
SHF_ALLOC 和 SHF_WRITE 等属性。 是否具有 SHF_WRITE
属性取决于操作系统和处理器。</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.dynstr</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_STRTAB</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">此节含有用于动态连接的字符串，一般是那些与符号表相关的名字</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.dynsym</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_DYNSYM</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">此节含有动态连接符号表</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.got</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC +
SHF_WRITE</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">此节包含全局偏移量表(Global Offset Table，GOT)</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.hash</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_HASH</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节包含一张符号哈希表</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.interp</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">见下文</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.interp的内容很简单，里面保存的就是一个字符串，这个字符串就是可执行文件所需要的动态链接器的路径</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.note</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_NOTE</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">无</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">注释节</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.plt</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC +
SHF_EXECINSTR</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">此节包含函数连接表(Procedure Linkage Table)</td>
</tr>
<tr class="even">
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">.rel.data/.rel.text</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_REL/SHT_RELA</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">见下文</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">这两个节含有重定位信息。如果此节被包含在某个可装载的段中，那么本节
的属性中应置 SHF_ALLOC 标志位，否则不置此标志。</td>
</tr>
<tr class="even">
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">.rel.dyn/.rel.plt</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_REL/SHT_RELA</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">见下文</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">动态链接的文件中，也有类似的重定位表分别叫做“.rel.dyn”和“.rel.plt”，它们分别相当于“.rel.text”和“.rel.data”。“.rel.dyn”实际上是对数据引用的修正，它所修正的位置位于“.got”以及数据段；而“.rel.plt”是对函数引用的修正，它所修正的位置位于“.got.plt”。</td>
</tr>
<tr class="odd">
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">.rodata/.rodata1</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节包含程序中的只读数据，在程序装载时，它们一般会被装入进程空间中
那些只读的段中去</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.shstrtab</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_STRTAB</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">无</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节是“节名字表”，含有所有其它节的名字</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.strtab</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_STRTAB</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">见下文</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节用于存放字符串，主要是那些符号表项的名字。如果一个目标文件有一
个可装载的段，并且其中含有符号表，那么本节的属性中应该有 SHF_ALLOC</td>
</tr>
<tr class="even">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.symtab</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_SYMTAB</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">见下文</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节用于存放符号表。如果一个目标文件有一个可载入的段，并且其中含有
符号表，那么本节的属性中应该有 SHF_ALLOC。</td>
</tr>
<tr class="odd">
<td style="border: 1px solid; padding: 0.2rem 1.5rem">.text</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHT_PROGBITS</td>
<td style="border: 1px solid; padding: 0.2rem 1.5rem">SHF_ALLOC +
SHF_EXECINSTR</td>
<td
style="border: 1px solid; padding: 0.2rem 1.5rem">本节包含程序指令代码</td>
</tr>
</tbody>
</table>

#### 符号表和字符串表
符号表记录了目标文件中所用到的所有符号信息，通常分为 `.dynsym` 和 `.symtab` ，前者是后者的子集。
+ dynsym保存了引用自外部文件的符号，只能在运行时被解析
+ symtab还保存了本地符号，用于调试和链接。
+ 目标文件通过一个符号在表中的索引值来使用该符号。索引值从0开始计数，但值为0的表项不具有实际的意义，它表示未定义的符号STN_UNDEF。每个符号都有一个符号值（symbol value），对于变量和函数，该值就是符号的地址。

```C
typedef struct {
	uint32_t      st_name;
	Elf32_Addr    st_value;
	uint32_t      st_size;
	unsigned char st_info;
	unsigned char st_other;
	uint16_t      st_shndx;
} Elf32_Sym;
```
<center><img src="pics/symbol.png" alt=""></center>

符号表项的格式定义（Elf64_Sym结构体）， 如下所示:
<table>
<thead>
<tr>
<th style="border:1px solid; padding:0.2rem 1.5rem;">字段</th>
<th style="border:1px solid; padding:0.2rem 1.5rem;">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="border:1px solid; padding:0.2rem 1.5rem;">st_name</td>
<td style="border:1px solid; padding:0.2rem 1.5rem;">符号的名字。但它并不是一个字符串，而是一个指向字符串表的索引值。如果此值为0，那么此符号无名字。</td>
</tr>
<tr>
<td style="border:1px solid; padding:0.2rem 1.5rem;">st_value</td>
<td style="border:1px solid; padding:0.2rem 1.5rem;">符号的值。这个值其实没有固定的类型，它可能代表一个数值，也可以是一个地址，具体是什么要看上下文。
</tr>
<tr>
<td style="border:1px solid; padding:0.2rem 1.5rem;">st_size</td>
<td style="border:1px solid; padding:0.2rem 1.5rem;">符号的大小。各种符号的大小各不相同，比如一个对象的大小就是它实际占用的字节数。一个符号的大小为0或者大小未知，则这个值为 0。</td>
</tr>
<tr>
<td style="border:1px solid; padding:0.2rem 1.5rem;">st_info</td>
<td style="border:1px solid; padding:0.2rem 1.5rem;">符号的类型和属性。st_info 由一系列的比特位构成，标识了“符号绑定 (symbol binding)”、“符号类型(symbol type)”和“符号信息(symbol infomation)” 三种属性。STB_LOCAL
</tr>
<tr>
<td style="border:1px solid; padding:0.2rem 1.5rem;">st_other</td>
<td style="border:1px solid; padding:0.2rem 1.5rem;">本数据成员目前暂未使用，在目标文件中一律赋值为 0。</td>
</tr>
<tr>
<td style="border:1px solid; padding:0.2rem 1.5rem;">st_shndx</td>
<td style="border:1px solid; padding:0.2rem 1.5rem;">任何一个符号表项的定义都与某一个“节”相联系，因为符号是为节而定义，在节中被引用。本数据成员即指明了相关联的节。本数据成员是一个索引值， 它指向相关联的节在节头表中的索引。在重定位过程中，节的位置会改变，本数据成员的值也随之改变，继续指向节的新位置。
</tr>
</tbody>
</table>

<!-- <img style="display: block;-webkit-user-select: none;margin: auto;cursor: zoom-in;background-color: hsl(0, 0%, 90%);transition: background-color 300ms;" src="https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png" width="1219" height="862"> -->


## Windows PE（Portable-Executable）[文件格式](https://bbs.pediy.com/thread-270210.htm)
PE文件的结构如下:
<center><img src="pics/pe-file.png" width=30% ></center>

其中，真正的段开始之前的部分（上图中.text之前）的详细结构如下：
<center><img src="pics/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg" width=80% ></center>

1. COFF HEADER(IMAGE_FILE_HEADER)
   ```
	typedef struct _IMAGE_FILE_HEADER{
		WORD Machine;                               // +0x00, 指定程序的运行平台(386/x64)
		WORD NumberOfSections;          // +0x02, PE中的节/块(section)数量
		DWORD TimeDateStamp;                // +0x04, 时间戳：链接器填写的文件生成时间
		DWORD PointerToSymbolTable;  // +0x08, 指向符号表的地址(主要用于调试)
		DWORD NumberOfSymbols;          // +0x0C, 符号表中符号个数(同上)
		WORD SizeOfOptionalHeader;  // +0x10, IMAGE_OPTIONAL_HEADER32选项头结构大小，勿改
		WORD Characteristics;               // +0x12, 文件属性，勿改
	} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
   ```

2. Optional Header(IMAGE_OPTIONAL_HEADER32)
   ```
   typedef struct _IMAGE_OPTIONAL_HEADER
	{
		WORD   Magic;                            //* PE标志字：32位（0x10B），64位（0x20B）
		BYTE   MajorLinkerVersion;               //  主链接器版本号
		BYTE   MinorLinkerVersion;               //  副链接器版本号
		DWORD  SizeOfCode;                        //  代码所占空间大小（代码节大小）
		DWORD  SizeOfInitializedData;         //  已初始化数据所占空间大小
		DWORD  SizeOfUninitializedData;           //  未初始化数据所占空间大小
		DWORD  AddressOfEntryPoint;               //* 程序执行入口RVA，(w)(Win)mainCRTStartup：即0D首次断下来的自进程地址
		DWORD  BaseOfCode;                        //  代码段基址
		DWORD  BaseOfData;                        //  数据段基址
		DWORD  ImageBase;                     //* 内存加载基址，exe默认0x400000，dll默认0x10000000
		DWORD  SectionAlignment;              //* 节区数据在内存中的对齐值，一定是4的倍数，一般是0x1000(4096=4K)
		DWORD  FileAlignment;                 //* 节区数据在文件中的对齐值，一般是0x200(磁盘扇区大小512)
		WORD   MajorOperatingSystemVersion;      //  要求操作系统最低版本号的主版本号
		WORD   MinorOperatingSystemVersion;      //  要求操作系统最低版本号的副版本号
		WORD   MajorImageVersion;                //  可运行于操作系统的主版本号
		WORD   MinorImageVersion;                //  可运行于操作系统的次版本号
		WORD   MajorSubsystemVersion;            //  主子系统版本号：不可修改
		WORD   MinorSubsystemVersion;            //  副子系统版本号
		DWORD  Win32VersionValue;             //  版本号：不被病毒利用的话一般为0,XP中不可修改
		DWORD  SizeOfImage;                       //* PE文件在进程内存中的总大小，与SectionAlignment对齐
		DWORD  SizeOfHeaders;                 //* PE文件头部在文件中的按照文件对齐后的总大小（所有头 + 节表）
		DWORD  CheckSum;                      //  对文件做校验，判断文件是否被修改：3环无用，MapFileAndCheckSum获取
		WORD   Subsystem;                        //  子系统，与连接选项/system相关：1=驱动程序，2=图形界面，3=控制台/Dll
		WORD   DllCharacteristics;               //  文件特性
		DWORD  SizeOfStackReserve;                //  初始化时保留的栈大小
		DWORD  SizeOfStackCommit;             //  初始化时实际提交的栈大小
		DWORD  SizeOfHeapReserve;             //  初始化时保留的堆大小
		DWORD  SizeOfHeapCommit;              //  初始化时实际提交的堆大小
		DWORD  LoaderFlags;                       //  已废弃，与调试有关，默认为 0
		DWORD  NumberOfRvaAndSizes;               //  下边数据目录的项数，此字段自Windows NT发布以来,一直是16
		IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];// 数据目录表
	} IMAGE_OPTIONAL_HEADER32, * PIMAGE_OPTIONAL_HEADER32;
	```
	 IMAGE_DATA_DIRECTORY: 数据目录用来描述PE中各个表的位置及大小信息，重点表有导出表、导入表、重定位表、资源表。
	```
	typedef struct _IMAGE_DATA_DIRECTORY {
		DWORD VirtualAddress;     /**指向某个数据的相对虚拟地址   RAV  偏移0x00**/
		DWORD Size;               /**某个数据块的大小                 偏移0x04**/
	} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
	```

3. Section Table(IMAGE_SECTION_HEADER)
   ```
   typedef struct _IMAGE_SECTION_HEADER {
		BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];  // 节表名称：描述性字段
		// 下方4个字段：从文件S1处开始，拷贝S2大小的数据，到内存S3处，有效数据占用内存S4大小
		union {
			DWORD PhysicalAddress;
			DWORD VirtualSize;         // S4:内存大小
		} Misc;
		DWORD VirtualAddress;          // S3:内存地址：基于模块基址
		DWORD SizeOfRawData;           // S2:文件大小
		DWORD PointerToRawData;        // S1:文件偏移
		DWORD PointerToRelocations;    // 无用
		DWORD PointerToLinenumbers;    // 无用
		WORD  NumberOfRelocations;    // 无用
		WORD  NumberOfLinenumbers;    // 无用
		DWORD Characteristics;     // 节属性，取值IMAGE_SCN_...系列宏
	} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
   ```

## 工具程序
1. `objdump` -用来查看目标文件或库文件的信息 ，`objdump option <filename>`
   + `-h`: 查看目标文件的各个段的基本信息。
   + `-s`: 将各个段的内容以十六进制打印出来
   + `-d`: 将包含指令的段反汇编打印出来 
   + `-D`: 反编译所有段
   + `-r`: 查看重定位表
   + `-t`: 查看符号表
2. `dumpbin` -用来查看windows 下的目标文件格式
	+ `/SUMMARY`：查看段信息
	+ `/SYMBOLS`：查看符号表
	+ `/RELOCATIONS`：查看重定位表
	+ `/HEADERS`：
3. `size` -查看目标文件各个段的长度
4. `readelf` -查看elf 文件的信息
	+ `-s`:查看目标文件的符号表
	+ `-h/--file-header`: Display the ELF file header
	+ `-l/--program-headers`: Display the program headers
	+ `-S/--section-headers`: Display the sections' header
	+ `-s/--syms`: Display the symbol table
	+ `-d --dynamic`: Display the dynamic section (if present)
5. `ar` -压缩/解压程序，通常用来将若干目标文件打包成一个库文件
   + `-t`：查看库文件中包含哪些目标文件 `ar -t libc.a`
   + `-x`:解压打包的文件 `ar -x libc.a`
6. `file`-查看文件的简要信息，`apt install file`
7. `hexdump -C -n 64 a.out` -观察二进制文件的二进制内容前64字节
8. `ldd hello` - 查看一个程序主模块或一个共享库依赖于哪些共享库
9. pax-utils-`apt install pax-utils`
   + `/usr/bin/dumpelf` – dump internal ELF structure
   + `/usr/bin/lddtree` – like ldd, with levels to show dependencies
   + `/usr/bin/pspax` – list ELF/PaX information about running processes
   + `/usr/bin/scanelf` – wide range of information, including PaX details
   + `/usr/bin/scanmacho` – shows details for Mach-O binaries (Mac OS X)
   + `/usr/bin/symtree` – displays a leveled output for symbols
10. [Radare2](https://www.radare.org/r/)
11. elfutils -`sudo apt install elfutils -y`
    + /usr/bin/eu-addr2line
	+ /usr/bin/eu-ar – alternative to ar, to create, manipulate archive files
	+ /usr/bin/eu-elfcmp
	+ /usr/bin/eu-elflint – compliance check against gABI and psABI specifications
	+ /usr/bin/eu-findtextrel – find text relocations
	+ /usr/bin/eu-ld – combining object and archive files
	+ /usr/bin/eu-make-debug-archive
	+ /usr/bin/eu-nm – display symbols from object/executable files
	+ /usr/bin/eu-objdump – show information of object files
	+ /usr/bin/eu-ranlib – create index for archives for performance
	+ /usr/bin/eu-readelf – human-readable display of ELF files
	+ /usr/bin/eu-size – display size of each section (text, data, bss, etc)
	+ /usr/bin/eu-stack – show the stack of a running process, or coredump
	+ /usr/bin/eu-strings – display textual strings (similar to strings utility)
	+ /usr/bin/eu-strip – strip ELF file from symbol tables
	+ /usr/bin/eu-unstrip – add symbols and debug information to stripped binary
12. elfkickers
    + /usr/bin/ebfc – compiler for Brainfuck programming language
	+ /usr/bin/elfls – shows program headers and section headers with flags
	+ /usr/bin/elftoc – converts a binary into a C program
	+ /usr/bin/infect – tool to inject a dropper, which creates setuid file in /tmp
	+ /usr/bin/objres – creates an object from ordinary or binary data
	+ /usr/bin/rebind – changes bindings/visibility of symbols in ELF file
	+ /usr/bin/sstrip – strips unneeded components from ELF file
13. prelink
    + /usr/bin/execstack – display or change if stack is executable
	+ /usr/bin/prelink – remaps/relocates calls in ELF files, to speed up the process
   
### objdump 和 readelf 的区别
/* The difference between readelf and objdump:

   Both programs are capabale of displaying the contents of ELF format files,
   so why does the binutils project have two file dumpers ?

   The reason is that objdump sees an ELF file through a BFD filter of the
   world; if BFD has a bug where, say, it disagrees about a machine constant
   in e_flags, then the odds are good that it will remain internally
   consistent.  The linker sees it the BFD way, objdump sees it the BFD way,
   GAS sees it the BFD way.  There was need for a tool to go find out what
   the file actually says.

   This is why the readelf program does not link against the BFD library - it
   exists as an independent program to help verify the correct working of BFD.

   There is also the case that readelf can provide more information about an
   ELF file than is provided by objdump.  In particular it can display DWARF
   debugging information which (at the moment) objdump cannot.  */

BFD（Binary File Descriptor）过滤器是 GNU Binutils 项目中的一个库，用于统一处理不同二进制文件格式（如 ELF、COFF、a.out 等）的抽象层。BFD 提供了一套通用接口，使得工具如链接器、反汇编器和调试器可以通过这个统一接口处理各种格式的二进制文件，而不必关心底层文件格式的具体细节。

通过 BFD 过滤器，工具可以：
+ 读取和写入不同格式的二进制文件：BFD 使得工具可以透明地处理不同格式的二进制文件，隐藏了文件格式的复杂性。
+ 转换和处理目标文件：BFD 可以处理各种目标文件的细节，包括符号表、重定位信息、调试信息等。
+ 保持内部一致性：所有通过 BFD 库处理的工具（如 objdump、链接器、汇编器）都使用相同的内部表示和常量，这确保了这些工具之间的行为一致。
由于 BFD 层的抽象和一致性处理，可能会出现一些情况下，实际的文件内容与通过 BFD 接口看到的内容存在差异。这就是为什么需要一个独立的工具如 readelf，它直接读取并显示 ELF 文件的实际内容，不经过 BFD 的处理，以便于验证和调试 BFD 库的正确性。  
总之，BFD 过滤器在处理二进制文件格式时提供了统一的抽象接口和一致性处理，但有时也需要像 `readelf` 这样的工具来验证其输出的准确性。

一般C语言的编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一个叫“.bss”的段里.

最基本的代码段(.text)、数据段(.data)和BSS(.bss)段以外，还有3个段分别是只读数据段（.rodata）、注释信息段（.comment）和堆栈提示段（.note.GNU-stack），这3个额外的段的意义我们暂且不去细究。先来看看几个重要的段的属性，其中最容易理解的是段的长度（Size）和段所在的位置（File Offset），每个段的第2行中的“CONTENTS”、“ALLOC”等表示段的各种属性，“CONTENTS”表示该段在文件中存在。我们可以看到BSS段没有“CONTENTS”，表示它实际上在ELF文件中不存在内容。“.note.GNU-stack”段虽然有“CONTENTS”，但它的长度为0，这是个很古怪的段，我们暂且忽略它，认为它在ELF文件中也不存在
