#  可执行文件格式
{docsify-updated}
> https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/

## 工具程序
1. `objdump` -用来查看目标文件或库文件的信息
   
   `objdump option <filename>`
   
   + `-h`: 查看目标文件的各个段的基本信息。
   + `-s`: 将各个段的内容以十六进制打印出来
   + `-d`: 将包含指令的段反汇编打印出来 
   + `-r`: 查看重定位表
   + `-t`: 查看符号表

2. `dumpbin` -用来查看windows 下的目标文件格式
	+ `/SUMMARY`：查看段信息
	+ `/SYMBOLS`：查看符号表
	+ `/RELOCATIONS`：查看重定位表
	+ `/HEADERS`：

3. `size` -查看目标文件各个段的长度
   
4. `readelf` -查看elf 文件的信息
	+ `-s`:查看目标文件的符号表
	+ `-h/--file-header`: Display the ELF file header
	+ `-l/--program-headers`: Display the program headers
	+ `-S/--section-headers`: Display the sections' header
	+ `-s/--syms`: Display the symbol table

5. `ar` -压缩/解压程序，通常用来将若干目标文件打包成一个库文件
   + `-t`：查看库文件中包含哪些目标文件 `ar -t libc.a`
   + `-x`:解压打包的文件 `ar -x libc.a`

6. `file`-查看文件的简要信息，`apt install file`
7. `hexdump -C -n 64 a.out` -观察二进制文件的二进制内容前64字节

pax-utils-`apt install pax-utils`
+ `/usr/bin/dumpelf` – dump internal ELF structure
+ `/usr/bin/lddtree` – like ldd, with levels to show dependencies
+ `/usr/bin/pspax` – list ELF/PaX information about running processes
+ `/usr/bin/scanelf` – wide range of information, including PaX details
+ `/usr/bin/scanmacho` – shows details for Mach-O binaries (Mac OS X)
+ `/usr/bin/symtree` – displays a leveled output for symbols
   
### objdump 和 readelf 的区别
/* The difference between readelf and objdump:

   Both programs are capabale of displaying the contents of ELF format files,
   so why does the binutils project have two file dumpers ?

   The reason is that objdump sees an ELF file through a BFD filter of the
   world; if BFD has a bug where, say, it disagrees about a machine constant
   in e_flags, then the odds are good that it will remain internally
   consistent.  The linker sees it the BFD way, objdump sees it the BFD way,
   GAS sees it the BFD way.  There was need for a tool to go find out what
   the file actually says.

   This is why the readelf program does not link against the BFD library - it
   exists as an independent program to help verify the correct working of BFD.

   There is also the case that readelf can provide more information about an
   ELF file than is provided by objdump.  In particular it can display DWARF
   debugging information which (at the moment) objdump cannot.  */

BFD（Binary File Descriptor）过滤器是 GNU Binutils 项目中的一个库，用于统一处理不同二进制文件格式（如 ELF、COFF、a.out 等）的抽象层。BFD 提供了一套通用接口，使得工具如链接器、反汇编器和调试器可以通过这个统一接口处理各种格式的二进制文件，而不必关心底层文件格式的具体细节。

通过 BFD 过滤器，工具可以：
+ 读取和写入不同格式的二进制文件：BFD 使得工具可以透明地处理不同格式的二进制文件，隐藏了文件格式的复杂性。
+ 转换和处理目标文件：BFD 可以处理各种目标文件的细节，包括符号表、重定位信息、调试信息等。
+ 保持内部一致性：所有通过 BFD 库处理的工具（如 objdump、链接器、汇编器）都使用相同的内部表示和常量，这确保了这些工具之间的行为一致。
由于 BFD 层的抽象和一致性处理，可能会出现一些情况下，实际的文件内容与通过 BFD 接口看到的内容存在差异。这就是为什么需要一个独立的工具如 readelf，它直接读取并显示 ELF 文件的实际内容，不经过 BFD 的处理，以便于验证和调试 BFD 库的正确性。  
总之，BFD 过滤器在处理二进制文件格式时提供了统一的抽象接口和一致性处理，但有时也需要像 `readelf` 这样的工具来验证其输出的准确性。

一般C语言的编译后执行语句都编译成机器代码，保存在.text段；已初始化的全局变量和局部静态变量都保存在.data段；未初始化的全局变量和局部静态变量一般放在一个叫“.bss”的段里.

最基本的代码段(.text)、数据段(.data)和BSS(.bss)段以外，还有3个段分别是只读数据段（.rodata）、注释信息段（.comment）和堆栈提示段（.note.GNU-stack），这3个额外的段的意义我们暂且不去细究。先来看看几个重要的段的属性，其中最容易理解的是段的长度（Size）和段所在的位置（File Offset），每个段的第2行中的“CONTENTS”、“ALLOC”等表示段的各种属性，“CONTENTS”表示该段在文件中存在。我们可以看到BSS段没有“CONTENTS”，表示它实际上在ELF文件中不存在内容。“.note.GNU-stack”段虽然有“CONTENTS”，但它的长度为0，这是个很古怪的段，我们暂且忽略它，认为它在ELF文件中也不存在

## ELF文件格式 

<img style="display: block;-webkit-user-select: none;margin: auto;cursor: zoom-in;background-color: hsl(0, 0%, 90%);transition: background-color 300ms;" src="https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png" width="1219" height="862">


## Windows PE（Portable-Executable）[文件格式](https://bbs.pediy.com/thread-270210.htm)
PE文件的结构如下:
<center><img src="pics/pe-file.png" width=30% ></center>

其中，真正的段开始之前的部分（上图中.text之前）的详细结构如下：
<center><img src="pics/Portable_Executable_32_bit_Structure_in_SVG_fixed.svg" width=80% ></center>

1. COFF HEADER(IMAGE_FILE_HEADER)
   ```
	typedef struct _IMAGE_FILE_HEADER{
		WORD Machine;                               // +0x00, 指定程序的运行平台(386/x64)
		WORD NumberOfSections;          // +0x02, PE中的节/块(section)数量
		DWORD TimeDateStamp;                // +0x04, 时间戳：链接器填写的文件生成时间
		DWORD PointerToSymbolTable;  // +0x08, 指向符号表的地址(主要用于调试)
		DWORD NumberOfSymbols;          // +0x0C, 符号表中符号个数(同上)
		WORD SizeOfOptionalHeader;  // +0x10, IMAGE_OPTIONAL_HEADER32选项头结构大小，勿改
		WORD Characteristics;               // +0x12, 文件属性，勿改
	} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
   ```

2. Optional Header(IMAGE_OPTIONAL_HEADER32)
   ```
   typedef struct _IMAGE_OPTIONAL_HEADER
	{
		WORD   Magic;                            //* PE标志字：32位（0x10B），64位（0x20B）
		BYTE   MajorLinkerVersion;               //  主链接器版本号
		BYTE   MinorLinkerVersion;               //  副链接器版本号
		DWORD  SizeOfCode;                        //  代码所占空间大小（代码节大小）
		DWORD  SizeOfInitializedData;         //  已初始化数据所占空间大小
		DWORD  SizeOfUninitializedData;           //  未初始化数据所占空间大小
		DWORD  AddressOfEntryPoint;               //* 程序执行入口RVA，(w)(Win)mainCRTStartup：即0D首次断下来的自进程地址
		DWORD  BaseOfCode;                        //  代码段基址
		DWORD  BaseOfData;                        //  数据段基址
		DWORD  ImageBase;                     //* 内存加载基址，exe默认0x400000，dll默认0x10000000
		DWORD  SectionAlignment;              //* 节区数据在内存中的对齐值，一定是4的倍数，一般是0x1000(4096=4K)
		DWORD  FileAlignment;                 //* 节区数据在文件中的对齐值，一般是0x200(磁盘扇区大小512)
		WORD   MajorOperatingSystemVersion;      //  要求操作系统最低版本号的主版本号
		WORD   MinorOperatingSystemVersion;      //  要求操作系统最低版本号的副版本号
		WORD   MajorImageVersion;                //  可运行于操作系统的主版本号
		WORD   MinorImageVersion;                //  可运行于操作系统的次版本号
		WORD   MajorSubsystemVersion;            //  主子系统版本号：不可修改
		WORD   MinorSubsystemVersion;            //  副子系统版本号
		DWORD  Win32VersionValue;             //  版本号：不被病毒利用的话一般为0,XP中不可修改
		DWORD  SizeOfImage;                       //* PE文件在进程内存中的总大小，与SectionAlignment对齐
		DWORD  SizeOfHeaders;                 //* PE文件头部在文件中的按照文件对齐后的总大小（所有头 + 节表）
		DWORD  CheckSum;                      //  对文件做校验，判断文件是否被修改：3环无用，MapFileAndCheckSum获取
		WORD   Subsystem;                        //  子系统，与连接选项/system相关：1=驱动程序，2=图形界面，3=控制台/Dll
		WORD   DllCharacteristics;               //  文件特性
		DWORD  SizeOfStackReserve;                //  初始化时保留的栈大小
		DWORD  SizeOfStackCommit;             //  初始化时实际提交的栈大小
		DWORD  SizeOfHeapReserve;             //  初始化时保留的堆大小
		DWORD  SizeOfHeapCommit;              //  初始化时实际提交的堆大小
		DWORD  LoaderFlags;                       //  已废弃，与调试有关，默认为 0
		DWORD  NumberOfRvaAndSizes;               //  下边数据目录的项数，此字段自Windows NT发布以来,一直是16
		IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];// 数据目录表
	} IMAGE_OPTIONAL_HEADER32, * PIMAGE_OPTIONAL_HEADER32;
	```
	 IMAGE_DATA_DIRECTORY: 数据目录用来描述PE中各个表的位置及大小信息，重点表有导出表、导入表、重定位表、资源表。
	```
	typedef struct _IMAGE_DATA_DIRECTORY {
		DWORD VirtualAddress;     /**指向某个数据的相对虚拟地址   RAV  偏移0x00**/
		DWORD Size;               /**某个数据块的大小                 偏移0x04**/
	} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
	```

3. Section Table(IMAGE_SECTION_HEADER)
   ```
   typedef struct _IMAGE_SECTION_HEADER {
		BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];  // 节表名称：描述性字段
		// 下方4个字段：从文件S1处开始，拷贝S2大小的数据，到内存S3处，有效数据占用内存S4大小
		union {
			DWORD PhysicalAddress;
			DWORD VirtualSize;         // S4:内存大小
		} Misc;
		DWORD VirtualAddress;          // S3:内存地址：基于模块基址
		DWORD SizeOfRawData;           // S2:文件大小
		DWORD PointerToRawData;        // S1:文件偏移
		DWORD PointerToRelocations;    // 无用
		DWORD PointerToLinenumbers;    // 无用
		WORD  NumberOfRelocations;    // 无用
		WORD  NumberOfLinenumbers;    // 无用
		DWORD Characteristics;     // 节属性，取值IMAGE_SCN_...系列宏
	} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
   ```
