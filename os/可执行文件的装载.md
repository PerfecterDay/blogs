# 装载与动态链接
{docsify-updated}

## 可执行文件的装载与运行
从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建，那么我们就来看看这种最通常的情形：创建一个进程，然后装载相应的可执行文件并且执行。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：
1. 创建一个独立的虚拟地址空间。
2. 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。

### 分配虚拟空间，创建进程
首先是创建虚拟地址空间。回忆第1章的页映射机制，我们知道一个虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，在i386 的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置。

### 映射可执行文件
上面那一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所做的是**虚拟空间与可执行文件的映射关系**。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。但是很明显的一点是，当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。

由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件（Image）。

让我们考虑最简单的情况，假设我们的ELF可执行文件只有一个代码段“.text“，它的虚拟地址为0x08048000，它在文件中的大小为0x000e1，对齐为0x1000。由于虚拟存储的页映射都是以页为单位的，在32位的Intel IA32下一般为4 096字节，所以32位ELF的对齐粒度为0x1000。由于该.text段大小不到一个页，考虑到对齐该段占用一个段。所以一旦该可执行文件被装载，可执行文件与执行该可执行文件进程的虚拟空间的映射关系如图所示：
<center><img src="pics/vma.png" width="30%"></center>

这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟空间中的一个段叫做**虚拟内存区域**（VMA-Virtual Memory Area），在Windows中将这个叫做**虚拟段**（VirtualSection），其实它们都是同一个概念。比如上例中，操作系统创建进程后，会在进程相应的数据结构中设置有一个.text 段的VMA：它在虚拟空间中的地址为 0x08048000～0x08049000，它对应ELF文件中偏移为0的.text，它的属性为只读（一般代码段都是只读的），还有一些其他的属性。

上面的例子中，我们描述的是最简单的只有一个段的可执行文件映射的情况。操作系统在内部保存这种结构，很明显是因为当程序执行发生段错误时，它可以通过查找这样的一个数据结构来定位错误页在可执行文件中的位置，此内容后面会详细介绍。

### 跳转到进程入口执行
第三步其实也是最简单的一步，操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及**内核堆栈和用户堆栈的切换、CPU运行权限的切换等**。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址。还记得ELF文件中保存有入口地址吗？没错，就是这个地址。

### 缺页错误
上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。假设在上面的例子中，程序的入口地址为0x08048000，即刚好是.text段的起始地址。当CPU开始打算执行这个地址的指令时，发现页面0x08048000～0x08049000是个空页面，于是它就认为这是一个页错误（Page Fault）。CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。这时候我们前面提到的装载过程的第二步建立的数据结构起到了很关键的作用，操作系统将查询这个数据结构，然后找到空页面所在的VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还回给进程，进程从刚才页错误的位置重新开始执行。

<center><img src="pics/page-fault.png" width="30%"></center>

随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求，如上图所示。当然有可能进程所需要的内存会超过可用的内存数量，特别是在有多个进程同时执行的时候，这时候操作系统就需要精心组织和分配物理内存，甚至有时候应将分配给进程的物理内存暂时收回等，这就涉及了操作系统的虚拟存储管理。

### 堆和栈
在操作系统里面，VMA除了被用来映射可执行文件中的各个“Segment”以外，它还可以有其他的作用，操作系统通过使用VMA来对进程的地址空间进行管理。我们知道进程在执行的时候它还需要用到栈（Stack）、堆（Heap）等空间，事实上它们在进程的虚拟空间中的表现也是以VMA的形式存在的，很多情况下，一个进程中的栈和堆分别都有一个对应的VMA。在Linux下，我们可以通过查看“/proc”来查看进程的虚拟空间分布：
```
└─$ cat /proc/self/maps
55f063058000-55f06305a000 r--p 00000000 08:30 30004                      /usr/bin/cat
55f06305a000-55f06305f000 r-xp 00002000 08:30 30004                      /usr/bin/cat
55f06305f000-55f063062000 r--p 00007000 08:30 30004                      /usr/bin/cat
55f063062000-55f063063000 r--p 00009000 08:30 30004                      /usr/bin/cat
55f063063000-55f063064000 rw-p 0000a000 08:30 30004                      /usr/bin/cat
55f064bd2000-55f064bf3000 rw-p 00000000 00:00 0                          [heap]
7fe4e9f5e000-7fe4e9f80000 rw-p 00000000 00:00 0
7fe4e9f80000-7fe4e9fd8000 r--p 00000000 08:30 40560                      /usr/lib/locale/aa_DJ.utf8/LC_CTYPE
7fe4e9fd8000-7fe4e9fd9000 r--p 00000000 08:30 40612                      /usr/lib/locale/aa_ET/LC_NUMERIC
7fe4e9fd9000-7fe4e9fda000 r--p 00000000 08:30 48353                      /usr/lib/locale/en_US.utf8/LC_TIME
7fe4e9fda000-7fe4ea252000 r--p 00000000 08:30 40556                      /usr/lib/locale/aa_DJ.utf8/LC_COLLATE
7fe4ea252000-7fe4ea253000 r--p 00000000 08:30 43256                      /usr/lib/locale/chr_US/LC_MONETARY
7fe4ea253000-7fe4ea254000 r--p 00000000 08:30 48035                      /usr/lib/locale/en_AG/LC_MESSAGES/SYS_LC_MESSAGES
7fe4ea254000-7fe4ea255000 r--p 00000000 08:30 43257                      /usr/lib/locale/chr_US/LC_PAPER
7fe4ea255000-7fe4ea258000 rw-p 00000000 00:00 0
7fe4ea258000-7fe4ea27e000 r--p 00000000 08:30 3814                       /usr/lib/x86_64-linux-gnu/libc.so.6
7fe4ea27e000-7fe4ea3d5000 r-xp 00026000 08:30 3814                       /usr/lib/x86_64-linux-gnu/libc.so.6
7fe4ea3d5000-7fe4ea42a000 r--p 0017d000 08:30 3814                       /usr/lib/x86_64-linux-gnu/libc.so.6
7fe4ea42a000-7fe4ea42e000 r--p 001d1000 08:30 3814                       /usr/lib/x86_64-linux-gnu/libc.so.6
7fe4ea42e000-7fe4ea430000 rw-p 001d5000 08:30 3814                       /usr/lib/x86_64-linux-gnu/libc.so.6
7fe4ea430000-7fe4ea43d000 rw-p 00000000 00:00 0
7fe4ea43d000-7fe4ea43e000 r--p 00000000 08:30 43134                      /usr/lib/locale/bi_VU/LC_NAME
7fe4ea43e000-7fe4ea43f000 r--p 00000000 08:30 48349                      /usr/lib/locale/en_US.utf8/LC_ADDRESS
7fe4ea43f000-7fe4ea440000 r--p 00000000 08:30 43258                      /usr/lib/locale/chr_US/LC_TELEPHONE
7fe4ea440000-7fe4ea441000 r--p 00000000 08:30 43254                      /usr/lib/locale/chr_US/LC_MEASUREMENT
7fe4ea441000-7fe4ea448000 r--s 00000000 08:30 3803                       /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
7fe4ea448000-7fe4ea449000 r--p 00000000 08:30 48351                      /usr/lib/locale/en_US.utf8/LC_IDENTIFICATION
7fe4ea449000-7fe4ea44b000 rw-p 00000000 00:00 0
7fe4ea44b000-7fe4ea44c000 r--p 00000000 08:30 3811                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fe4ea44c000-7fe4ea471000 r-xp 00001000 08:30 3811                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fe4ea471000-7fe4ea47b000 r--p 00026000 08:30 3811                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fe4ea47b000-7fe4ea47d000 r--p 00030000 08:30 3811                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fe4ea47d000-7fe4ea47f000 rw-p 00032000 08:30 3811                       /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffff78ad000-7ffff78ce000 rw-p 00000000 00:00 0                          [stack]
7ffff7944000-7ffff7948000 r--p 00000000 00:00 0                          [vvar]
7ffff7948000-7ffff794a000 r-xp 00000000 00:00 0                          [vdso]
```
上面的输出结果中：第一列是VMA的地址范围；第二列是VMA的权限，“r”表示可读，“w”表示可写，“x”表示可执行，“p”表示私有（COW, Copy on Write），“s”表示共享。第三列是偏移，表示VMA对应的Segment在映像文件中的偏移；第四列表示映像文件所在设备的主设备号和次设备号；第五列表示映像文件的节点号。最后一列是映像文件的路径。

有些VMA的文件所在设备主设备号和次设备号及文件节点号都是0，则表示它们没有映射到文件中，这种VMA叫做**匿名虚拟内存区域（Anonymous Virtual Memory Area）**。我们可以看到有两个区域分别是堆（Heap）和栈（Stack）。这两个VMA几乎在所有的进程中存在，我们在C语言程序里面最常用的malloc()内存分配函数就是从堆里面分配的，堆由系统库管理，我们在第10章会详细介绍关于堆的内容。栈一般也叫做堆栈，我们知道每个线程都有属于自己的堆栈，对于单线程的程序来讲，这个VMA堆栈就全都归它使用。另外有一个很特殊的VMA叫做 [VDSO（virtual dynamic shared object）](https://hackmd.io/@sysprog/linux-vdso) ，它的地址已经位于内核空间了（即大于0xC0000000的地址），事实上它是一个内核的模块，进程可以通过访问这个VMA来跟内核进行一些通信。

### 小结
操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA；一个进程基本上可以分为如下几种VMA区域：
+ 代码VMA，权限只读、可执行；有映像文件。 
+ 数据VMA，权限可读写、可执行；有映像文件。 
+ 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。 
+ 栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。

<center><img src="pics/process-vma.png" width="30%"></center>


## Linux内核装载ELF过程简介
当我们在Linux系统的bash下输入一个命令执行某个ELF程序时，Linux系统是怎样装载这个ELF文件并且执行它的呢？

首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用 execve() 系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。 execve() 系统调用被定义在unistd.h，它的原型如下:
```C
int execve(const char *filename, char *const argv[], char *const envp[])
```
它的三个参数分别是被执行的程序文件名、执行参数和环境变量。glibc对 `execvp()` 系统调用进行了包装，提供了 `execl()、execlp()、execle()、execv() 和 execvp()` 等5个不同形式的 `exec` 系列API，它们只是在调用的参数形式上有所区别，但最终都会调用到 `execve()` 这个系统調用中。

在进入 execve() 系统调用之后，Linux内核就开始进行真正的装载工作。在内核中， execve() 系统调用相应的入口是 sys_execve()， 它被定义在arch\i386\kernel\Process.c。 sys_execve() 进行一些参数的检查复制之后调用 do_execve()。do_execve() 会首先查找被执行的文件，如果找到文件，则读取文件的前128个字节。为什么要这么做呢？因为我们知道，Linux支持的可执行文件不止ELF一种，还有a.out、Java程序和以“#!”开始的脚本程序。Linux还可以支持更多的可执行文件格式，如果某一天Linux须支持Windows PE的可执行文件格式，那么我们可以编写一个支持PE装载的内核模块来实现Linux对PE文件的支持。这里 do_execve()读取文件的前128个字节的目的是判断文件的格式，每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称做魔数（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如ELF的可执行文件格式的头4个字节为0x7F、’e’、’l’、’f’；而Java的可执行文件格式的头4个字节为’c’、’a’、’f’、’e’；如果被执行的是Shell脚本或perl、python等这种解释型语言的脚本，那么它的第一行往往是“#!/bin/sh”或“#!/usr/bin/perl”或“#!/usr/bin/python”，这时候前两个字节’#’和’!’就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。

当 do_execve() 读取了这128个字节的文件头部之后，然后调用search_binary_handle() 去搜索和匹配合适的可执行文件装载处理过程。Linux中所有被支持的可执行文件格式都有相应的装载处理过程search_binary_handle() 会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如ELF可执行文件的装载处理过程叫做load_elf_binary()； a.out可执行文件的装载处理过程叫做 load_aout_binary()； 而装载可执行脚本程序的处理过程叫做 load_script()。 这里我们只关心ELF可执行文件的装载， load_elf_binary() 被定义在fs/Binfmt_elf.c，这个函数的代码比较长，它的主要步骤是：
1. 检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。
2. 寻找动态链接的“.interp”段，设置动态链接器路径（与动态链接 有关，具体请参考第9章）。
3. 根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。
4. 初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址（参照动态链接）。
5. 将系统调用的返回地址修改成ELF可执行文件的入口点，这个 入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中 e_entry 所指的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。

当 load_elf_binary() 执行完毕，返回至 do_execve() 再返回至 sys_execve() 时，上面的第5步中已经把系统调用的返回地址改成了被装载的ELF程序的入口地址了。所以当 sys_execve() 系统调用从内核态返回到用户态时，EIP寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。
