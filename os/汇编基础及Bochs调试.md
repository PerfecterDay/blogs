# 汇编基础及Bochs调试
{docsify-updated}

- [汇编基础及Bochs调试](#汇编基础及bochs调试)
    - [IA32指令](#ia32指令)
    - [寻址方式](#寻址方式)
      - [寄存器寻址](#寄存器寻址)
      - [立即数寻址](#立即数寻址)
      - [内存寻址](#内存寻址)
      - [注释](#注释)
      - [mov 指令](#mov-指令)
      - [movsb 和 movsw](#movsb-和-movsw)
      - [cmp指令](#cmp指令)
      - [标号](#标号)
      - [分段（Section/Segment)](#分段sectionsegment)
      - [NASM 编译器的$和$$标记](#nasm-编译器的和标记)
      - [在程序中声明并初始化数据](#在程序中声明并初始化数据)
      - [一些伪指令](#一些伪指令)
      - [jmp 无条件跳转指令](#jmp-无条件跳转指令)
      - [条件跳转指令](#条件跳转指令)
      - [栈指令](#栈指令)
      - [过程调用](#过程调用)
      - [loop循环指令](#loop循环指令)
      - [速记指令](#速记指令)
  - [Bochs 调试](#bochs-调试)
    - [Bochs调试命令](#bochs调试命令)

### IA32指令
<center>
<img src="pics/IA32instructor-format.png" width="60%" height="50%">
</center>

### 寻址方式
寻址，址指的是CPU指令中操作数的地址，寻址就是寻找操作数（包括源操作数和目的操作数）的地址，CPU的寻址方式，就是指CPU指令中支持的给出操作数地址的方式。

简单地说，寻址方式就是如何找到要操作的数据，以及如何找到存放操作结果的地方。

寻址方式，从大方向来看可以分为: 
1. 寄存器寻址
2. 立即数寻址
3. 内存寻址
   1. 直接寻址
   2. 基址寻址
   3. 变址寻址
   4. 基址变址寻址

#### 寄存器寻址
它是指操作数存取在寄存器中，直接从寄存器中存/取数据就行了，因此只要在指令中直接给出寄存器名即可。
```
mov ax, 0x10
add ax, 0x10
add ax, bx
```
上述指令中，ax是目的操作数，0x10 是源操作数，这里的目的操作数就是寄存器寻址

#### 立即数寻址
立即数就是指令中直接给出的常数，指令中的数据就是操作数，不用去寄存器或者内存中寻找操作数。
```
mov ax, 0x10
``` 
这条指令中的源操作数就是立即数寻址

#### 内存寻址
操作数在内存中的寻址方式称为内存寻址。
又有以下几种详细类型：

1. 直接寻址  
直接寻址，就是将直接在操作数中给出的**数字**作为内存地址，通过中括号的形式告诉CPU，取此地址中的值作为操作数。如:
```
mov ax, [0x1234]
mov ax, [fs:0x5678]
xor [es:label_a],0x05
```
**但凡是表示内存地址的，都必须用中括号括起来。**

2. 基址寻址  
基址寻址，就是在操作数的偏移地址由 bx 寄存器或 bp 寄存器给出，地址的变化以它为基础。bx 寄存器的默认段寄存器是DS，而 bp 寄存器的默认段寄存器是SS，即bp和sp都是操作数的有效地址。
总的来说就是操作数的内存地址由`DS:BX` 或者 `SS:BP` 给出。bp 寄存器因为默认段寄存器是SS，所以通常用来访问栈数据。
```
	mov bx,start_addr
lpinc:
	inc word, [bx]
	add bx,2
	loop lpinc

	mov [bx+offset],0x16
```
这种寻址方式的优点就是可以修改 bx/bp 的值来快速改变引用的内存地址。

3. 变址寻址  
变址寻址其实和基址寻址类似，只是寄存器由bx、bp换成了si和di。si是指源索引寄存器(source index)，di是指目的索引寄存器(destination index)。两个寄存器的默认段寄存器都是ds。
```
mov [di]，ax :将寄存器ax的值存入`ds:di`指向的内存 
mov [si+0x1234], ax ;变址中也可以加个偏移量:`ds:si+0x1234`
```

4. 基址变址寻址  
这是基址寻址和变址寻址的结合，即基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di。如:
```
   mov [bx+di], ax 将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存
   add [bx+si], ax 将 ax 与[ds: bx+si]处的值相加后存入内存[ds:bx+si]
```
在8086 处理器上，如果要用寄存器来提供偏移地址，只能使用BX、SI、DI、BP，不能使用其他寄存器。且只允许以下几种基址寄存器和变址寄存器的组合
+ [bx+si]
+ [bx+di]
+ [bp+si]
+ [bp+di]

#### 注释
注释行以英文字母“;”开始。

#### mov 指令
mov 指令用于数据传送。既然是数据传送，那么，目的操作数的作用应该相当于一个“容器”，故必须是**通用寄存器或者内存单元**；源操作数呢，也可以是和目的操作数**具有相同数据宽度的通用寄存器和内存单元，还可以是立即数**。传送指令只影响目的操作数的内容，不改变源操作数的内容。当只给出偏移地址时，默认使用DS的值作为段基址。
可以使用关键字“byte/word”用来修饰目的操作数，指出本次传送是以字节/字的方式进行的：
```
mov byte [0x00],0x15
mov word [0x11],0x1526
```

处理器不允许在两个内存单元之间直接进行传送操作，因此下面指令是不允许的：
```
mov [0x100],[0x300]
```
不单单是mov 指令，其他指令都不支持在两个内存单元之间直接进行操作，包括加、减、乘、除和逻辑运算等指令.

#### movsb 和 movsw
这两个指令通常用于把数据从**内存**中的一个地方批量地传送（复制）到另一个地方，处理器把它们看成是数据串。但是，movsb 的传送是以字节为单位的，而movsw 的传送是以字为单位的。movsb 和movsw 指令执行时，原始数据串的段地址由DS 指定，偏移地址由SI 指定，简写为 `DS:SI`；要传送到的目的地址由 `ES:DI` 指定；传送的字节数（movsb）或者字数（movsw）由CX指定。除此之外，还要指定是正向传送还是反向传送，正向传送是指传送操作的方向是从内存区域的低地址端到高地址端；反向传送则正好相反。正向传送时，每传送一个字节（movsb）或者一个字（movsw），SI 和DI 加1 或者加2；反向传送时，每传送一个字节（movsb）或者一个字（movsw）时，SI和DI 减去1 或者减去2。不管是正向传送还是反向传送，也不管每次传送的是字节还是字，每传送一次，CX 的内容自动减一。

方向指示由EFLAGS寄存器的第10 位方向标志DF（Direction Flag）给出，通过将这一位清零或者置1，就能控制movsb 和movsw 的传送方向。

`cld` 指令将DF 标志清零，以指示传送是正方向的。和 cld 功能相反的是 `std` 指令，它将DF标志置位（1）。此时，传送的方向是从高地址到低地址。

#### cmp指令
比较指令cmp，它需要两个操作数，目的操作数可以是8 位或者16 位通用寄存器，也可以是8 位或者16 位内存单元；源操作数可以是与目的操作数宽度一致的通用寄存器、内存单元或者立即数，但两个操作数同时为内存单元的情况除外。
cmp 指令在功能上和sub 指令相同，唯一不同之处在于，cmp 指令仅仅根据计算的结果设置相应的标志位，而不保留计算结果，因此也就不会改变两个操作数的原有内容。cmp 指令将会影响到CF、OF、SF、ZF、AF 和PF 标志位。

#### 标号
在源程序的编译阶段，编译器会把源程序整体上作为一个个独立的段来处理，并从0 开始计算和跟踪每一条指令的地址。因为该地址是在编译期间计算的，故称为汇编地址 。汇编地址是在源程序编译期间，编译器为每条指令确定的汇编位置（Assembly Position），指示该指令相对于程序或者段起始处的距离，以字节计。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。

在NASM 汇编语言里，每条指令的前面都可以拥有一个标号，以代表和指示该指令的汇编地址。毕竟，由我们自己来计算和跟踪每条指令所在的汇编地址是极其困难的。

标号并不是必需的，只有在我们需要引用某条指令的汇编地址时，才使用标号。

#### 分段（Section/Segment)
NASM 编译器使用汇编指令`SECTION`或者`SEGMENT`来定义段。它的一般格式是
```
SECTION 段名称
SEGMENT 段名称
```
每个段都要求给出名字，这就是段名称，它主要用来引用一个段，可以是任意名字，只要它们彼此之间不会重复和混淆。NASM 编译器不关心段的用途，可能也根本不知道段的用途，不知道它是数据段，还是代码段，或是栈段。事实上，这都不重要，段只用来分隔程序中的不同内容。有时候，程序并不以段定义语句开始。在这种情况下，这些内容默认地自成一个段。最为典型的情况是，整个程序中都没有段定义语句。这时，整个程序自成一个段。

NASM 对段的数量没有限制。一些大的程序，可能拥有不止一个代码段和数据段。

Intel 处理器要求段在内存中的起始物理地址起码是16 字节对齐的。这句话的意思是，必须是16 的倍数，或者说该物理地址必须能被16 整除。

相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求。具体做法是，在段定义中使用“align=”子句，用于指定某个SECTION 的汇编地址对齐方式。比如说，“align=16”就表示段是16 字节对齐的，“align=32”就表示段是32 字节对齐的。

每个段都有一个汇编地址，它是相对于整个程序开头（0）的。为了方便取得该段的汇编地址，NASM 编译器提供了以下的表达式，可以用在你的程序中：
```
section.段名称.start
```

尽管定义了段，但是，引用某个标号时，该标号处的汇编地址依然是从整个程序的开头计算的，而不是从段的开头处计算的。这有时候就会很麻烦。因此，段定义语句还可以包含`vstart=`子句。
当使用 `vstart` 语句时，标号的汇编地址要从它所在段的开头计算，而且从`vstart`指定的地址开始计算。也就是说：
```
label 的汇编地址 = label 到段起始处的偏移地址 + vstart指定值
```

#### NASM 编译器的$和$$标记
NASM 编译器提供了一个标记`$`，该标记等同于标号，你可以把它看成是一个隐藏在当前行行首的标号。
`$$` 是NASM 编译器提供的另一个标记，代表当前汇编节（段）的起始汇编地址。当前程序没有定义节或段，就默认地自成一个汇编段，而且起始的汇编地址是0（程序起始处）。这样，用当前汇编地址减去程序开头的汇编地址（0），就是程序实体的大小。

#### 在程序中声明并初始化数据
程序中的数据是用DB 指令来声明（Declare）的，DB 的意思是声明字节（Declare Byte），所以，跟在它后面的操作数都占一个字节的长度（位置）。注意，如果要声明超过一个以上的数据，各个操作数之间必须以逗号隔开。除此之外，DW（Declare Word）用于声明字数据，DD（DeclareDouble Word）用于声明双字（两个字）数据，DQ（Declare QuadWord）用于声明四字数据。DB、DW、DD 和DQ 并不是处理器指令，它只是编译器提供的汇编指令 ，所以称做伪指令（pseudoInstruction）。伪指令是汇编指令的一种，它没有对应的机器指令，所以它不是机器指令的助记符，仅仅在编译阶段由编译器执行，编译成功后，伪指令就消失了，所以在程序执行时，伪指令是得不到处理器光顾的，实际上，程序执行时，伪指令已不存在。

和指令不同，对于在程序中声明的数值，在编译阶段，编译器会在它们被声明的汇编地址处原样保留。实际上他们是作为数据被载入内存以便使用的。

#### 一些伪指令
1. times
	伪指令times 可用于重复它后面的指令若干次：
	```
	times 20 mov ax,bx
	times 100 db 0
	```
2. equ
   常数是用伪指令 equ 声明的，它的意思是“等于”。如：`app_lba_start equ 100`,和其他伪指令db、dw、dd不同，用equ 声明的数值不占用任何汇编地址，也不在运行时占用任何内存位置。它仅仅代表一个数值，在编译阶段，所有用到的地方会被替换为所代表的常数。

#### jmp 无条件跳转指令
jmp 是转移指令，用于使处理器脱离当前的执行序列，转移到指定的地方执行，关键字near表示目标位置依然在当前代码段内。

处理器取指令、执行指令是依赖于段寄存器CS 和指令指针寄存器IP的，8086 处理器取指令时，把CS 的内容左移4 位，加上IP 的内容，形成20 位的物理地址，取得指令，然后执行，同时把IP 的内容加上当前指令的长度，以指向下一条指令的偏移地址。但是，一旦处理器取到的是转移指令，情况就完全变了。

jmp 指令有多种格式：
1. 相对短转移  
   相对短转移的操作码为0xEB，操作数是相对于目标位置的偏移量，**只能是标号或数值**，仅1 字节，是个有符号数。由于这个原因，该指令属于段内转移指令，而且只允许转移到距离当前指令-128～127 字节的地方。相对短转移指令必须使用关键字“short”
   ```
   jmp short infinate
   ```
   编译器会检查标号infinite 所代表的值，如果数值超过了一字节所能允许的数值范围，则无法通过编译。否则，编译器用目标位置的汇编地址减去当前令的汇编地址，再减去当前指令的长度（2），保留1 字节的结果，作为机器指令的操作数。
   在指令执行时，处理器把指令中的操作数加上2，再加到指令指针寄存器IP 上，这会导致指令的执行流程转向目标地址处。
2. 相对近转移  
   操作码为0xE9，它的操作数是目标位置相对于当前指令处的偏移量，16位。并且以 near 修饰: 
   ```
   jmp near infi
   ```
   在编译阶段，编译器是这么做的：用标号（目标位置）处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（3），就得到了jmp near infi 指令的实际操作数。  
   在指令执行阶段，处理器用指令指针寄存器IP 的内容加上该指令的操作数，再加上该指令的长度（3），就得到了要转移的实际偏移地址，同时CS 寄存器的内容不变。因为改变了IP 的内容，这直接导致处理器的指令执行流程转向目标位置。
3. 16 位间接绝对近转移  
   转移到的目标偏移地址不是在指令中直接给出的，而是用一个16位的通用寄存器或者内存地址来间接给出的:
   ```
   jump_dest dw 0xc000
   jmp near [jump_dest]
   jmp near bx
   jmp near cx
   jmp [bx]
   jmp [bx+si]
   ```
   指令执行时，处理器将用寄存器BX 或者CX 的内容来取代指令指针寄存器IP 的当前内容。
4. 16 位直接绝对远转移  
   操作码是0xEA，0xEA 是操作码，后面是操作数。注意，字的存放是按照低端字节序的。而且，在编译之后，偏移地址在前，段地址在后。执行这条指令后，处理器用指令中给出的段地址代替段寄存器CS 的原有内容，用给出的偏移地址代替IP 寄存器的原有内容，从而跳转到另一个不同的代码段中，即执行一个段间转移。
   ```
	jmp 0x7c00:0x12
   ```
5. 16 位间接绝对远转移（jmp far）  
   远转移的目标地址可以通过访问内存来间接得到，这叫间接远转移，但是要使用关键字“far”。关键字“far”的作用是告诉编译器，该指令应当编译成一个远转移。处理器执行这条指令后，访问段寄存器DS 所指向的数据段，从指令中给出的偏移地址处取出两个字，分别用来替代段寄存器CS 和指令指针寄存器IP 的内容。
   ```
   jump_far dw 0x33c0,0xf000
   jmp far [jump_far]
   jmp far [bx]
   jmp far [bx+si]
   ```

#### 条件跳转指令
jmp指令是无条件的跳转指令，但是我们很多时候需要在满足一定条件的时候才跳转到特定指令处开始执行。于是，CPU提供了很多条件跳转指令。

1. js/jns: 当标志寄存器的SF位为1/0时执行跳转。
2. jz/jnz: 当标志寄存器的ZF为1/0时执行跳转。
3. jo/jno: 当标志寄存器的OF为1/0时执行跳转。
4. jc/jnc: 当标志寄存器的CF为1/0时执行跳转。
5. jp/jnp: 当标志寄存器的PF为1/0时执行跳转。
6. jcxz（jump if CX is zero）：当 cx 为 0 时执行跳转。

#### 栈指令
处理器在设计的时候就规定，当遇到修改段寄存器SS 的指令时，在这条指令和下一条指令执行完毕期间，禁止中断，以此来保护栈。换句话说，你应该在修改段寄存器SS 的指令之后，紧跟着一条修改栈指针SP 的指令。

#### 过程调用
过 程（Procedure ）又叫例程，或者子程序、子过程、子例程（Sub-routine），不管怎么称呼，实质都一样，都是一段普通的代码。处理器可以用过程调用指令转移到这段代码执行，在遇到过程返回指令时重新返回到调用处的下一条指令接着执行。
<center>
<img src="pics/call.jpg" width="30%">
</center>

要调用过程，需要该过程的地址。一般来说，过程的第一条指令需要一个标号，以方便引用该过程。编写过程的好处是只用编写一次，以后只需要“调用”即可。所以，代码的灵活性和通用性尤其重要。具体到这里，就是每次读硬盘时的起始逻辑扇区号和数据保存位置都不相同，这就涉及所谓的参数传递。参数传递最简单的办法是通过寄存器，但是大部分高级编程语言都是用的栈传递。

调用过程的指令是“call”。8086 处理器支持四种调用方式。
1. 第一种是16位相对近调用
   近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，所以只需要得到偏移地址即可。
   16 位相对近调用是三字节指令，操作码为0xE8，后跟16 位的操作数（可以是标号或者一个立即数），因为是相对调用，故该操作数是当前call 指令相对于目标过程的偏移量。计算过程如下：用目标过程的汇编地址减去当前call 指令的汇编地址，再减去当前call 指令以字节为单位的长度（3），保留16 位的结果。
   ```
   call near proc
   call proc ;near 可省略
   ```
   在指令执行阶段，处理器看到操作码0xE8，就知道它应当调用一个过程。于是，它用指令指针寄存器IP 的当前内容加上指令中的操作数，再加上3，得到一个新的偏移地址。接着，将IP 的原有内容压入栈。最后，用刚才计算出的偏移地址取代IP 原有的内容。这直接导致处理器的执行流转移到目标位置处。
2. 第二种是16位间接绝对近调用
   这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址。不过，这个偏移地址不是直接出现在指令中，而是由16 位的通用寄存器或者16 位的内存单元间接给出。
   16位间接绝对近调用的指令的操作码是 0xFF 。
   ```
   call cx           ；目标地址在 cx 中，省略了 near ，下同
   call [0x3c00]     ；目标地址在内存 DS:0x3c00 处
   call [bx]         ；目标地址在内存 DS:BX 处
   call [bs+si+0x02] ；目标地址在内存 DS:bs+si+0x02 处
   ```
   间接绝对近调用指令在执行时，处理器首先按以上的方法计算被调用过程的偏移地址，然后将指令指针寄存器IP 的当前值压栈，最后用计算出来的偏移地址取代寄存器IP 原有的内容。并直接取代指令指针寄存器IP 原有的内容。
3. 第三种是16位直接绝对远调用
   这种调用属于段间调用，即调用另一个代码段内的过程，所以称为远调用（far call）。很容易想到，远调用既需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。
   ```
   call 0x2000:0x0030
   ```
   这种指令对应的操作码是0x9A，处理器在执行时，首先将代码段寄存器CS 的当前内容压栈，接着再把指令指针寄存器IP 的当前内容压栈。紧接着，用指令中给出的段地址代替CS 原有的内容，用指令中给出的偏移地址代替IP 原有的内容。这直接导致处理器从新的位置开始执行。
4. 第四种是16 位间接绝对远调用
   这也属于段间调用，被调用过程位于另一个代码段内，而且，被调用过程所在的段地址和偏移地址是间接给出的。间接远调用必须使用关键字“far”，这一点务必牢记。
   ```
   call far [0x2000]
   call far [prc]
   call far [bx]
   call far [bx+si]
   ```
   以上面第二条指令为例，处理器访问由段寄存器DS 指向的数据段，从指令中指定的偏移地址（由标号proc提供）处取得两个字（假设分别是段地址0x2000 和偏移地址0x0102）；接着，将代码段寄存器CS 和指令指针寄存器IP 的当前内容分别压栈；最后，用刚才取得的段地址和偏移地址分别取代CS 和IP 的原值。

过程执行完还得返回到调用点继续执行下一条指令，这称为过程返回（ProcedureReturn）。用 `ret` 和 `retf` 来完成。
ret 和 retf 经常用做 call 和 call far 的配对指令。ret 是近返回指令，当它执行时，处理器只做一件事，那就是**从栈中弹出一个字到指令指针寄存器IP 中**（注意IP其实是下一条指令的地址，所以过程调用前入栈的IP就是指向call指令下面一条指令的，所以直接出栈到IP）。
retf 是远返回指令（return far），它的工作稍微复杂一点点。当它执行时，处理器分别从栈中弹出两个字到指令指针寄存器IP 和代码段寄存器CS 中。

需要说明的是，尽管call 指令通常需要ret/retf 和它配对，遥相呼应，但ret/retf 指令却并不依赖于call 指令。

#### loop循环指令
loop 指令的功能是重复执行一段相同的代码，处理器在执行它的时候会顺序做两件事：
1. 将寄存器cx 的值减1
2. 如果cx的值不为0，转移到特定的位置处开始执行，否则顺序执行后面的指令。

它的机器指令操作码是0xE2，后面跟着一个字节的操作数，而且也是相对于标号处的偏移量，是在编译阶段，编译器用标号digit 所在位置的汇编地址减去loop 指令的汇编地址，再减去loop 指令的长度（2）来得到的。

```
loop digit
```

#### 速记指令
1. xor：异或指令，指令的目的操作数可以是通用寄存器和内存单元，源操作数可以是通用寄存器、内存单元和立即数（不允许两个操作数同时为内存单元）。而且，异或操作是在两个操作数相对应的比特之间单独进行的。
2. inc：加一指令，操作数可以是8位或者16 位的寄存器，也可以是字节或者字内存单元。


## Bochs 调试
制作虚拟硬盘：
```
bximage -func=create -q -hd=10 -imgmode=flat ./target/hd60M.img
dd if=./target\mbr.bin of=./target/hd60M.img bs=512 conv=notrunc
```

### Bochs调试命令
1. 调试控制：
    1. help
	2. q|quit|exit：退出调试
	3. set
	4. instrument
	5. show
	6. trace
	7. trace-reg
	8. trace-mem
	9. u|disasm
	10. ldsym
	11. slist
   
2. 执行控制：
    1. c|cont|continue: 继续执行到下一个断点处 
	12. s|step：单步执行（step into），遇到循环/函数调用时，进去单步
	13. p|n|next：单步执行（step over），遇到循环/函数调用时，整体单步，不会进去单步执行
	14. modebp
	15. vmexitbp

3. 断点管理：
    1. vb|vbreak
    2. lb|lbreak
    3. pb|pbreak|b|break
    4. sb
    5. sba
    6. blist,
    bpe, bpd, d|del|delete, watch, unwatch

4. CPU及内存查看：
    1. x
    2. xp：显示指定物理内存地址，处的内容。xp 命令每次只显示一个双字。要显示多个双字，需要用“/”附加一个数量。然后，还应当指定一个物理内存地址。
    3. setpmem
    4. writemem
    5. crc
    6. info
    7. r|reg|regs|registers：查看通用寄存器的值 
    8. fp|fpu, 
    9. mmx, 
    10. sse, 
    11. sreg：查看段寄存器的值
    12. dreg, 
    13. creg,
    14. page, 
    15. set, 
    16. ptime, 
    17. print-stack:查看栈信息，它可以带一个参数，用于指定显示多少数据。如果不使用参数，则默认显示当前栈中从栈顶到栈底开始的16 个字。 
    18. ?|calc
    