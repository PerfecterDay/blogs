#  系统调用与API
{docsify-updated}

- [系统调用与API](#系统调用与api)
	- [系统调用介绍](#系统调用介绍)
	- [运行库](#运行库)
	- [系统调用原理](#系统调用原理)
		- [堆栈切换](#堆栈切换)
		- [参数传递](#参数传递)
	- [API 与 ABI](#api-与-abi)

<center><img src="/pics/sys_call.jpg" width="30%"></center>

### 系统调用介绍
在现代的操作系统里，程序运行的时候，本身是没有权利访问多少系统资源的。由于系统有限的资源有可能被多个不同的应用程序同时访问，因此，如果不加以保护，那么各个应用程序难免产生冲突。所以现代操作系统都将可能产生冲突的系统资源给保护起来，阻止应用程序直接访问。这些系统资源包括文件、网络、IO、各种设备等。举个例子，无论在Windows下还是Linux下，程序员都没有机会擅自去访问硬盘的某扇区上面的数据，而必须通过文件系统；也不能擅自修改任意文件，所有的这些操作都必须经由操作系统所规定的方式来进行，比如我们使用fopen去打开一个没有权限的文件就会发生失败。

系统调用的弊端：
1. 使用不便。操作系统提供的系统调用接口往往过于原始，程序员须要了解很多与操作系统相关的细节。如果没有进行很好的包装，使用起来不方便。
2. 各个操作系统之间系统调用不兼容。首先Windows系统和Linux系统之间的系统调用就基本上完全不同，虽然它们的内容很多都一样，但是定义和实现大不一样。即使是同系列的操作系统的系统调用都不一样，比如Linux和UNIX就不相同。

在探究系统调用时会反复涉及原子操作的概念。所有系统调用都是以原子操作方式执行的。之所以这么说，是指内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以 执行，其间不会为其他进程或线程所中断。

### 运行库
为了解决系统调用的弊端，“解决计算机的问题可以通过增加层来实现”，于是运行库挺身而出，它作为系统调用与程序之间的一个抽象层可以保持着这样的特点：
1. 使用简便。因为运行库本身就是语言级别的，它一般都设计相对比较友好。
2. 形式统一。运行库有它的标准，叫做标准库，凡是所有遵循这个标准的运行库理论上都是相互兼容的，不会随着操作系统或编译器的变化而变化。

C语言里的fread，用于读取文件，在Windows下这个函数的实现可能是调用ReadFile这个API，而如果在Linux下，则很可能调用了read这个系统调用。但不管在哪个平台，我们都可以使用C语言运行库的fread来读文件。运行时库将不同的操作系统的系统调用包装为统一固定的接口，使得同样的代码，在不同的操作系统下都可以直接编译，并产生一致的效果。这就是源代码级上的可移植性。

但是运行库也有运行库的缺陷，比如C语言的运行库为了保证多个平台之间能够相互通用，于是它只能取各个平台之间功能的交集。比如Windows和Linux都支持文件读写，那么运行库就可以有文件读写的功能；但是Windows原生支持图形和用户交互系统，而Linux却不是原生支持的（通过XWindows），那么CRT就只能把这部分功能省去。因此，一旦程序用到了那些CRT之外的接口，程序就很难保持各个平台之间的兼容性了。

### 系统调用原理
1. 应用程序通过调用 C 语言函数库中的外壳(wrapper)函数，来发起系统调用。
2. 对系统调用中断处理例程(稍后介绍)来说，外壳函数必须保证所有的系统调用参数可用。通过堆栈，这些参数传入外壳函数，但内核却希望将这些参数置入特定寄存器。因此，外壳函数会将上述参数复制到寄存器。
3. 由于所有系统调用进入内核的方式相同，内核需要设法区分每个系统调用。为此，外壳函 数会将系统调用编号复制到一个特殊的 CPU 寄存器(%eax)中。
4. 外壳函数执行一条中断机器指令(`int 0x80`)，引发处理器从用户态切换到核心态，并执行 系统中断 0x80 (十进制数 128)的中断矢量所指向的代码。较新的 x86-32 硬件平台实现了 `sysenter` 指令，较之传统的 `int 0x80` 中断指令， `sysenter` 指令进入内核的速度更快。2.6 内核及 glibc 2.3.2 以后的版本都支持 `sysenter` 指令。
5. 为响应中断 0x80，内核会调用 system_call()例程(位于汇编文件 arch/i386/entry.S 中)来 处理这次中断，具体如下。
	1. 在内核栈中保存寄存器值(参见 6.5 节)。
	2. 审核系统调用编号的有效性。
	3. 以系统调用编号对存放所有调用服务例程的列表(内核变量 sys_call_table)进行索引， 发现并调用相应的系统调用服务例程。若系统调用服务例程带有参数，那么将首先检 查参数的有效性。例如，会检查地址指向用户空间的内存位置是否有效。随后，该服 务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改，以及 在用户内存和内核内存间传递数据(比如，在 I/O 操作中)。最后，该服务例程会将结 果状态返回给 system_call()例程。
	4. 从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中。
	5. 返回至外壳函数，同时将处理器切换回用户态。
6. 若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno。然后，外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统 调用是否成功。

<center><img src="pics/syscall.png" width="50%"></center>

即便对 于一个简单的系统调用，仍要完成相当多的工作，因此系统调用的开销虽小，却也不容忽视。  
可以以 getppid()系统调用为例，研判一下发起系统调用的开销— 该系统调用只是简 单地返回调用进程的父进程 ID。在作者的一台运行 Linux 2.6.25 的 x86-32 系统上，调用 getppid()一千万次大约需要 2.2 秒钟，每次调用大致需要 0.3 微秒。相形之下，在同一系统 上，调用某个只返回整数的 C 语言函数一千万次，仅需 0.11 微秒，约为调用 `getppid()`耗费时 间的 1/20。当然，大多数系统调用的开销都明显高于 getppid()。

现代的CPU常常可以在多种截然不同的特权级别下执行指令，在现代操作系统中，通常也据此有两种特权级别，分别为用户模式（UserMode）和内核模式（Kernel Mode），也被称为用户态和内核态。由于有多种特权模式的存在，操作系统就可以让不同的代码运行在不同的模式上，以限制它们的权力，提高稳定性和安全性。普通应用程序运行在用户态的模式下，诸多操作将受到限制，这些操作包括访问硬件设备、开关中断、改变特权模式等。

系统调用是运行在内核态的，而应用程序基本都是运行在用户态的。用户态的程序如何运行内核态的代码呢？操作系统一般是通过中断（Interrupt）来从用户态切换到内核态。更多关于中断的细节请参考 [中断](/os/中断.md)

由于中断号是很有限的，操作系统不会舍得用一个中断号来对应一个系统调用，而更倾向于用一个或少数几个中断号来对应所有的系统调用。例如，i386下Windows里绝大多数系统调用都是由int 0x2e来触发的，而Linux则使用int 0x80来触发所有的系统调用。对于同一个中断号，操作系统如何知道是哪一个系统调用要被调用呢？和中断一样，系统调用都有一个系统调用号，就像身份标识一样来表明是哪一个系统调用，这个系统调用号通常就是系统调用在系统调用表中的位置，例如Linux里fork的系统调用号是2。这个系统调用号在执行int指令前会被放置在某个固定的寄存器里，对应的中断代码会取得这个系统调用号，并且调用正确的函数。以Linux的int 0x80为例，系统调用号是由eax来传入的。用户将系统调用号放入eax，然后使用int 0x80调用中断，中断服务程序就可以从eax里取得系统调用号，进而调用对应的函数。

由于基于int指令的系统调用在奔腾4代处理器上性能不佳，Linux在2.5版本起开始支持一种新型的系统调用机制。这种新机制使用Intel在奔腾2代处理器就开始支持的一组专门针对系统调用的指令—— `sysenter` 和 `sysexit` 。

系统调用的一般过程：
1. 触发中断
2. 切换堆栈
3. 执行中断处理程序

#### 堆栈切换
在实际执行中断向量表中的第0x80号元素所对应的函数之前，CPU首先还要进行栈的切换。在Linux中，用户态和内核态使用的是不同的栈，两者各自负责各自的函数调用，互不干扰。但在应用程序调用0x80号中断时，程序的执行流程从用户态切换到内核态，这时程序的当前栈必须也相应地从用户栈切换到内核栈。从中断处理函数中返回时，程序的当前栈还要从内核栈切换回用户栈。

所谓的“当前栈”，指的是ESP的值所在的栈空间。如果ESP的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器SS的值还应该指向当前栈所在的页。所以，将当前栈由用户栈切换为内核栈的实际行为就是：
1. 保存当前的ESP、SS的值。
2. 将ESP、SS的值设置为内核栈的相应值。

反过来，将当前栈由内核栈切换为用户栈的实际行为则是：
1. 恢复原来ESP、SS的值。
2. 用户态的ESP和SS的值保存在哪里呢？答案是内核栈上。这一行为由i386的中断指令自动地由硬件完成。

当0x80号中断发生的时候，CPU除了切入内核态之外，还会自动完成下列几件事：
1. 找到当前进程的内核栈（每一个进程都有自己的内核栈）。
2. 在内核栈中依次压入用户态的寄存器SS、ESP、EFLAGS、CS、EIP。

而当内核从系统调用中返回的时候，须要调用iret指令来回到用户态，iret指令则会从内核栈里弹出寄存器SS、ESP、EFLAGS、CS、EIP的值，使得栈恢复到用户态的状态。

#### 参数传递
用户调用系统调用时，根据系统调用参数数量的不同，依次将参数放入EBX、ECX、EDX、ESI、EDI和EBP这6个寄存器中传递。
<center><img src="/pics/sys-param-pass.jpg" width="30%"></center>


### API 与 ABI
API定义了源代码接口，术语“POSIX（可移植操作系统Portable Operating System Interface 的缩写）”是指在IEEE（电器及电子工程师协会），确切地说是其下属的可移植应用标准委员会（PASC, http://www.pasc.org/）赞助下所开发的一系列标准。PASC 标准的目标是提升应用程序在源码级别的可移植性。

符合 POSIX 标准的操作系统应向程序提供调用各项服务的 API，POSIX 文档对此作了规范。凡是提供了上述 API 的操作系统都可被认定为符合 POSIX 标准。 POSIX 基于UNIX 系统调用和 C 语言库函数，但无需与任何特殊实现相关。这意味着任何操作系统都可以实现该接口，而不一定要是 UNIX 操作系统。实际上，在不对底层操作系统大加改动的同时，一些厂商通过添加 API 已经使自己的专有操作系统符合了 POSIX 标准。

而 ABI 定义的则是在特定的架构上两个或者多个软件模块之间的二进制接口。它定义了一个应用如何和自己交互，如何和内核以及库进行交互。 ABI 必须保证二进制代码兼容，保证一段目标代码能够在任何具有同样 ABI 的系统上都正常运作，而不需要重新编译。

ABI 主要关注的问题有调用约定、字节序、寄存器使用、系统调用、链接、库行为和二进制格式。以调用规则为例，它规定了函数如何被调用，参数如何传递，哪些寄存器被保留而哪些会被破坏，以及调用者如何提取返回的结果。

尽管曾经尝试着为特定架构下不同的操作系统（特别是 i386 上的 Umx 操作系统）定义唯一的 ABI ，然而到目前为止还没有取得成效。相反，包括 Linux 在内的操作系统都尝试定义各自独立的 ABI ，这些 ABI 和架构紧密相连。大部分的 ABI 涉及了机器级别的概念，如特定的寄存器或者汇编指令。因此，在 Linux系统中，每一个机器架构都有自己的 ABI 集合，事实上，我们以机器架构的名称呼这些 ABI ，例如 alpha， x86－64。

由LSB 所推广的二进制可移植性与POSIX 所推广的源码可移植性可谓“一时瑜亮”。源码可移植性是指以 C 语言编写的程序可在任何符合 POSIX 规范的系统上编译并运行。而二进制可移植性则要苛刻得多，通常，只要硬件平台不一，便无法实现。二进制可移植性允许我们在某特定平台上将程序一次编译“成型”，然后，便可在任何符合 LSB 标准的 Linux实现上运行该编译好的程序，当然，符合 LSB 标准的 Linux 实现必须运行在相同的硬件平台之上。对于在 Linux 上开发应用程序的独立软件开发商来说，二进制可移植性是其生存的基本前提。 