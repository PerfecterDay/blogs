# 进程管理
{docsify-updated}

> https://pravin-hub-rgb.github.io/BCA/resources/sem2/operating_sys/unit2/index.html

## 进程
+ 进程是一个正在执行的程序，包括程序计数器、寄存器和变量的当前值。 
+ 进程与程序的区别在于，程序是一组指令，而进程是一项活动。 或者我们可以说，进程是程序的一种活动状态。 
+ 我们将计算机程序写入文本文件，当我们执行这个程序时，它就变成了一个进程，执行程序中提到的所有任务。 
+ 当程序加载到内存中并变成一个进程时，它可以分为四个部分：堆栈、堆、文本和数据。 
+ 进程一般还包括进程堆栈和数据部分，前者包含临时数据（如函数参数、返回地址和局部变量），后者包含全局变量。

## PCB
操作系统为每个进程创建进程控制块（PCB）存储进程的各个属性，进程控制块是一个进程存在的根本标识。 PCB 存储的部分重要信息如下：

<center><img src="pics/process.svg" width="20%"></center>

+ 进程 ID： 创建进程时，会为进程分配一个唯一 ID，用于在系统中唯一标识进程。 
+ 程序计数器： 程序计数器存储了进程的最后一条指令的地址，在该指令上进程被暂停。 CPU 在恢复执行该进程时会使用该地址。 
+ 进程状态： 进程从创建到完成会经历各种状态，包括新建、就绪、运行和等待。 
+ 优先级： 每个进程都有自己的优先级。 在所有进程中，优先级最高的进程会优先使用 CPU。 这也存储在进程控制块中。 
+ 通用寄存器值： 当操作系统切换进程时，每个进程都会记录下当前使用CPU通用寄存器中的值，用于保存进程执行过程中产生的数据，当再次切换执行时，恢复寄存器值继续执行。
+ 打开文件列表： 在执行过程中，每个进程都会使用一些需要存在于主存储器中的文件。 操作系统还会维护 PCB 中的打开文件列表。 
+ 打开设备列表： 操作系统还维护进程执行过程中使用的所有打开设备的列表。


## 进程状态
<center><img src="pics/process2.svg" width="40%"></center>

## 进程队列
+ 操作系统为每种进程状态管理各种类型的队列。
+ 与进程相关的 PCB 也存储在同一状态的队列中。
+ 如果进程从一个状态转移到另一个状态，那么它的 PCB 也会从相应的队列中解除链接，并添加到进行转换的另一个状态队列中。

<center><img src="pics/manage2.svg" width="60%"></center>

1. 作业队列  
    + 在启动过程中，所有进程都会被存储在作业队列中。 
    + 作业队列保存在二级内存中。
    + 长期调度程序（作业调度程序）会挑选部分进程并将其放入一级内存中。 

2. 就绪队列  
    + 就绪队列保存在一级内存中
    + 短期调度程序会从就绪队列中挑选作业并调度 CPU 执行。

3. 等待队列  
    + 当进程需要执行一些 IO 操作才能完成其执行时，操作系统会将进程的状态从运行状态改为等待状态。 
    + 与进程相关的上下文（PCB）会存储在等待队列中，当进程完成 IO 操作时，处理器将继续调度该上 PCB 进程。
    + 操作系统会将等待的队列与之在等待的对象（事件）关联起来，这样一旦等待的对象完成某一操作（事件完成），就能通知等待该事件的进程。


## 与进程有关的各种时间
<center><img src="pics/process3.svg" width="70%"></center>

1. 到达时间:进程进入就绪队列的时间 
2. Burst Time  
   + The total amount of time required by the CPU to execute the whole process is called the Burst Time.
   + This does not include the waiting time.
   + It is confusing to calculate the execution time for a process even before executing it hence the scheduling problems based on the burst time cannot be implemented in reality.
3. 完成时间:进程进入完成状态的时间或进程完成其执行的时间。 
4. 周转时间:进程从到达到完成所花费的总时间。 
5. 等待时间:进程等待分配 CPU 的总时间。 
6. 响应时间:进程到达时间与首次获得 CPU 时间之差。

## CPU 调度
在 MS DOS 等单任务系统中，当进程等待 I/O 操作完成时，CPU 仍处于空闲状态。单任务系统是一种一次只能执行一个程序的操作系统。这是一种开销，因为它既浪费时间，又会造成饥饿问题。"开销 "指的是系统在执行用户程序所需的任务之外所需的额外资源。 开销包括管理和运行操作系统本身所需的时间、内存、处理能力或其他系统资源。

然而，在多程序系统中，CPU 不会在进程等待期间一直闲置，而是会开始执行其他进程。 操作系统必须确定将哪个进程分配给 CPU。 在多程序系统中，操作系统会对 CPU 上的进程进行调度，以最大限度地利用 CPU，这一过程称为 CPU 调度。 操作系统使用各种调度算法来调度进程。 短期调度器的任务是根据就绪队列中的进程数量来调度 CPU。 每当运行中的进程请求进行某些 I/O 操作时，短期调度器就会保存进程的当前上下文（也称为 PCB），并将其状态从运行状态改为等待状态。 在进程处于等待状态期间，短期调度程序会从就绪队列中选择另一个进程，并将 CPU 分配给该进程。 这一过程称为上下文切换。

<center><img src="pics/contextswitching.svg" width="60%"></center>
