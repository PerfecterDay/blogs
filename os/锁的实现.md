## 锁的实现
{docsify-updated}

- [锁的实现](#锁的实现)
	- [以中断启用与禁止来实现锁](#以中断启用与禁止来实现锁)
	- [以测试与设置指令来实现锁](#以测试与设置指令来实现锁)
	- [以非繁忙等待/中断启用与禁止来实现锁](#以非繁忙等待中断启用与禁止来实现锁)
	- [以最少繁忙等待/测试与设置来实现锁](#以最少繁忙等待测试与设置来实现锁)
	- [总结与对比](#总结与对比)


自然，如果没有硬件提供原子操作，只在软件层上是不可能设计出原子操作的。就像没有地基，就无法建造高楼一样。操作系统之所以能够构建锁之类的同步原语，原因就是硬件已经为我们提供了一些原子操作：中断禁止和启用（inter-rupt enable/disable）、内存加载和存入（load/store）和测试与设置（test＆set）指令。禁止中断这个操作是一个硬件步骤，中间无法插入别的操作。同样，中断启用、内存加载、内存存入、测试与设置均为一个硬件步骤的指令。在这些硬件原子操作之上，我们便可以构建软件原子操作：锁、睡觉与叫醒、信号量等。

### 以中断启用与禁止来实现锁
要防止一段代码在执行过程中被其他进程插入，我们就要考虑在一个**单处理器上**，一个线程在执行中途被切换是通过什么途径来实现的。到现在我们知道，要切换进程，必须发生上下文切换，而发生上下文切换只能有两种可能：
+ 一是一个线程自愿放弃CPU而将控制权交给操作系统调度器，从而发生上下文切换；
+ 二是一个线程被强制放弃CPU而失去控制权。
自愿放弃通过调用yield之类的操作系统系统调用来实现；而强制放弃则需通过中断来实现，操作系统主要是通过**周期性的时钟中断**来获得CPU控制权的。  
由于原语执行过程中，我们不会自动放弃CPU控制权。因此要防止进程切换，就要在原语执行过程中不能发生中断。由此，我们想到，通过禁止中断，并且不自动调用让出CPU的系统调用（如yield之类），就可以防止进程切换，就能将一组操作变为原子操作。
> 请注意，禁止中断响应的方式在多核理器系统中不会生效，因为关中断只对当前核有效：https://stackoverflow.com/questions/53919482/whats-the-process-of-disabling-interrupt-in-multi-processor-system

接下来的一个问题是，如果禁止中断就能将一组操作变为原子操作，那还要锁干什么？不如直接在程序中进入临界区之前禁止中断，在离开临界区的时候再启用中断。  
这种做法的问题是危险。因为将操作系统赖以工作的基础机制交给用户来控制是十分不明智的。万一用户的水平有限，禁止中断后忘了启用，这个系统就完了。而且，这就等于给黑客一个攻击的入口。所以，用户程序不能进行中断的启用和禁止操作。理论上可以，但实际上不能。因此，合理的做法就是由操作系统提供一个锁给用户使用，而锁的正确性由操作系统保证。
```
lock(){
	disable interrupts ；
	while(value ！= FREE) {  //忙等
		enable interrupts;
		disable interrupts;
	}
	value = BUSY;
	enable interrupts;
}
```
闭锁的第一个操作是禁止中断，记住，这是一个硬件原子操作。如果成功禁止了中断，接下来就检查value是否等于FREE，如果是，就表明这个资源没有被其他进程占用，我们就将其设置为忙，然后启用中断（记住，这也是一个硬件原子操作）。这样就完成了闭锁操作。如果value不是FREE，则我们循环等待这个值变为FREE。但在循环等待的过程中，我们使用了一对操作，分别是启用中断和禁止中断。这是为何呢？这是因为，如果value不是FREE，就说明有别的线程占用了value。我们需要等待占用value的线程使用完value后将其设置为FREE。因为我们禁止了中断，别的线程已经无法获得CPU来执行，自然无法将value设置为FREE。因此，我们加入了启用/禁止中断操作对，寄希望于在启用和禁止中间那个占用value的进程切换进来，完成操作后释放value。如果不这样，那就永远只能等在那里，别人也不会释放锁。

```
unlock(){
	disable interrupts;
	value = FREE;
	enable interrupts;
}
```
将value设置为FREE需要中断禁止的保护吗？当然需要，因为value=FREE这个赋值语句不是原子操作，所以需要禁止中断来保护。否则，值"FREE"可能在传往value的中途被冲掉，造成锁的释放失败。

以中断启用与禁止来实现锁的优点是原理简单，容易理解，也容易实现。但存在的问题也很明显:
1. 频繁地禁止中断有可能造成对重要事件的处理不及时。
2. 其次，在锁的实现中留给其他进程获得CPU的机会也不大，这可能是个很大的问题。因为持有锁的进程可以切换的地方是在启用中断和禁止中断两句原子操作之间。由于是原子操作，因此硬件上只有一个操作，而在这两个原子操作之间恰好插入进来并不是一件概率很大的事情。当然，循环久了，总会有机会插入。但循环多久才发生插入是很难预料的事情。

### 以测试与设置指令来实现锁
测试与设置（test＆set）指令就是一条类似的指令，但略有不同，它以不可分割的方式执行如下两个步骤：
1. 设置操作：将1写入指定内存单元(初始为0)。
2. 读取操作：返回指定内存单元里原来的值（写入新值1之前的内容）。
```
test_and_set(X){
	tmp=X;
	X=1;
	return tmp;
}
```
实现锁：
```
lock(){
	while(test_and_set(value)==1){} //忙等
}

unlock(){
	value = 0;
}
```
test＿and＿set（value）的操作是将1写入变量value里，并将写1之前value的值返回。如果锁是打开的，即value是0的话，该指令将value设置为1，获得锁并退出循环。如果锁是闭上的，即value的值是1，则返回的值为1，循环继续。该指令将value设置为1并不改变value的状态（value本来就是1）。该循环将一直持续到成功获得锁为止。

开锁的操作很简单，将value设置为0即可。上面的value=0的赋值语句怎么不需要保护呢？难道不怕别人插在中间造成问题？  
答案是否定的。因为调用unlock的进程一定是已经获得锁的进程。别的进程由于没有锁，无法对value进行操作。当然了，这里我们要求所有的进程在调用unlock之前必须先调用lock，否则我们的这种保障就不能实现。

测试与设置强于中断启用和禁止。不过，需要指出的是，这种区别是很小的，因为中断禁止所禁止的并不是中断的发出，而是对中断的响应。由于中断一旦发出，就一直处于发出状态，此时只要中断被启用，将马上得到响应。因此，使用中断启用与禁止所留下的空当绰绰有余。

### 以非繁忙等待/中断启用与禁止来实现锁
前面介绍的两种锁的实现方式看上去简单，也很容易理解，但都有一个问题。这个问题就是繁忙等待。本书前面章节多次说过，繁忙等待浪费资源，并且有可能造成优先级倒挂和死锁。因此，我们自然想到对前面介绍的两种方法进行改善。改善的思路是不进行繁忙等待，而是在拿不到锁的时候去睡觉，等待别人的叫醒。这样，锁的实现思路如下：
1. 使用中断禁止，但不进行繁忙等待。
2. 如果拿不到锁，等待进程放弃CPU并进入睡觉状态，以便持有锁的进程可以更好地运行。等待线程在调用切换操作时将中断留在禁止状态。
3. 下一个执行的线程负责在返回到用户代码前启用中断。
4. 当锁释放的时候将睡觉进程叫醒。当唤醒一个等待线程时，中断仍然处于（又设置成）禁止状态。

```
lock(){
	disable interrupts;
	if(value==FREE){
		value = BUSY;
	}else{
		add thread to queue of threads waiting for this lock;
		switch to next runable thread;
	}
	enable interrupts; //由于已经切换了线程，所以开中断语句无法执行
}
```

### 以最少繁忙等待/测试与设置来实现锁
```
lock(){
	while(test_and_set(guard)==1){} //忙等
	if(value==FREE){
		value = BUSY;
		guard = 0;
	}else{
		add thread to queue Of threads waiting for this lock;
		guard = 0;
		switch to next runable thread;
	}
}
```
首先来看着这个实现是否正确。如果guard的值为1，则这个lock操作将不停地循环等待。直到guard变为0为止。这个时候，检查锁的值（value）。如果是FREE，将其设置为忙碌（BUSY），将guard设置为0，获得锁而退出lock**系统调用**，然后去执行用户临界区的代码。  
如果value的值等于繁忙，先将guard设置为0，再将自己加到等待队列上，然后切换到别的线程。在这种情况下，则存在另一个线程持有value这把锁。线程在做完自己的事情后，将调用unlock来释放锁。而unlock首先测试guard，如果没有人持有，该线程将value设置为FREE，然后检查是否有线程在锁上等待。在我们这种情况下有。这时它就将等待线程移动到就绪队列，然后将锁交给被叫醒的线程（value=1），然后将guard设置为0。

因此，上面锁的实现是正确的。那另一个问题是，与上一节锁的实现方式相比，为什么繁忙等待大大缩短了？这是因为我将等待对象从value改成了guard，而guard所保护的范围远远小于value要保护的临界区。因为
guard要防止的只是不要同时拿锁而已，一旦拿锁的动作完成（不管是否拿到锁），guard都将被设置为0。而这个范围很小，在拿到锁的情况下，guard保护的只有if（value==FREE）的条件判断和value=BUSY的赋值语句。在没有拿到锁的情况下，guard保护的语句只有将自己加到等待队列的一段代码。

拿到锁后的临界区操作并不由guard保护。不管临界区有多大，guard维持繁忙的时间不会受到丝毫影响。因此，一个进程在guard上的循环等待时间都几乎是恒定的，并且很短，只有几句语句，所以大大缩短了繁忙等待时间。

这种实现策略的根本思想就是循环等待不是等在lock，而是等在guard上。从而将临界区的工作时间从需要等待的时间中消除了，进而在实现锁的同时大大降低了繁忙等待时间。当然，如果同时出现3个以上线程同时竞争guard的情况，则有1个线程等待时间要长一些。但第3者多等也是应该的。而且就算是第3者，也不会等待很久时间。因为第1个释放guard之后，第2个得到guard，然后获得lock以后也释放了guard，所以第3者也不会等很久。你等多久，不就等几句语句的运行时间吗？所以这个等待时间可以忽略不计。

不过细心的读者可能发现图10-10的实现中存在一个问题。就是和使用中断禁止与启用时有一样的问题。假如在将自己放在等待队列后突然发生线程切换，那么本线程也将同时处于等待和就绪两个队列。这个问题是怎么解决的呢？解决办法也很简单，就是将执行lock这个系统调用的进程的优先权提高，以使这种情况发生的概率降低。当然，完全避免是不可能的。这也就是为什么操作系统在运行中偶尔会出问题，如死锁。

```
unlock(){
	while(test_and_set(guard)==1){}
	va1ue=FREE;
	if(any thread is waiting for this lock){
		move waiting thread from waiting queue to ready queue;
		va1ue=BUSY;
	}
	guard=0;
}
```

### 总结与对比
我们讲解了如何使用中断禁止、测试与设置两种硬件原语来实现软件的锁原语。这两种方式比较起来，显然测试与设置更加简单。因此，其使用的范围更加普遍。除此之外，测试与设置方法还有一个优点，那就是可以在多CPU环境下工作，而中断启用和禁止则不能。

在单处理器上，如果禁止了中断，自然别的线程就无法获得CPU控制权。但在多CPU情况下，即使禁止了某个CPU的中断，另一个CPU却可以继续执行，即我们不能保证其他CPU不进行上下文切换。当然，我们可以同时修改几个CPU的中断启用/禁止位来防止其他CPU继续运行。这样禁止所有上下文切换了吗？确实防止了上下文切换，但是却付出了更大的代价。

这是因为，如果我们一条指令把所有CPU的中断都禁止了，则这些CPU之间的独立性将大打折扣。而使用多CPU的目的就算想让它们能够独立执行。  另外，就算我们想这样做，也实现不了。因为硬件不提供一条指令禁止所有中断，而使用多条指令来禁止所有CPU上的中断则不能保证原子性。所以不提倡这种方法。

那么多CPU环境下使用测试与设置怎么能工作呢？这是因为test＆set是针对内存单元的，多CPU有全局内存，所以能够工作。我们在后面介绍旋锁的时候，将再次提到这一点。