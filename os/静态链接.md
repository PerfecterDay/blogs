#  静态链接
{docsify-updated}

- [静态链接](#静态链接)
    - [gcc和g++](#gcc和g)
    - [编译链接的一般过程](#编译链接的一般过程)
    - [链接的接口——符号](#链接的接口符号)
      - [一个很小的程序](#一个很小的程序)
    - [ld 链接器](#ld-链接器)

### gcc和g++
预编译器`cpp`,现在版本的GCC把预编译和编译两个步骤合并成一个步骤，使用一个叫做`cc1`的程序来完成这两个步骤。  
对于C语言的代码来说，这个预编译和编译的程序是`cc1`，对于C++来说，有对应的程序叫做`cc1plus`；Objective-C是`cc1obj`；fortran是`f771`；Java是`jc1`。

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”这个名字也来源于此。上面的汇编过程我们可以调用汇编器 `as` 来完成。

`ld` 链接器将目标文件与相关的库文件链接形成最终的可执行程序文件。

所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序cc1、汇编器as、链接器ld。

+ `-E` 表示只进行预编译：主要处理那些源代码文件中的以“#”开始的预编译指令，输出 .i 文件
+ `-S` 编译:进行词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，输出 .s 文件
+ `-c` ：预编译、编译和汇编直接输出目标文件，输出 .o 文件

### 编译链接的一般过程
编译链接的过程：预处理（Prepressing）-cpp、编译（Compilation）-ccl、汇编（Assembly）-as 和链接（Linking）-ld
<center>
<img src="pics/compile-link-process.png" width=50% >
<img src="pics/linker.png" width=30% >
</center>

以下列程序为例：
<center><img src="pics/link-sample-code.png" width=60% ></center>

### 链接的接口——符号
链接过程的本质就是要把多个不同的目标文件之间相互“粘”到一起，或者说像玩具积木一样，可以拼装形成一个整体。为了使不同目标文件之间能够相互粘合，这些目标文件之间必须有固定的规则才行，就像积木模块必须有凹凸部分才能够拼合。在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。比如目标文件B要用到了目标文件A中的函数“foo”，那么我们就称目标文件A定义（Define）了函数“foo”，称目标文件B引用（Reference）了目标文件A中的函数“foo”。这两个概念也同样适用于变量。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。

链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号：
+ 定义在本目标文件的全局符号，可以被其他目标文件引用。
+ 在本目标文件中引用的全局符号，却没有定义在本目标文件，叫做外部符号(External Symbol)。
+ 段名，通常由编译器产生，符号值就是段的起始地址。如代码段“.text”、数据段“.data”等。
+ 局部符号，由函数内部的局部变量产生，这些局部符号对链接过程没有作用，链接器也往往忽视他们。这也是为什么我们在用IDA反编译时看不到局部变量的名字。
+ 行号信息，通常用于调试。

现在的链接器空间分配的策略基本上都采用上述方法中的第二种，使用这种方法的链接器一般都采用一种叫两步链接（Two-passLinking）的方法。也就是说整个链接过程分两步。
1. 第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
2. 第二步 符号解析与重定位 使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。

那么链接器是怎么知道哪些指令是要被调整的呢？在目标文件中有一个叫做**重定位表**(Relocation Table)的结构专门用来保存与重定位相关的信息。对于每个要被重定位的ELF段都有一个对应的重定位表，例如.text段如有要被重定位的地方，就会有一个相对应的.rel.text的段保存了代码段的重定位表，数据段.data同理。

#### 一个很小的程序
传统的 hello world C程序，需要依赖C运行库的支持(printf函数)，并且默认以main函数做程序入口。以下程序会脱离C运行库而直接调用操作系统的系统调用来实现：

```
char* str = "Hello world\n";

void print(){
    asm(
            "movl $13, %%edx \n\t"
            "movl %0, %%ecx \n\t"
            "movl $0, %%ebx \n\t"
            "movl $4, %%eax \n\t"
            "int $0x80 \n\t"
            ::"r"(str):"edx","ecx","ebx");
}

void exit(){
    asm(
            "movl $42, %ebx \n\t"
            "movl $1, %eax \n\t"
            "int $0x80 \n\t");
}

void nomain(){
    print();
    exit();
}
```
编译链接命令：
```
gcc -c -fno-builtin min.c -m32
ld -static -e nomain -o min min.o -m elf_i386
```

我们可以用以下链接控制脚本将各个节合并到一个节：
```
ENTRY(nomain)
SECTIONS
{
    . = 0x0804800 + SIZEOF_HEADERS;
    tinytext : { * (.text) *(.data) *(.rodata) }
    /DISCARD/ : { *(.coment) }
}
```
编译链接命令：
```
gcc -c -fno-builtin min.c -m32
ld -static -T self-lds.lds -o min min.o -m elf_i386
```

### ld 链接器
ld命令的参数非常丰富，以下是一些常用的参数：

+ `-o <output>`：指定输出文件的名称。
+ `-l <library>`：链接指定的库。
+ `-L <directory>`：指定库文件的搜索路径。
+ `-static`：静态链接库文件。
+ `-shared`：创建共享库。
+ `-e <symbol>`：指定程序的入口点符号。
+ `-rpath <path>`：指定运行时库文件的搜索路径（仅对ELF格式有效）。
+ `--verbose`：显示详细的链接信息。

