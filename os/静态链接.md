#  静态链接
{docsify-updated}

- [静态链接](#静态链接)
  - [gcc和g++](#gcc和g)
  - [编译链接的一般过程](#编译链接的一般过程)
  - [静态链接](#静态链接-1)
    - [静态库](#静态库)
      - [一个很小的程序](#一个很小的程序)
  - [ld 链接器](#ld-链接器)
    - [ld 链接器脚本](#ld-链接器脚本)

## gcc和g++
预编译器`cpp`,现在版本的GCC把预编译和编译两个步骤合并成一个步骤，使用一个叫做`cc1`的程序来完成这两个步骤。  
对于C语言的代码来说，这个预编译和编译的程序是`cc1`，对于C++来说，有对应的程序叫做`cc1plus`；Objective-C是`cc1obj`；fortran是`f771`；Java是`jc1`。

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了，“汇编”这个名字也来源于此。上面的汇编过程我们可以调用汇编器 `as` 来完成。

`ld` 链接器将目标文件与相关的库文件链接形成最终的可执行程序文件。

所以实际上gcc这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序cc1、汇编器as、链接器ld。

+ `-E` 表示只进行预编译：主要处理那些源代码文件中的以“#”开始的预编译指令，输出 .i 文件
+ `-S` 编译:进行词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，输出 .s 文件
+ `-c` ：预编译、编译和汇编直接输出目标文件，输出 .o 文件
+ `-v` : 可以输出编译链接各个过程的详细信息

## 编译链接的一般过程
编译链接的过程：预处理（Prepressing）-cpp、编译（Compilation）-ccl、汇编（Assembly）-as 和链接（Linking）-ld
<center>
<img src="pics/compile-link-process.png" width=50% >
<img src="pics/linker.png" width=30% >
</center>

以下列程序为例：
<center>
<img src="pics/link-sample-code.png" width=50% >
</center>
<center>
<img src="pics/link.png" width=30% >
</center>

## 静态链接
链接过程的本质就是要把多个不同的目标文件之间相互“粘”到一起，或者说像玩具积木一样，可以拼装形成一个整体。为了使不同目标文件之间能够相互粘合，这些目标文件之间必须有固定的规则才行，就像积木模块必须有凹凸部分才能够拼合。在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。比如目标文件B要用到了目标文件A中的函数“foo”，那么我们就称目标文件A定义（Define）了函数“foo”，称目标文件B引用（Reference）了目标文件A中的函数“foo”。这两个概念也同样适用于变量。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们**将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。**

链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号：
+ 定义在本目标文件的全局符号，可以被其他目标文件引用。
+ 在本目标文件中引用的全局符号，却没有定义在本目标文件，叫做外部符号(External Symbol)。
+ 段名，通常由编译器产生，符号值就是段的起始地址。如代码段“.text”、数据段“.data”等。
+ 局部符号，由函数内部的局部变量产生，这些局部符号对链接过程没有作用，链接器也往往忽视他们。这也是为什么我们在用IDA反编译时看不到局部变量的名字。
+ 行号信息，通常用于调试。

现在的链接器空间分配的策略基本上都一种叫两步链接（Two-passLinking）的方法。也就是说整个链接过程分两步。
1. 第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
2. 第二步 符号解析与重定位 使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。

那么链接器是怎么知道哪些指令是要被调整的呢？在目标文件中有一个叫做**重定位表**(Relocation Table)的结构专门用来保存与重定位相关的信息。对于每个要被重定位的ELF段都有一个对应的重定位表，例如.text段如有要被重定位的地方，就会有一个相对应的.rel.text的段保存了代码段的重定位表，数据段.data同理。

### 静态库
让我们还是先回到一个比较初步的问题，就是程序如何使用操作系统提供的API？

在一般的情况下，一种语言的开发环境往往会附带有**语言库**（Language Library）。这些库就是对操作系统的API的包装，比如我们经典的C语言版“Hello World”程序，它使用C语言标准库的“printf”函数来输出一个字符串，“printf”函数对字符串进行一些必要的处理以后，最后会调用操作系统提供的API。各个操作系统下，往终端输出字符串的API都不一样，在Linux下，它是一个“write”的系统调用，而在Windows下它是“WriteConsole”系统API库里面还带有那些很常用的函数，比如C语言标准库里面有很常用一个函数取得一个字符串的长度叫 strlen()， 该函数即遍历整个字符串后返回字符串长度，这个函数并没有调用任何操作系统的API，也没有做任何输入输出。但是很大一部分库函数都是要调用操作系统的API。

其实一个静态库可以简单地**看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件**。比如我们在Linux中最常用的C语言静态库libc位于 `/usr/lib/libc.a` ，它属于glibc项目的一部分；像Windows这样的平台上，最常使用的C语言库是由集成开发环境所附带的运行库，这些库一般由编译器厂商提供，比如Visual C++附带了多个版本的C/C++运行库。

在一个C语言的运行库中，包含了很多跟系统功能相关的代码，比如输入输出、文件操作、时间日期、内存管理等。glibc本身是用C语言开发的，它由成百上千个C语言源代码文件组成，也就是说，编译完成以后有相同数量的目标文件，比如输入输出有`printf.o，scanf.o`；文件操作有`fread.o，fwrite.o`；时间日期有`date.o，time.o`；内存管理有malloc.o等。把这些零散的目标文件直接提供给库的使用者，很大程度上会造成文件传输、管理和组织方面的不便，于是通常人们使用“ar”压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了libc.a这个静态库文件。

使用 `ar`（windows 下有lib.exe） 工具可以查看库中的目标文件：

```shell
ar -t libc.a
```

#### 一个很小的程序
传统的 hello world C程序，需要依赖C运行库的支持(printf函数)，并且默认以main函数做程序入口。以下程序会脱离C运行库而直接调用操作系统的系统调用来实现：

```
char* str = "Hello world\n";

void print(){
    asm(
            "movl $13, %%edx \n\t"
            "movl %0, %%ecx \n\t"
            "movl $0, %%ebx \n\t"
            "movl $4, %%eax \n\t"
            "int $0x80 \n\t"
            ::"r"(str):"edx","ecx","ebx");
}

void exit(){
    asm(
            "movl $42, %ebx \n\t"
            "movl $1, %eax \n\t"
            "int $0x80 \n\t");
}

void nomain(){
    print();
    exit();
}
```
编译链接命令：
```
gcc -c -fno-builtin min.c -m32
ld -static -e nomain -o min min.o -m elf_i386
```
+ `-fno-builtin` GCC编译器提供了很多内置函数(Built-in Function)，它会把一些常用的C库函数替换成编译器的内置函数，以达到优化的功 能。比如GCC会将只有字符串参数的printf函数替换成puts，以节省格 式解析的时间。exit()函数也是GCC的内置参数之一，所以我们要使 用-fno-builtin参数来关闭GCC内置函数功能。
+ `-m32` 选项用于指定生成32位代码或目标文件
+ `gcc -static`： 使用静态链接
+ `gcc --verbose`: 输出详细编译链接过程

我们可以用以下链接控制脚本将各个节合并到一个节：
```
ENTRY(nomain)
SECTIONS
{
    . = 0x0804800 + SIZEOF_HEADERS;
    tinytext : { * (.text) *(.data) *(.rodata) }
    /DISCARD/ : { *(.coment) }
}
```
编译链接命令：
```
gcc -c -fno-builtin min.c -m32
ld -static -T self-lds.lds -o min min.o -m elf_i386
```

## ld 链接器
链接器一般都提供多种控制整个链接过程的方法，以用来产生用户所须要的文件。一般链接器有如下三种方法：
1. 使用命令行来给链接器指定参数，我们前面所使用的ld的-o、-e参数就属于这类。这种方法我们已经在前面使用很多次了。
2. 将链接指令存放在目标文件里面，编译器经常会通过这种方法向链接器传递指令。方法也比较常见，只是我们平时很少关注，比如VISUAL C++编译器会把链接参数放在PE目标文件的.drectve段以用来传递参数。具体可以参考PE/COFF一节中的.drectve段介绍。
3. 使用链接控制脚本，也是最为灵活、最为强大的链接控制方法。

ld命令的参数非常丰富，以下是一些常用的参数：
+ `-T <ldsfile>`: 使用指定的链接控制脚本。
+ `-o <output>`：指定输出文件的名称。
+ `-m <EMULATION>`: 指定目标文件的架构类型。
+ `-l <library>`：链接指定的库。
+ `-L <directory>`：指定库文件的搜索路径。
+ `-static`：Do not link against shared libraries，使用静态链接的方式来链接程序，而不是使用默认的动态链接的方式。
+ `-shared`：创建共享库。
+ `-e <symbol>`：指定程序的入口点符号。
+ `-rpath <path>`：指定运行时库文件的搜索路径（仅对ELF格式有效）。
+ `--verbose`：显示详细的链接脚本信息。
+ 查看 ld 链接器查找链接库路径：`ld --verbose | grep SEARCH_DIR | tr -s ' ;' \\012`
+ 查看 gcc 查找路径: `gcc -print-search-dirs | sed '/^lib/b 1;d;:1;s,/[^/.][^/]*/\.\./,/,;t 1;s,:[^=]*=,:;,;s,;,;  ,g' | tr \; \\012`

### ld 链接器脚本 
无论是输出文件还是输入文件，它们的主要的数据就是文件中的各种段，我们把输入文件中的段称为**输入段**（Input Sections），输出文件中的段称为**输出段**（Output Sections）。简单来讲，控制链接过程无非是控制输入段如何变成输出段，比如哪些输入段要合并一个输段，哪些输入段要丢弃；指定输出段的名字、装载地址、属性，等等。

ld链接器的链接脚本语法继承与AT&T链接器命令语言的语法，风格有点像C语言，它本身并不复杂。链接脚本由一系列语句组成，语句分两种：
+ 一种是命令语句
+ 另外一种是赋值语句。
  
前面的链接脚本里面的 `ENTRY(nomain)` 就是命令语句，而 `. = 0x08480000 + SIZEOF_HEADERS` 则是一个经典的赋值语句。

一些常用的命令语句如下：
<center><img src="pics/ld-commands.png" width="40%"></center>

除了这些简单的命令语句之外，剩下最重要、也是最复杂的就是SECTIONS命令了。SECTIONS 命令语句最基本格式为：
```C
SECTIONS 
{
    ... 
    secname : { contents } 
    ... 
}
```

`secname` 表示输出段的段名， `secname` 后面必须有一个空格符，这样使得输出段名不会有歧义，后面紧跟着冒号和一对大括号。大括号里面的 `contents` 描述了一套规则和条件，它表示符合这种条件的输入段将合并到这个输出段中。输出段名的命名方法必须符合输出文件格式的要求，比如，如果使用ld生产一个 `a.out` 格式的文件，那么输出段名就不可以使用除 `.text` 、`.data` 和 `.bss` 之外的任何名字，因为a.out格式规定段名只允许这三个名字。

有一个特殊的段名叫“/DISCARD/”，如果使用这个名字作为输出段名，那么所有符合后面contents所规定的条件的段都将被丢弃，不输出到输出文件中。

contents中可以包含若干个条件，每个条件之间以空格隔开，如果输入段符合这些条件中的任意一个即表示这个输入段符合contents规则。条件的写法如下：
```
filename(sections)
```
`filename` 表示输入文件名， `sections` 表示输入段名。让我们举几个条件的例子来看看：
+ `file1.o(.data)` 表示输入文件中名为`file1.o`的文件中名叫`.data`的段符合条件。
+ `file1.o(.data .rodata)` 或 `file1.o(.data, .rodata)` 表示输入文件中名为 `file1.o` 的文件中的名叫`.data`或`.rodata`的段符合条件。
+ `*(.data)` 所有输入文件中的名字为.data的文件符合条件。
+ `[a-z]*(.text*[A-Z])` 这个条件比较复杂，它表示所有输入文件中以小写字母a到z开头的文件中所有段名以`.text`开头，并且以大写字母A到Z结尾的段。
