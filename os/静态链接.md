# 静态链接
{docsify-updated}


编译链接的过程：
<center><img src="pics/compile-link-process.png" width=30% ></center>
<center><img src="pics/linker.png" width=30% ></center>

以下列程序为例：
<center><img src="pics/link-sample-code.png" width=60% ></center>

### 链接的接口——符号
链接过程的本质就是要把多个不同的目标文件之间相互“粘”到一起，或者说像玩具积木一样，可以拼装形成一个整体。为了使不同目标文件之间能够相互粘合，这些目标文件之间必须有固定的规则才行，就像积木模块必须有凹凸部分才能够拼合。在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。比如目标文件B要用到了目标文件A中的函数“foo”，那么我们就称目标文件A定义（Define）了函数“foo”，称目标文件B引用（Reference）了目标文件A中的函数“foo”。这两个概念也同样适用于变量。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。

链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。除了函数和变量之外，还存在其他几种不常用到的符号：
+ 定义在本目标文件的全局符号，可以被其他目标文件引用。
+ 在本目标文件中引用的全局符号，却没有定义在本目标文件，叫做外部符号(External Symbol)。
+ 段名，通常由编译器产生，符号值就是段的起始地址。如代码段“.text”、数据段“.data”等。
+ 局部符号，由函数内部的局部变量产生，这些局部符号对链接过程没有作用，链接器也往往忽视他们。这也是为什么我们在用IDA反编译时看不到局部变量的名字。
+ 行号信息，通常用于调试。

现在的链接器空间分配的策略基本上都采用上述方法中的第二种，使用这种方法的链接器一般都采用一种叫两步链接（Two-passLinking）的方法。也就是说整个链接过程分两步。
1. 第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
2. 第二步 符号解析与重定位 使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。

那么链接器是怎么知道哪些指令是要被调整的呢？在目标文件中有一个叫做**重定位表**(Relocation Table)的结构专门用来保存与重定位相关的信息。对于每个要被重定位的ELF段都有一个对应的重定位表，例如.text段如有要被重定位的地方，就会有一个相对应的.rel.text的段保存了代码段的重定位表，数据段.data同理。

#### 一个很小的程序
传统的 hello world C程序，需要依赖C运行库的支持(printf函数)，并且默认以main函数做程序入口。以下程序会脱离C运行库而直接调用操作系统的系统调用来实现：

```
char* str = "Hello world\n";

void print(){
    asm(
            "movl $13, %%edx \n\t"
            "movl %0, %%ecx \n\t"
            "movl $0, %%ebx \n\t"
            "movl $4, %%eax \n\t"
            "int $0x80 \n\t"
            ::"r"(str):"edx","ecx","ebx");
}

void exit(){
    asm(
            "movl $42, %ebx \n\t"
            "movl $1, %eax \n\t"
            "int $0x80 \n\t");
}

void nomain(){
    print();
    exit();
}
```
编译链接命令：
```
gcc -c -fno-builtin min.c -m32
ld -static -e nomain -o min min.o -m elf_i386
```

我们可以用以下链接控制脚本将各个节合并到一个节：
```
ENTRY(nomain)
SECTIONS
{
    . = 0x0804800 + SIZEOF_HEADERS;
    tinytext : { * (.text) *(.data) *(.rodata) }
    /DISCARD/ : { *(.coment) }
}
```
编译链接命令：
```
gcc -c -fno-builtin min.c -m32
ld -static -T self-lds.lds -o min min.o -m elf_i386
```