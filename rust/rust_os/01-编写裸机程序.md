# 编写裸机程序
{docsify-updated}

要编写一个操作系统内核，我们需要编写不依赖任何操作系统特性的代码。这意味着我们不能使用线程、文件、堆内存、网络、随机数、标准输出，或其它任何需要操作系统抽象和特定硬件的特性；因为我们正在编写自己的操作系统和硬件驱动。

实现这一点，意味着我们不能使用 Rust标准库的大部分；但还有很多 Rust 特性是我们依然可以使用的。比如说，我们可以使用迭代器、闭包、模式匹配、Option、Result、字符串格式化，当然还有所有权系统。这些功能让我们能够编写表达性强、高层抽象的操作系统，而无需关心未定义行为和内存安全。

为了用 Rust 编写一个操作系统内核，我们需要创建一个独立于操作系统的可执行程序。这样的可执行程序常被称作独立式可执行程序（freestanding executable）或裸机程序(bare-metal executable)。


## 禁用标准库
在默认情况下，所有的 Rust 包（crate）都会链接标准库（standard library），而标准库依赖于操作系统功能，如线程、文件系统、网络。标准库还与 Rust 的 C 语言标准库实现库（libc）相关联，它也是和操作系统紧密交互的。既然我们的计划是编写自己的操作系统，我们就需要不使用任何与操作系统相关的库——因此我们必须禁用标准库自动引用（automatic inclusion）。使用 no_std 属性可以实现这一点。
```
cargo new blog_os --bin --edition 2024
```
创建项目。

现在我们的包依然隐式地与标准库链接。为了禁用这种链接，可以添加 `no_std` 属性：
```
#![no_std]

fn main() {}
```
看起来很顺利。当我们使用 `cargo build` 来编译的时候，却出现了下面的错误：
```
> cargo build
error: `#[panic_handler]` function required, but not found
error: language item required, but not found: `eh_personality`
```

编译器缺少一个 `#[panic_handler]` 函数和一个 `language item`.

## eh_personality 语言项
