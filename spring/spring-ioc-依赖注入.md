# Spring Ioc 依赖注入
{docsify-updated}

依赖注入（DI）是一个过程，在此过程中，对象仅通过构造函数参数、工厂方法参数或对象实例构造或从工厂方法返回后在其上设置的属性来定义其依赖关系（即与之协同工作的其他对象）。然后，容器会在创建 Bean 时注入这些依赖关系。从根本上说，这一过程是 bean 本身通过直接构建类或服务定位器模式来控制其依赖关系的实例化或位置的逆过程（因此被称为控制反转）。

## Bean 依赖注入的方式
三种依赖注入的方式，即**构造方法注入**（constructor injection）、**setter方法注入**（setter injection）以及**接口注入**（interface injection）。

1. 构造方法注入  
   构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是IoC容器）知道它需要哪些依赖对象。IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个生命周期，应该是由IoC Service Provider来管理的。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。
2. setter 方法注入  
   对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。setter 方法注入就是通过 setter 方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再注入。
3. 接口注入  
   相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。



## 基于构造函数的依赖注入
基于构造器的 DI 是通过容器调用带有参数（每个参数代表一个依赖关系）的构造器来实现的。调用带有特定参数的静态工厂方法来构造 Bean 也是同样的道理，构造器的参数和静态工厂方法的参数进行了类似的处理。

## 基于Setter的依赖注入
在调用无参数构造函数或无参数静态工厂方法实例化 Bean 后，容器会调用 Bean 上的 Setter 方法，从而实现基于设置器的 DI。

## 两种依赖注入方式的选择
可以混合使用基于构造函数和基于setter 的DI，一个很好的经验法则是将构造函数用于**强制性依赖关系**，而将setter 方法或配置方法用于**可选依赖关系**。注意，在setter方法上使用 `@Autowired` 注解可以使属性成为必备依赖项；不过，最好使用构造器注入并对参数进行编程验证。

Spring 团队通常提倡构造器注入，因为它可以将应用程序组件作为不可变对象来实现，并确保所需的依赖关系不会为 null 。此外，注入构造函数的组件总是以完全初始化过的状态返回给客户端（调用）代码。顺便提一句，大量的构造函数参数是一种不好的代码气味，这意味着类的职责可能过多，应进行重构，以更好地解决适当的分离问题。

设置器注入应主要用于可在类中分配合理默认值的可选依赖项。否则，必须在代码使用依赖关系的任何地方执行非空检查。设置器注入的一个好处是：**设置器方法可使该类的对象在以后进行重新配置或重新注入**。因此，通过 JMX MBeans 进行管理是设置器注入的一个重要用例。


## 依赖注入的过程
容器执行 bean 依赖关系解析的过程如下：
+ 创建 ApplicationContext 时，会使用描述所有 Bean 的配置元数据对其进行初始化。配置元数据可以通过 XML、Java 代码或注解指定。
+ 对于每个 Bean，其依赖关系以属性、构造函数参数或静态工厂方法参数的形式来表示出来的。这些依赖对象会在实际创建 Bean 时提供给相应的setter方法、构造函数或者静态工厂方法。
+ 每个属性或构造函数参数都是要设置的值（直接量）或者是对容器中另一个 Bean 的引用。
+ 作为值（直接量）的每个属性或构造函数参数都会从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，如 int、long、String、布尔等。

Spring 容器会在创建容器时验证每个 Bean 的配置。但是，在实际创建 Bean 之前，Bean 属性本身不会被设置。单例作用域（Bean Scopes 中可以定义作用域）并被设置为预实例化（默认）的 Bean 会在容器创建时创建。否则，Bean 只有在被请求时才会被创建。创建一个 Bean 可能会导致创建一个 Bean 依赖图，因为 Bean 的依赖及其依赖的依赖...都会被创建和分配。请注意，根据 bean 的作用域不同，这些依赖错误可能会在首次创建某个 Bean 时出现。

## Spring 循环依赖
如果使用构造函数注入，就有可能产生无法解决的循环依赖关系。

例如类 A 通过构造器注入需要类 B 的实例，而类 B 则通过构造器注入需要类 A 的实例。如果您将类 A 和类 B 的 Bean 配置为相互注入，Spring IoC 容器会在运行时检测到这种循环引用，并抛出 BeanCurrentlyInCreationException 异常。

一种解决方案是编辑某些类的源代码，使其通过设置器而不是构造器进行配置。或者，避免构造函数注入，只使用设置器注入。换句话说，虽然不推荐使用设置器注入，但可以用来配置循环依赖关系。



首先，Spring内部维护了三个Map，也就是我们通常说的三级缓存。
在Spring的`DefaultSingletonBeanRegistry`类中，你会赫然发现类上方挂着这三个Map：
+ `singletonObjects`: 它是我们最熟悉的朋友，俗称“单例池”“容器”，缓存创建完成单例Bean的地方。
+ `singletonFactories`: 映射创建Bean的原始工厂
+ `earlySingletonObjects`: 映射Bean的早期引用，也就是说在这个Map里的Bean不是完整的，甚至还不能称之为 “Bean”，只是一个Instance。

后两个Map其实是“垫脚石”级别的，只是创建Bean的时候，用来借助了一下，创建完成就清掉了。
为什么成为后两个Map为垫脚石，假设最终放在singletonObjects的Bean是你想要的一杯“凉白开”。
那么Spring准备了两个杯子，即singletonFactories和earlySingletonObjects来回“倒腾”几番，把热水晾成“凉白开”放到singletonObjects中。

简言之，两个池子：一个成品池子 singletonObjects ，一个半成品池子 earlySingletonObjects 。能解决循环依赖的前提是：spring开启了allowCircularReferences，那么一个正在被创建的bean才会被放在半成品池子里。在注入bean，向容器获取bean的时候，优先向成品池子要，要不到，再去向半成品池子要。

但是对于构造器注入来说，因为必须调用构造器来实例化对象，但是构造器有循环依赖，所以没有办法构造实例化对象，也就没法讲实例对象放到半成品池子，所以 spring 无法解决构造器的循环依赖问题。