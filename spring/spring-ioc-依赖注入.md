# Spring Ioc 依赖注入
{docsify-updated}

依赖注入（DI）是一个过程，在此过程中，对象仅通过构造函数参数、工厂方法参数或对象实例构造或从工厂方法返回后在其上设置的属性来定义其依赖关系（即与之协同工作的其他对象）。然后，容器会在创建 Bean 时注入这些依赖关系。从根本上说，这一过程是 bean 本身通过直接构建类或服务定位器模式来控制其依赖关系的实例化或位置的逆过程（因此被称为控制反转）。

## Bean 依赖注入的方式
三种依赖注入的方式，即**构造方法注入**（constructor injection）、**setter方法注入**（setter injection）以及**接口注入**（interface injection）。

1. 构造方法注入  
   构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是IoC容器）知道它需要哪些依赖对象。IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个生命周期，应该是由IoC Service Provider来管理的。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。
2. setter 方法注入  
   对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。setter 方法注入就是通过 setter 方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再注入。
3. 接口注入  
   相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。



## 基于构造函数的依赖注入
基于构造器的 DI 是通过容器调用带有参数（每个参数代表一个依赖关系）的构造器来实现的。调用带有特定参数的静态工厂方法来构造 Bean 也是同样的道理，构造器的参数和静态工厂方法的参数进行了类似的处理。

## 基于Setter的依赖注入
在调用无参数构造函数或无参数静态工厂方法实例化 Bean 后，容器会调用 Bean 上的 Setter 方法，从而实现基于设置器的 DI。

## 两种依赖注入方式的选择
可以混合使用基于构造函数和基于setter 的DI，一个很好的经验法则是将构造函数用于**强制性依赖关系**，而将setter 方法或配置方法用于**可选依赖关系**。注意，在setter方法上使用 `@Autowired` 注解可以使属性成为必备依赖项；不过，最好使用构造器注入并对参数进行编程验证。

Spring 团队通常提倡构造器注入，因为它可以将应用程序组件作为不可变对象来实现，并确保所需的依赖关系不会为 null 。此外，注入构造函数的组件总是以完全初始化过的状态返回给客户端（调用）代码。顺便提一句，大量的构造函数参数是一种不好的代码气味，这意味着类的职责可能过多，应进行重构，以更好地解决适当的分离问题。

设置器注入应主要用于可在类中分配合理默认值的可选依赖项。否则，必须在代码使用依赖关系的任何地方执行非空检查。设置器注入的一个好处是：**设置器方法可使该类的对象在以后进行重新配置或重新注入**。因此，通过 JMX MBeans 进行管理是设置器注入的一个重要用例。


## 依赖注入的过程
容器执行 bean 依赖关系解析的过程如下：
+ 创建 ApplicationContext 时，会使用描述所有 Bean 的配置元数据对其进行初始化。配置元数据可以通过 XML、Java 代码或注解指定。
+ 对于每个 Bean，其依赖关系以属性、构造函数参数或静态工厂方法参数的形式来表示出来的。这些依赖对象会在实际创建 Bean 时提供给相应的setter方法、构造函数或者静态工厂方法。
+ 每个属性或构造函数参数都是要设置的值（直接量）或者是对容器中另一个 Bean 的引用。
+ 作为值（直接量）的每个属性或构造函数参数都会从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，如 int、long、String、布尔等。

Spring 容器会在创建容器时验证每个 Bean 的配置。但是，在实际创建 Bean 之前，Bean 属性本身不会被设置。单例作用域（Bean Scopes 中可以定义作用域）并被设置为预实例化（默认）的 Bean 会在容器创建时创建。否则，Bean 只有在被请求时才会被创建。创建一个 Bean 可能会导致创建一个 Bean 依赖图，因为 Bean 的依赖及其依赖的依赖...都会被创建和分配。请注意，根据 bean 的作用域不同，这些依赖错误可能会在首次创建某个 Bean 时出现。

## depend-on
如果一个 Bean 是另一个 Bean 的依赖关系，这通常意味着一个 Bean 被设置为另一个 Bean 的属性。通常情况下，您可以通过基于 XML 的配置元数据中的 <ref/> 元素来实现这一点。不过，有时 Bean 之间的依赖关系并不那么直接。例如，需要触发一个类中的静态初始化器，如数据库驱动程序注册。`depends-on` 属性可以显式地强制在使用此元素的 Bean 初始化之前初始化一个或多个 Bean。下面的示例使用 depends-on 属性表达了对单个 Bean 的依赖关系：
```
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />

<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
	<property name="manager" ref="manager" />
</bean>

<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```
如果A依赖B，销毁 bean 时，依赖其他 Bean 的 Bean A会首先被销毁，然后才销毁给定 Bean B本身。

## 自动注入 Autowire
使用基于 XML 的配置元数据（请参阅依赖注入）时，您可以使用 <bean/> 元素的 `autowire` 属性为 bean 定义指定 autowire 模式。自动注入功能有四种模式。可以为每个 Bean 指定自动注入模式，从而选择要自动注入的 Bean。下表描述了四种自动注入模式：
1. no : 默认的无自动注入。Bean 引用必须由 ref 元素定义。对于大型部署，不建议更改默认设置，因为明确指定协作者会带来更强的控制力和清晰度。在某种程度上，它记录了系统的结构。
2. byName : 根据属性名称自动注入。Spring 会查找与需要自动注入的属性名称相同的 Bean。例如，如果一个 Bean 定义被设置为按名称自动注入，并且它包含一个 master 属性（即它有一个 setMaster(..) 方法），那么 Spring 就会查找一个名为 master 的 Bean 定义，并使用它来设置该属性。
3. byType : 如果容器中正好存在一个与属性类型相同的 Bean，则允许对该属性进行自动注入。如果存在一个以上的 Bean，则会抛出一个致命异常，表示不能对该 Bean 使用 byType 自动注入。如果没有匹配的 Bean，则不会发生任何事情（不设置属性）。
4. constructor : 与 byType 类似，但用于构造函数参数。如果容器中没有一个构造函数参数类型的 Bean，就会出现致命错误。

使用 byType 或构造函数自动注入模式，可以注入数组和集合（Collection）类型。在这种情况下，容器中所有符合预期类型的Bean都会被注入。自动注入的 Map 实例的值由符合预期类型的所有 Bean 实例组成，而 Map 实例的键必须是 String 类型，则包含相应的 Bean 名称。

### 自动注入的缺点和局限性
1. 属性和构造函数参数设置中的显式依赖关系总是覆盖自动注入。您不能自动注入简单属性，如基元、字符串和类（以及此类简单属性的数组）。这种限制是设计所致。
2. 自动注入不如显式布线精确。不过，正如前面的表格所指出的，Spring 会小心避免猜测，以防模棱两可造成意想不到的结果。Spring 管理对象之间的关系不再明确记录。
3. 从 Spring 容器生成文档的工具可能无法获得布线信息。
4. 容器中的多个 Bean 定义可能与设置器方法或构造器参数指定的类型相匹配，从而自动注入。对于数组、集合或 Map 实例，这不一定是个问题。但是，对于预期只有一个值的依赖关系，这种模糊性就不能任意解决了。如果没有可用的唯一 bean 定义，就会出现异常。


## 方法注入
在大多数应用场景中，容器中的大多数 Bean 都是单例。当一个单例 Bean 需要与另一个单例 Bean 协作，或一个非单例 Bean 需要与另一个非单例 Bean 协作时，您通常会通过将一个 Bean 定义为另一个 Bean 的属性来处理这种依赖关系。当 bean 的生命周期不同时，问题就出现了。假设单例 Bean A 需要使用非单例（原型）Bean B，可能是在 A 的每次方法调用中。容器无法在每次需要时都为 Bean A 提供一个新的 Bean B 实例。

`@Lookup`

## Spring 循环依赖
如果使用构造函数注入，就有可能产生无法解决的循环依赖关系。

例如类 A 通过构造器注入需要类 B 的实例，而类 B 则通过构造器注入需要类 A 的实例。如果您将类 A 和类 B 的 Bean 配置为相互注入，Spring IoC 容器会在运行时检测到这种循环引用，并抛出 BeanCurrentlyInCreationException 异常。

一种解决方案是编辑某些类的源代码，使其通过设置器而不是构造器进行配置。或者，避免构造函数注入，只使用设置器注入。换句话说，虽然不推荐使用设置器注入，但可以用来配置循环依赖关系。



首先，Spring内部维护了三个Map，也就是我们通常说的三级缓存。
在Spring的`DefaultSingletonBeanRegistry`类中，你会赫然发现类上方挂着这三个Map：
+ `singletonObjects`: 它是我们最熟悉的朋友，俗称“单例池”“容器”，缓存创建完成单例Bean的地方。
+ `singletonFactories`: 映射创建Bean的原始工厂
+ `earlySingletonObjects`: 映射Bean的早期引用，也就是说在这个Map里的Bean不是完整的，甚至还不能称之为 “Bean”，只是一个Instance。

后两个Map其实是“垫脚石”级别的，只是创建Bean的时候，用来借助了一下，创建完成就清掉了。
为什么成为后两个Map为垫脚石，假设最终放在singletonObjects的Bean是你想要的一杯“凉白开”。
那么Spring准备了两个杯子，即singletonFactories和earlySingletonObjects来回“倒腾”几番，把热水晾成“凉白开”放到singletonObjects中。

简言之，两个池子：一个成品池子 singletonObjects ，一个半成品池子 earlySingletonObjects 。能解决循环依赖的前提是：spring开启了allowCircularReferences，那么一个正在被创建的bean才会被放在半成品池子里。在注入bean，向容器获取bean的时候，优先向成品池子要，要不到，再去向半成品池子要。

但是对于构造器注入来说，因为必须调用构造器来实例化对象，但是构造器有循环依赖，所以没有办法构造实例化对象，也就没法讲实例对象放到半成品池子，所以 spring 无法解决构造器的循环依赖问题。