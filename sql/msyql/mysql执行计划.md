# 执行计划
{docsify-updated}

+ `id`: 在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id
+ `select_type`: SELECT 关键字对应的那个查询的类型
+ `table`: 表名
+ `partitions`: 匹配的分区信息
+ `type`: 针对单表的访问方法
+ `possible_keys`: 可能用到的索引
+ `key`: 实际上使用的索引
+ `key_len`: 实际使用到的索引长度
+ `ref`: 当使用索引列等值查询时，与索引列进行等值匹配的对象信息
+ `rows`: 预估的需要读取的记录条数
+ `filtered`: 某个表经过搜索条件过滤后剩余记录条数的百分比
+ `Extra`: 一些额外的信息


## ID
查询询语句一般都以 `SELECT` 关键字开头，  比较简单的查询语句中只有一个 `SELECT` 关键字，但是在下面这两种情况下， 一条查询语句中会出现多个 `SELECT` 关键字 :

1. 查询中包含子查询的情况。 比如下面这个查询语句中就包含 2 个 `SELECT` 关键字:
    ```sql
    SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2);
    ```
2. 查询 中包含 `UNION` 子句的情况。 比如下面这个查询语句 中 就包含 2 个 SELECT 关键字:
   ```sql
    SELECT * FROM s1 UNION SELECT * FROM s2;
   ```

查询语句中每出现一个 `SELECT` 关键字 ， 设计 MySQL 的 大叔就会为它分配一个唯一的ID值 ， 这个 id 值就是 `EXPLAIN` 时输出的第一列 。

对于连接查询来说， 一个 `SELECT` 关键字后面的 `FROM` 子句中可以跟随多个表。在连接查询的执行计划中 ，每个表都会对应一条记录，但是这些记录 的 id 值都是相同的。连接查询的执行计划中 ，每个表都会对应一条记录，这些记录的 id 列的值是相同的; 出现在前面的表表示驱动衰，出现在后面的表表示被驱动表。

在许多 UNION 语句中，它的执行计划可能还包含 ID 为 NULL 的条目，íd 为 NULL 表明这个临时表是为了合并两个查询的结果集而创建的。

+ id相同执行顺序由上至下
+ id不同，id值越大优先级越高，越先被执行。
+ id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。

## select_type