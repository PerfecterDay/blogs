
# JavaScript的运行机制
{docsify-updated}

说到JS，脑海里首先会想到的是单线程、事件循环、异步等等概念，这些名词到底代表什么，之前了解的不是很深入。后来，看到这个Philip Roberts的演讲：《[Help, I’m stuck in an event-loop.](https://vimeo.com/96425312)》.感觉对这些概念的理解又深入了一些。

首先，引入一张图：
<center><img src="pics/js_eventloop.png" alt="V8 JS运行原理"></center>

首先按照我的理解来描述一下上图：
我们写了一个JS脚本文件，JS引擎执行的时候，会产生执行栈和堆，JS引擎在执行代码的时候，代码可能会调用WebApi(js/DOM等提供的一些js函数)执行一些异步操作，比如执行ajax、调用setTimeout、绑定响应DOM事件的函数等等。这些webApi函数往往都是需要一个回调函数作为参数来调用的。但是这些回调函数不会立即被调用，而是在一定条件下，由webApi内部将这些回调函数放到call-back-queue中，JS引擎在执行完脚本代码后，最后会在event-loop上死循环。

**通俗的解释就是 JS 引擎在执行我们写 JS 脚本时，启动一个初始的函数栈，执行脚本时，发现一些异步操作时，会启动"异步任务"，这些异步任务会在成功完成或失败时产生对应的事件，JS在解析执行这些异步任务脚本时也会将这些事件与其处理函数的绑定关系记录下来，存放在 call-back-queue 中。所有的脚本解析完成后，js 引擎就会在 event-loop 上执行死循环。等待事件的到来，一旦侦测到事件，就会执行绑定的函数。**

所以说，JS脚本中的代码总是先于call-back-queue中的代码执行。
对照上图，我们一一来解释上述名词

## 单线程
单线程指的是JS引擎执行JS代码是单线程的，但是一些WebApi调用如ajax,setTimeout,事件响应等是由其它线程完成的。之前一直困扰我的一个问题是：既然JS是单线程的，那么它是如何做到并发的执行JS代码，又去发起异步ajax请求的呢？其实，ajax请求是由webApi实现者完成的。它可以是多线程的。
所以这里单线程的范畴应该是指图中的call stack、堆、event-loop和call-back-queue。

## 事件循环
JS引擎最后总是陷入event-loop循环执行call-back-queue中的回调函数。
```
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

## 异步
webApi的某些调用执行是在另一个线程中完成的，与JS执行线程是异步的。JS通过执行回调函数来响应webApi产生的事件。

## 队列
一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。

在事件循环期间的某个时刻，运行时会从**最先进入队列的消息**开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。

函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。

## 多个运行时互相通信
一个 web worker 或者一个跨域的 iframe 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 `postMessage` 方法进行通信。如果另一个运行时侦听 message 事件，则此方法会向该运行时添加消息。