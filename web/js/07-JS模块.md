# 模块
{docsify-updated}

>　https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules


JavaScript 程序本来很小——在早期，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地方提供一定交互，所以一般不需要多大的脚本。过了几年，我们现在有了运行大量 JavaScript 脚本的复杂程序，还有一些被用在其他环境。

复杂的项目需要一种将 JavaScript 程序拆分为可按需导入的单独模块的机制。Node.js 已经提供这个能力很长时间了，还有很多的 JavaScript 库和框架已经开始了模块的使用（例如，CommonJS 和基于 AMD 的其他模块系统，如 RequireJS、webpack 和 Babel）。

所有现代浏览器都原生支持模块特性，无需转译。这是一件好事——浏览器可以优化模块的加载，使其比使用库进行所有额外的客户端处理和额外的网络开销更高效。不过，这并不意味着像 webpack 这样的打包工具就过时了——打包工具仍然在将代码分割成合理大小的块方面做得很好，并且能够进行其他优化，如极简化、无用代码消除和摇树优化。


## 例子
目录结构：
```
index.html
main.js
modules/
    canvas.js
    square.js
```

## 导出
为了获得模块的功能要做的第一件事是把它们导出来。使用 export 语句来完成。

最简单的方法是把它（指上面的 export 语句）放到你想要导出的项前面，比如导出 square 功能：
```js
export const name = "square";

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);

  return {
    length: length,
    x: x,
    y: y,
    color: color,
  };
}
```

**能够导出函数，var，let，const, 和等会会看到的类。export 要放在最外层；比如你不能够在函数内使用 export**。

一个更方便的方法导出所有你想要导出的模块的方法是在模块文件的末尾使用一个 export 语句，语句是用花括号括起来的用逗号分割的列表。比如：
```
export { name, draw, reportArea, reportPerimeter };
```

## 导入
如果想在模块外面使用一些功能，那你就需要导入他们才能使用。最简单的就像下面这样的：
```js
import { name, draw, reportArea, reportPerimeter } from '/js-examples/modules/basic-modules/modules/square.js';
```

使用 `import` 语句，然后你被花括号包围的用逗号分隔的你想导入的功能列表，然后是关键字 `from` ，然后是模块文件的路径。模块文件的路径是**相对于站点根目录的相对路径**，对于我们的 `basic-modules` 应该是 `/js-examples/modules/basic-modules`。

当然，我们写的路径有一点不同——我们使用点语法意味“当前路径”，跟随着包含我们想要找的文件的路径。这比每次都要写下整个相对路径要好得多，因为它更短，使得 URL 可移植——如果在站点层中你把它移动到不同的路径下面仍然能够工作。  
`/js/examples/modules/basic-modules/modules/square.js` ---> `./modules/square.js`


## 应用模块到你的 HTML
需要把 `type="module"` 放到 `<script>` 标签中，来声明这个脚本是一个模块：
```
<script type="module" src="main.js"></script>
```
你导入模块功能的脚本基本是作为顶级模块。如果省略它，Firefox 就会给出错误“SyntaxError: import declarations may only appear at top level of a module。

只能在模块内部使用 `import` 和 `export` 语句；不能在常规脚本中使用。如果你的 `<script>` 元素没有 `type="module"` 属性并尝试导入其他模块(使用 import 语句)，将会抛出错误。

`<script nomodule>` 代表如果浏览器不支持模块功能才会执行脚本，否则不会执行


### 模块脚本与普通脚本的不同
+ 需要注意本地测试——如果你通过本地加载 HTML 文件（比如一个 file:// 路径的文件），你将会遇到 CORS 错误，因为 JavaScript 模块安全性需要。你需要通过一个服务器来测试。
+ 另请注意，可能会从模块内部定义的脚本部分获得与标准脚本中不同的行为。这是因为模块自动使用严格模式。
+ 加载一个模块脚本时不需要使用 defer 属性 (see `<script> attributes`) 模块会自动延迟加载。
+ 最后一个但不是不重要，需要明白模块功能**导入到单独的脚本文件的范围——他们无法在全局获得**。因此，你只能在导入这些功能的脚本文件中使用他们，你也无法通过 JavaScript console 中获取到他们，比如，在 DevTools 中你仍然能够获取到语法错误，但是你可能无法像你想的那样使用一些 debug 技术。

## 默认导出 vs 命名导出
在我们的基本模块 square.js 中，你可以找到一个名为 randomSquare() 的函数，它创建一个具有随机颜色，大小和位置的正方形。我们想作为默认导出，所以在文件的底部我们这样写：
```js
export default randomSquare;
```
注意，没有大括号。

可以把 export default 放到函数前面，定义它为一个匿名函数，像这样：
```js
export default function(ctx) {
  ...
}
```

在我们的 main.js 文件中，我们使用以下行导入默认函数：
```js
import randomSquare from "./modules/square.js";
```

同样，没有大括号，因为每个模块只允许有一个默认导出，我们知道 randomSquare 就是需要的那个。上面的那一行相当于下面的缩写：
```js
import { default as randomSquare } from "./modules/square.js";
```

## 重命名导出与导入
当我们使用不同的模块时，可能会有相同的函数比如 `draw()`、`reportArea()`，等等；如果我们用相同的名字导入不同的函数到顶级模块文件中，我们会收到冲突和错误。

在你的 import 和 export 语句的大括号中，可以使用 as 关键字跟一个新的名字，来改变你在顶级模块中将要使用的功能的标识名字。因此，例如，以下两者都会做同样的工作，尽管方式略有不同：
```js
// inside module.js
export { function1 as newFunctionName, function2 as anotherNewFunctionName };

// inside main.js
import { newFunctionName, anotherNewFunctionName } from "/modules/module.js";
```
或者，更推荐第二种方式，在导入时重命名。因为有时候你无法更改第三方模块的代码：
```js
// inside module1.js
export { function1, function2 };

// inside module2.js
export { function1, function2 };

// inside main.js
import {
  function1 as newFunctionName1,
  function2 as anotherNewFunctionName1,
} from "/modules/module1.js";

import {
  function1 as newFunctionName2,
  function2 as anotherNewFunctionName2,
} from "/modules/module2.js";
```

## 导出模块对象
上面的分别导入模块中变量的方法工作的挺好，但是有一点点混乱、亢长。一个更好的解决方是，导入每一个模块功能到一个模块功能对象上。可以使用以下语法形式：
```js
import * as Module from "/modules/module.js";
```
这将获取 module.js 中所有可用的导出，并使它们可以作为对象模块的成员使用，从而有效地为其提供自己的命名空间。例如：
```
Module.function1();
Module.function2();
```

例子：
```
import * as Canvas from "./modules/canvas.js";

import * as Square from "/./modules/square.js";
import * as Circle from "./modules/circle.js";
import * as Triangle from "./modules/triangle.js";


let square1 = Square.draw(myCanvas.ctx, 50, 50, 100, "blue");
Square.reportArea(square1.length, reportList);
Square.reportPerimeter(square1.length, reportList);
Canvas.draw(...)
```


## 加载非 JavaScript 资源
统一模块架构带来的一个令人兴奋的功能是能够将非 JavaScript 资源作为模块加载。例如，你可以将 JSON 作为 JavaScript 对象导入，或将 CSS 作为 CSSStyleSheet 对象导入。

你必须明确声明你正在导入哪种资源。默认情况下，浏览器假定资源是 JavaScript，如果解析的资源是其他类型，将抛出错误。要导入 JSON、CSS 或其他类型的资源，请使用导入属性语法：
```
import colors from "./colors.json" with { type: "json" };
import styles from "./styles.css" with { type: "css" };
```
浏览器还会对模块类型进行验证，如果 `./data.json` 不是 JSON 文件，将会失败。这确保了你在仅打算导入数据时不会意外执行代码。一旦成功导入，你现在可以像使用普通 JavaScript 对象或 CSSStyleSheet 对象一样使用导入的值。