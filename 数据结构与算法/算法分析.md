## 算法分析
{docsify-updated}

- [算法分析](#算法分析)
	- [LogN](#logn)
	- [递归的运行时间](#递归的运行时间)


时间复杂度指算法运行需要的时间。我们一般将算法的基本运算执行次数作为时间复杂度的度量标准。

<center><img src="pics/O.jpg" width="30%"></center>

指数阶增量随着x 的增加而急剧增加，而对数阶增加缓慢。它们之间的关系为 $$О(1)<О(logn)<О(n)<О(nlogn)<О(n^2)<О(n^3)<О(2^n)<О(n!)<О(n^n)。$$


### LogN
一种很常见的运行时间是 O(log N)。它是从哪儿冒出来的？  
让我们以二分查找为例。假设一个排序数组长度为 N，目标值为 x。首先比较 x 与中值，如果 x 等于中值直接返回。如果 x 小于中值，搜索数组的左边。如果 x 大于中值，搜索数组的右边。
``` 
search 9 within {1, 5, 8, 9, 11, 13, 15, 19, 21}  
    compare 9 to 11 -> smaller.  
    search 9 within {1, 5, 8, 9}  
        compare 9 to 8 -> bigger  
        search 9 within {9}  
            compare 9 to 9  
            return 
```
开始时有 N 个元素的排序数组需要搜索。经过一次搜索之后，还剩下 N/2 个元素。再一次，只剩下 N/4 个元素。直到找到目标值或者待搜索的元素个数为 1 时才停止搜索。   
总的运行时间是从 N（N 每次减半）到 1 一共搜索了多少次。 
```
N = 16 
N = 8 /* 除以 2 */ 
N = 4 /* 除以 2 */ 
N = 2 /* 除以 2 */ 
N = 1 /* 除以 2 */ 
```
可以倒着看（从 16 到 1 变成从 1 到 16）。从 1 开始每次乘以 2，多少次能得到 N？ 
```
N = 1 
N = 2       /* 乘以 2 */ 
N = 4       /* 乘以 2 */ 
N = 8       /* 乘以 2 */ 
N = 16      /* 乘以 2 */ 
```
也就是 2k = N 中的 k，它的值是多少？它恰好符合 log 的语义。   
$2^4 = 16 -> log_216 = 4$  
$log_2 N = k -> 2^k = N $

这是一个很好的推导方法。下次你看到一个类似的问题，元素个数也是每次减半，它的运行时很可能是 Ο(log N)。  
同理，在平衡二叉搜索树中查找一个元素也是 Ο(log N)。每次比较，非左即右。每边都有一半的节点，也就是说每次都把问题规模缩小一半。 

### 递归的运行时间 
这个问题向来棘手。下面代码的运行时间是多少？ 
```
int f(int n) { 
	if (n <= 1) { 
	return 1; 
	} 
	return f(n - 1) + f(n - 1); 
} 
```

不知何故，很多人一看到两次调用，就不假思索地认为运行时间为 Ο(N2)。其实一点都不对。  
相比于臆想，不如通过模拟代码执行来推断出它的运行时间。假设调用 f(4)，它调用 f(3)两次，每个 f(3)都会调用 f(2)两次，以此类推直到 f(1)。
<center><img src="pics/recursiveO.jpg" width="60%"></center>

因此，节点数为  
$2^0 + 2^1+ 2^2+ 2^3+ 2^4+ … + 2^N = 2^{N + 1}$  

尽量记住这个模式。当一个多次调用自己的递归函数出现时，它的运行时间往往是（偶尔不是）  
$Ο(分支数^{树的深度})$  
分支数是每次调用自己的次数。

所以，上面例子中运行时间是 $Ο(2^N)$。

