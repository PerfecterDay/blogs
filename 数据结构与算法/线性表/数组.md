## 数组
{docsify-updated}

- [数组](#数组)
  - [前缀和](#前缀和)
  - [差分数组](#差分数组)

+ 给定下标可在常数时间内访问元素:由于数组中每个元素的下标直接对应了内存中的特定地址 ， 如果能知道下标 ， 则可迅速访问该数据项。
+ 节约空间： 数组完全由数据构成 ，不存在因链接或其他格式信息 (formatting information) 而造成的浪费。 此外，数组由数目固定的若干个记录构成 ， 从而不需要记录终止信息来标记数组结束。
+ 内存局部性 ：编程常常需要对数据结构中所有元素从头至尾进行迭代 ，事实上这是程序设计中的一种惯用法、 由于数组体现了极好的内存局部性 ，因此它非常适宜于开展迭代。在对数据进行相继访问时，数据地址在物理上的连续性有助于充分利用现代计算机系统结构中的高速缓存。

### 前缀和
前缀和主要适⽤的场景是**原始数组不会被修改的情况下，频繁查询某个区间的累加和。**

例题：
> 给定一个数组，设计一个类，能快速的返回 [i,j] 区间内元素的和。

1. 普通算法（O(n)）：
    ```java
    int res = 0;
    for(int k=i; k<=j; ++k>){
        res += arr[k];
    }
    return res
    ```

2. 前缀和(时间O(1)，空间复杂度O(n))：  
   定义有一个前缀和数组 $preSum[], preSum[0]=arr[0], preSum[i] = sum[0,i] = preSum[i-1] + arr[i]$;  
   $sum[i,j] = sum[0,j] - sum[0,i-1] = preSum[j] - preSum[i-1]$
   ```java
   class SumArray{
       int[] arr;
       int[] preSum;

       public SumArray(int[] arr){
           this.arr = arr;
           initPresum();
       }

       private void initPresum(){
           preSum = new int[arr.length];
           preSum[0] = arr[0];
           for(int k = 0; k < arr.length; ++ k){
               preSum[k] = preSum[k-1] + arr[k];
           }
       }

       public int sumRange(int i, int j){
           return preSum[j] - preSum[i>0?i-1:0];
       }
   }
   ```

### 差分数组
差分数组的主要适⽤场景是**频繁对原始数组的某个区间的元素进⾏增减。**

例题：
> 给定一个数组 arr ,然后要求给 [2,5] 的所有元素加2；然后给 [3,8] 的所有元素减3，然后[7,10]的所有元素加1....求最后数组 arr 的各个元素值？

1. 普通算法
   ```java
   class ChangeArray{
       int[] arr;

       public ChangeArray(int[] arr ){
           this.arr = arr;
       }

       private void change(int left,int right,int change){
		   // 拷贝一个临时数组 tmp
           for(int i = left; i < right; ++i ){
               tmp[i] += change;
           }
       }
   }
   ```

2. 差分数组：
   定义一个差分数组$ diff[] ; dff[0]=arr[0], diff[i] = arr[i] - arr[i-1]$;   
   由差分数组反推原数组：$arr[i]=sum(diff[0,i])$;  
   这样构造差分数组 diff，就可以快速进⾏区间增减的操作，如果你想对区间 arr[i..j] 的元素全部加3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可.  
   原理很简单，回想 diff 数组反推 arr 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 ⼜意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，是不是就是对nums[i..j] 中的所有元素都加 3 了.
   
   ```java
   class ChangeArray{
       int[] arr;
       int[] diff;

       public SumArray(int[] arr){
           this.arr = arr;
           initDiff();
       }

       private void initPresum(){
           diff = new int[arr.length];
           diff[0] = arr[0];
           for(int k = 1; k < arr.length; ++ k){
               diff[k] = arr[k] - arr[k-1];
           }
       }

       public void changeRange(int i, int j,int change){
           diff[i-1] += change;
           if(j-1 < diff.length){
               diff[j-1] -= change;
           }
       }

       public void backArr(){
           arr[0] = diff[0];
           for(int k = 1; k < arr.length; ++ k){
               arr[k] = diff[k] + nums[k-1];
           }
       }
   }
   ```