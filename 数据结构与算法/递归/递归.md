## 递归
{docsify-updated}

> https://developer.ibm.com/articles/l-recurs/

- [递归](#递归)
	- [阶乘](#阶乘)
	- [汉诺塔](#汉诺塔)
	- [数学归纳法](#数学归纳法)
	- [平面上的直线](#平面上的直线)
	- [约瑟夫环问题](#约瑟夫环问题)
	- [递归代码分析](#递归代码分析)

**遇到一个问题，先研究小的情形是大有裨益的.聪明的数学家们不会羞于考虑小问题，因为当极端情形（即便它们是平凡的情形）弄得明明白白时，一般的形式就容易理解了．**

### 阶乘
<center><img src="pics/recursion.jpg" width="40%"></center>


### 汉诺塔
$T_n$是根据卢卡斯的规则将 n个圆盘从一根桩柱移动到另一根桩柱所需要的最少移动次数．那么，$T_1$ 显然是1，而$T_2=3$ 

移动3个圆盘的试验表明，获胜的思路是将上面两个圆盘移动到中间的桩柱上，然后移动第三个圆盘，接着再把其余两个放到它上面．这就为移动 n 个圆盘提供了一条线索：首先把 $n-1$个小的圆盘移动到一个不同的桩柱上（需要$T_{n-1}$次移动），然后移动最大的圆盘（需要一次移动），最后再把那$n-1$个小的圆盘移回到最大圆盘的上面（这需要另外的$T_{n-1}$次移动）．这样，至多
需要 $2T_{n-1}+1$次移动就能移动 n 个圆盘了，我们可以得出递归式：
$$T_0 = 0;\\ T_n = 2T_{n-1}+1 $$

### 数学归纳法
**数学归纳法**（mathematical induction）是证明某个命题对所有满足 $n≥n_0$ 的整数 n 都成立的一般方法．首先我们在 n 取最小值 $n_0$ 时证明该命题，这一步骤称为**基础**（basis）；然后对 $n > n_0$ ，假设该命题对 $n_0$ 与 $n-1$之间（包含它们在内）的所有值都已经被证明，再证明该命题对 n 成立，这一步骤称为**归纳**（induction）．这样一种证明方法仅用有限步就得到无限多个结果。

形象的解释： 通过证明我们可以 爬到梯子的最底一 级（基础），并能从 一个阶梯爬到上一 个阶梯（归纳），数 学归纳法就证明了： 我们可以在一架梯 子上想爬多高就爬 多高．

### 平面上的直线
用一把比萨刀直直地切 n 刀，可以得到多少块比萨饼？或者说得更有学术味儿点：平面上 n 条直线所界定的区域的最大个数$L_n$ 是多少？

第 n(n>0) 条直线使得区域的个数增加 k 个， 当且仅当它对 k 个已有区域进行了分裂；而它对 k 个已有区域进行分裂，当且仅当它在 k-1 个不同的地方与前面那些直线相交．两条直线至多相交于一点，因而这条新的直线与那 n-1 条已有直线至多相交于 n-1个不同的点，故必定有 $k\leq n$ ．我们就证明了上界:
$$L_0=1; \\ L_n \leq L_{n-1} + n$$

展开求解析式：
$$
L_n = L_{n-1} + n
    = L_{n-2} + (n-1) + n
	= L_{n-3} + (n-2) + (n-1) + n
	...
	= L_0 + 1 + ....+ (n-1) + n
	= 1 + S_n ;\\
S_n = 1 + 2 + ..... + n = {n(n+1)\over2};
$$

### 约瑟夫环问题
从围成标有记号1到 n 的圆圈的 n 个人开始，每隔一个删去一 个人，直到只有一个人幸存下来，求幸存者的编号？


### 递归代码分析
如下代码，遍历一颗树的所有路径：
```
static void preOrder(TreeNode root, List<Integer> path, List<List<Integer>> res) {
	if (root == null) {
		return;
	}
	path.add(root.val);
	if (root.left == null && root.right == null) {
		List copy = List.copyOf(path);
		res.add(copy);
		path.remove(path.size() - 1);
		return;
	}
	preOrder(root.left, path, res);
	preOrder(root.right, path, res);
	path.remove(path.size() - 1);
}
```
通常我们只会注意到开始处 retuen 处有一个函数出口（base 情况下的出口），实际上在最后一行也是函数调用的出口（非base 情况下的出口）。  
两个出口实际上是在处理同一个节点，所以两个remove 都需要加上。