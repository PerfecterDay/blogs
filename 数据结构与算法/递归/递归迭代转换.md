## 递归
{docsify-updated}
> https://www.baeldung.com/cs/factorial-recursion-to-iteration  
> https://www.baeldung.com/cs/convert-recursion-to-iteration

- [递归](#递归)
  - [递归](#递归-1)
  - [转换尾递归函数](#转换尾递归函数)
    - [尾部递归的迭代版本](#尾部递归的迭代版本)
    - [Example](#example)
  - [一般转换方法](#一般转换方法)
    - [递归的一般形式](#递归的一般形式)
    - [执行图](#执行图)
    - [作为深度优先遍历执行](#作为深度优先遍历执行)
    - [实施细节](#实施细节)
    - [Example](#example-1)
      - [框架、边缘和边缘创建](#框架边缘和边缘创建)
    - [可读性和语义](#可读性和语义)
    - [优化和递归类型](#优化和递归类型)
  - [为什么要将递归转换为迭代](#为什么要将递归转换为迭代)
  - [将递归转换为迭代的优势](#将递归转换为迭代的优势)


在本教程中，我们将讨论将递归函数转换为迭代形式的方法。我们将介绍适用于尾递归和头递归的转换方法，以及一种可将任何递归转换为迭代算法的通用技术。
你总能把递归函数变成迭代函数吗？是的，绝对可以，如果没记错的话，丘奇-图灵论证了这一点。通俗地说，就是递归函数可计算的内容，迭代模型（如图灵机）也可计算，反之亦然。论文并没有告诉你如何精确地进行转换，但它确实说这是绝对可能的。参见：[stackoverflow](https://stackoverflow.com/questions/931762/can-every-recursion-be-converted-into-iteration)

### 递归
递归有很多好处。许多问题具有递归结构，可以分解成更小的子问题。因此，以递归方式求解子问题并将它们的解结合起来，是处理这类问题的自然方法。因此，递归函数更易于阅读、理解和维护。

不过，递归本身也存在一些问题。由于每次递归调用都会在调用堆栈中添加一个新帧，如果处理的输入量非常大，递归函数可能会耗尽堆栈内存，从而导致堆栈溢出错误。此外，递归函数的内存和空间复杂度可能高于迭代函数。让我们来看看计算斐波那契数的递归函数和迭代函数：
<center><img src="pics/quicklatex.com-ad4a62327cfdc970cf97d7a8dd647d8c_l3.svg" alt=""></center>

递归函数 $Fibonacci_R$ 的可读性更高，因为它遵循了斐波纳契数的定义：
<center><img src="pics/quicklatex.com-7af68d35d96ec6637570570264b71ad6_l3.svg" alt=""></center>

但是，由于堆栈的深度有限，因此对于较大的 n 数，堆栈会出现溢出。相比之下，迭代函数在同一帧内运行。此外，递归函数的时间复杂度是指数级的，而迭代函数是线性的。这就是我们有时需要将递归算法转换为迭代算法的原因。可读性上的损失，换来的是性能上的提升。

### 转换尾递归函数
最容易处理的情况是尾部递归。当递归调用结束时，这类函数已经完成了其主体（非基本分支）中的所有工作，因此此时除了返回其值外，没有其他事情可做。一般来说，它们遵循相同的模式：
<center><img src="pics/quicklatex.com-c7be317df3d0d315168e932b1875a387_l3.svg" alt=""></center>

累加器是在执行过程中保存部分解的变量。它们代表一连串子问题的解决方案，一个问题嵌套一个问题。每次调用都会更新累加器，直到递归到基本情况。此时，累加器中保存的是我们一开始求解的整个问题的解决方案。

#### 尾部递归的迭代版本
上述尾递归模式有以下迭代版本：
<center><img src="pics/quicklatex.com-75025ae5655ada4808812d41bc95159e_l3.svg" alt=""></center>
由此，我们制定了转换的一般规则：

1. 在 while 循环之前初始化累加器。
2. 使用基例条件的否定作为循环的条件。
3. 使用递归函数的主体（递归调用除外）作为 while 循环的主体。
4. 循环结束后，应用累加器的基值更新并返回其值。

通常情况下，基值更新并不会改变累加器的值，因为它通常只是一个中性操作，如加 0 或乘 1，或者没有更新可应用。因此，在大多数情况下，我们可以忽略这一部分。尽管如此，我们还是在伪代码中保留了这一部分，以考虑到那些基本情况下更新并不复杂的函数。例如，如果我们有多个基本情况，并且每个基本情况都将不同的值与累加器相结合，就会出现这种情况。如果基值更新取决于累加器，也会出现这种情况。

#### Example
让我们运用这些规则，转换一个用于计算阶乘的尾递归函数：
<center><img src="pics/quicklatex.com-a298bee4f2370b8be080bf213d58ea59_l3.svg" alt=""></center>

现在，让我们确定在迭代变体中将重新排序的尾部递归的元素：

1. 基础条件：$n=0$
2. 基准累加器更新：乘以 1
3. 累加器的初始值：1
4. 累加器更新：  $accumulator <--- n * accumulator$
5. 问题缩小: $n-->n-1$

有鉴于此，我们可以得到以下迭代函数：
<center><img src="pics/quicklatex.com-1f7a8c8e72459de14cc94e11b16ebbca_l3.svg" alt=""></center>

即使 $n=0$ 的否定是 $n\neq 0$ 而不是 $n>0$，我们也使用后者，因为 $n$仅限于自然数。

### 一般转换方法
我们看到了如何将尾递归函数变成迭代函数。不过，还有其他递归类型。例如，头部递归函数将递归调用放在函数体的开头而不是结尾。其他类型的递归函数会在调用的周围添加代码块，用于预处理输入和后处理调用的返回值。此外，递归函数可以在其主体中进行任意次数的递归调用，而不仅仅是一次。

幸运的是，我们有一种通用方法可以将任何递归转化为迭代算法。该方法基于以下观察：递归函数是通过将帧推入调用栈并从中弹出来执行的。因此，如果我们模拟堆栈，就可以在一个主循环中迭代执行任何递归函数。不过，这样得到的代码可能并不漂亮。这就是为什么我们通常会首先尝试使函数具有尾递归性。如果成功了，我们就可以使用第 3 节中的方法得到相当可读的代码。如果不成功，我们就使用一般转换方法。因此，让我们先看看递归函数的一般形式。

#### 递归的一般形式
递归函数可以在其主体中进行任意次数的递归调用：
<center><img src="pics/quicklatex.com-b371233b445a9130237014ae5509f0c3_l3.svg" alt=""></center>

这个伪代码涵盖了递归调用次数（m）恒定或有界的情况（如二叉树遍历（m=2）），m 取决于问题大小的情况。此外，基础解决方案可以是恒定的，也可以取决于通过测试的情况。此外，每个非递归代码块可以是空的，也可以是一条指令，还可以包括对其他子程序的调用。其目的是为第 - 次递归调用准备数据。最后，对递归子解决方案的组合也应作一般理解：它可以很简单，也可以更复杂。

#### 执行图
每次调用都会创建一个框架。它是一个结构，包含传递的参数、局部变量和返回值的占位符。如果我们将框架可视化并跟踪调用，就会发现递归函数定义了一个隐式有向图。图中的节点是框架，其中一些框架没有明显的边。它们代表递归的基本情况。其他节点则有向内和向外的边缘：它们是基例和第一次调用之间的调用模型。让我们来看看斐波那契数字图的一部分：
<center><img src="pics/fibonacci.jpg" alt=""></center>

一条从 u 到 v 的有向边对应于一个递归调用，该递归调用 u 使帧 v 成为活动帧。因此，执行递归函数等同于以结构化的方式遍历帧图。我们会对每条边 $u -> v$进行两次遍历：第一次是在u调用时创建 v，第二次是在 v 将调用值返回给 u 时.

#### 作为深度优先遍历执行
因此，我们从原始调用者的框架节点开始，在第一次递归调用之前执行非递归代码块。此时，我们已经创建了一个子节点，它代表了调用的框架。递归的工作方式意味着我们应该移动到子节点，并以同样的方式访问它的子节点。之后，我们收集其帧的返回值，回到起始节点，并移动到下一个子节点。我们的目标是访问所有节点并返回初始帧，然后合并子帧的返回值并输出解决方案。

但是，这个图形如何帮助我们将递归函数转化为迭代函数呢？答案就在于我们刚刚描述了执行图的深度优先遍历。深度优先遍历的迭代版本使用堆栈来存储标记为要访问的节点。如果我们以与函数元素相对应的方式来实现节点和边，我们就会得到它的迭代版本。在这里，用于存储节点的堆栈扮演了 CPU 调用堆栈的角色：
<center><img src="pics/quicklatex.com-221ad280d8f92a89baf143897f37b4be_l3.svg" alt=""></center>

#### 实施细节
执行图是隐式的。这意味着我们在执行非递归代码块和进行递归调用时，会即时创建执行图。为了正确地创建执行图，我们应该按照我们正在转换的递归函数的结构来实现框架和边。

因此，应该返回与第一个未执行的 NRCB 和递归调用相关的边。它还应包含指向通过沿边得到的子帧的指针。因此，该函数应将问题划分为子问题并创建子帧。A 框架应该是一个数据结构，能够容纳其局部变量和子问题。它还应能将其返回值传递给其父框架。

如果该框架是基例框架，那么它的父框架将负责确定返回值。如果框架是一个基准节点，那么函数应返回相应的基准解决方案。如果不是，则函数应将框架从其子节点获得的返回值合并。

#### Example
让我们把递归转换成迭代：
<center><img src="pics/quicklatex.com-0a7133fb40fc8e782d2d68773fa56f37_l3.svg" alt=""></center>

##### 框架、边缘和边缘创建
在我们的例子中，我们可以这样创建一个 Python 字典：
```
def create_new_frame(n, parent, return_name):
    # create an empty frame
    frame = {
        'n' : None,
        'parent' : None,      # the parent frame
        'return_name' : None, # the return address
        'placeholders': {     # the placeholders for 
            'a' : None,   # the children's return values
            'c' : None
        },
        'local': {            # the local variables 
            'b' : None,
            'd' : None
        },
    }

    # fill in the fields
    frame['n'] = n 
    frame['parent'] = parent 
    frame['return_name'] = return_name
    return frame
```
框架的实例应与函数结合使用，以计算返回值并将其传递给框架的父节点：
```
def get_return_value(frame):
    if frame['n'] <= 1:
        # the base case
        return 1
    else:
        # the recursive case
        frame['local']['d'] = frame['placeholders']['a'] * frame['placeholders']['c']
        return frame['local']['d'] + 1

def pass_to_parent(frame, return_value):
    return_name = frame['return_name']
    frame['parent']['placeholders'][return_name] = return_value
```
在此实现中，我们不需要对边进行建模。从算法 7 中我们可以看出，一条边应该包含一个子帧（它指向的节点）和相应的 NRCB。我们可以将 NRCB 建模为一个整数，并将其作为另一个整数字段 nrcb_counter 放入帧中，在 create_new_frame 中初始化为 0，并用下面的函数进行解释：
```
def execute_nrcb(frame):
    nrcb_counter = frame['nrcb_counter']
    if nrcb_counter == 1:
        # do nothing because the NRCB
        # before the first call (f(n-1))
        # is empty
        pass
    elif nrcb_counter == 2:
        frame['local']['b'] = frame['n'] // 2	
```
我们将更新计数器，并在返回下一子帧的函数中执行相应的 NRCB：
```
def get_next_child(frame):
    # check if all the frame's NRCBs have been executed
    if frame['nrcb_counter'] >= 2:
        return None
    frame['nrcb_counter'] += 1
    execute_nrcb(frame)
    if frame['nrcb_counter'] == 1:
        child = create_new_frame(frame['n'] - 1, frame, 'a')
    else:
        child = create_new_frame(frame['placeholders']['b'], frame, 'c')
    return child
```
我们通过验证 $frame.nrcb_counter < 2$ 来测试 frame 是否有一条未访问的出站边：
```
def has_next_child(frame):
    return frame['n'] > 1 and frame['nrcb_counter'] < 2

def solve(n):
    start = create_new_frame(n, None, None)
    stack = [start]
    while len(stack) > 0:
        frame = stack.pop(-1)
        if has_next_child(frame):
            child = get_next_child(frame)
            stack.append(frame)
            stack.append(child)
        else:
            return_value = get_return_value(frame)
        if frame['parent'] is not None:
            pass_to_parent(frame, return_value)
    return get_return_value(start)
```

#### 可读性和语义
将一般的深度优先遍历算法与帧、边和相关函数的递归特定实现相结合，我们就能得到想要转换的递归函数的迭代变体。不过，由此产生的迭代代码的可读性和可理解性都不如原始的递归代码。

不过，我们还是在图中保留了一些语义。因为它体现了原始问题的递归结构，我们仍然可以对其进行解释。一个节点及其子节点代表递归的主体，而基本情况可以从没有子节点的节点中识别出来。

#### 优化和递归类型
最后，我们注意到，我们可以多次访问图中的某些节点。如果子问题重叠，就会出现这种情况，斐波那契数就是这种情况。$F_n$和$F_(n-1)$都取决于$F_(n-2)$ ，因此会被访问两次。多次访问同一节点会导致重复计算，增加复杂度。我们可以通过记住返回值来解决这个问题。每当我们计算一个节点应该返回的值时，我们就把它存储在节点中。如果我们以后访问同一个节点，我们就可以重复使用已经找到的解决方案，避免重复评估。这种技术被称为记忆化。一些作者认为它是动态编程的一种工具。

此外，执行图的形状揭示了各种递归类型之间的区别。如果递归函数的主体只进行一次递归调用，其执行图就是一条路径。如果它进行了两次调用，并且子问题没有重叠，那么得到的图将是一棵二叉树。尾递归之所以特殊，是因为它的重组阶段是一种身份操作：每个节点只转发子节点的返回值。这就是为什么我们不需要堆栈来实现迭代。

### 为什么要将递归转换为迭代
递归和迭代同样强大。任何递归算法都可以改写为使用循环。反之亦然。这意味着任何迭代算法都可以只用递归来编写。因此，如果我们必须选择使用其中一种算法，我们很可能会根据这些问题做出决定：

表现力：我们选择能使代码更简单的方法（从而减少犯错的机会）。这是为了减少测试和调试代码的时间
性能：迭代通常（但并不总是）比等效递归快。此外，迭代的时间复杂度通常是多项式对数，而递归算法的时间复杂度通常是指数。
此外，一些流行的编程语言并不支持递归。当我们试图将大量输入输入到递归算法（例如 Python）中时，几乎肯定会达到运行时的递归极限。这指的是函数可以调用自身多少次，以避免无限递归。

递归函数需要大量内存。每次递归都会使函数分配的内存量翻倍，而且数据会存储在堆栈中。堆栈的内存是有限的，如果达到这个限制，堆栈空间就会耗尽，程序就无法继续运行。

因此，了解如何将递归算法转换为迭代算法是一项重要技能。

### 将递归转换为迭代的优势
将递归函数转换为迭代函数有几个优点。让我们来了解其中的一些：

+ 提高内存效率：迭代函数使用单个栈帧，与递归函数相比内存效率更高，因为递归函数每次递归调用都会创建一个新的栈帧
+ 提高性能：迭代函数可以比递归函数更快，因为它们避免了为每次递归调用创建和销毁栈帧的开销
+ 更易于理解和维护：将尾递归函数转换为迭代函数，可以删除递归调用，从而使代码更易于理解和维护

在本文中，我们讨论了如何将递归转换为迭代。我们介绍了将任何递归函数转换为迭代函数的一般方法。此外，我们还展示了一种仅适用于尾部递归的方法。尽管转换可以提高性能，但这种方法会降低代码的可读性。

