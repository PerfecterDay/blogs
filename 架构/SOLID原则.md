# SOLID
{docsify-updated}

+ SRP: 单一职责原则
+ OCP: 开闭原则
+ LSP: 里氏替换原则
+ ISP: 接口隔离原则
+ DIP: 依赖反转原则


## SRP
SRP是五大设计原则中最容易被误解的一个。也许是名字的原因，很多程序员根据SRP这个名字想当然地认为这个原则就是指：每个模块都应该只做一件事。

在历史上，我们曾经这样描述SRP这一设计原则：**任何一个软件模块都应该有且仅有一个被修改的原因**

最终： **任何一个软件棋块都应该只对某一类行为者负责**

是我最喜欢举的一个例子：
某个工资管理程序中的Employee类有三个函数 `calculatePay()` 、`reportHours()` 和 `save()`
如你所见，这个类的三个函数分别对应的是三类非常不同的行为者，违反了SRP设计原则。
+ `calculatePay()` 函数是由财务部门制定的，他们负责向CFO汇报。
+ `reportHours()` 函数是由人力资源部门制定并使用的，他们负责向coo汇报。
+ `save()`函数是由DBA制定的，他们负责向CTO汇报。

这三个函数被放在同一个源代码文件，即同一个 `Employee`类中，程序员这样做实际上就等于使三类行为者的行为祸合在了一起，这有可能会导致CFO团队的命令影响到coo团队所依赖的功能。

<center><img src="pics/srp.png" alt=""></center>

## OCP
开闭原则(OCP)是 Bertrand Meyer 在 1988 年提出的， 该设计原则认为:
**设计良好的计算机软件应该易于扩展， 同时抗拒修改**

换句话说，一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展 。其实这也 是 我们研究软件架构的根本目的 。 如果对原始需求的小小延伸就需要对原有的软件系统进行大幅修改，那么这个系统 的 架构设计显然是失败的。

OCP 是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件 ，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。

## LSP
1988 年， Barbara Liskov 在描述如何定义子类型时写下了这样一段话 ：
这里需要的是一种 可替换性：如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2 ，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型 。
为了让读者理解这段话中所体现的设计理念，也就是里氏替换原则 LSP 。

## ISP
有多个用户需要操作OPS类。现在，我们假设这里的User1只需要使用op1,User2只需要使用op2,User3只需要使用op3。

在这种情况下，如果OPS类是用Java编程语言编写的，那么很明显，User1虽然不需要调用op2、op3，但在源代码层次上也与它们形成依赖关系。这种依赖、意味着我们对OPS代码中op2所做的任何修改，即使不会影响到User1的功能，也会导致它需要被重新编译和部署.

<center><img src="pics/isp.png" alt=""></center>

## DIP
如果想要在软件架构设计上边求稳定，就必须多使用稳定的抽象接口，少依赖多 变的具体实现 。 下面，我们将该设计原则归结为以下几条具体的编码守则：
+ 应在代码中多使用抽象接口 ， 尽量避免使用那些多变的具体实现类 。
+ 不要在具体实现类上创建衍生类。在静态类型的编程语言中，继承关系是所有一 切源代码依赖关系中最强的、最难被修改的，所以我们对继承的使用应该格外小心 。
+ 不要覆盖（ override ） 包含具体实现的函数。调用包含具体实现的函数通常就意味着引入了源代码级别的依赖 。 即使覆盖了这些函数，我们也无法消除这其中的依赖一一这些函数继承了那些依赖关系。在这里，控制依赖关系的唯一办法，就是创建一个抽象函数，然后再为该函数提供多种具体实现。
+ 应避免在代码中写入与任何具体实现相关的名字 ， 或者是其他容易变动的事物的名字 。


<center><img src="pics/solid.jpg" width="80%"></center>
