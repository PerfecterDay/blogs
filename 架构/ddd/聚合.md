# 聚合
{docsify-updated}

迪米特法则（Law of Demeter，LOD）可以帮助设计聚合根的行为方法。一个对象（聚合根）的行为方法只应该调用下面这些对象（聚合边界内的对象）的行为方法。

1. 可以调用这个对象内部的其他行为方法。
2. 行为方法有输入参数，那么输入参数涉及对象的方法也是可以被调用的。
3. 创建对象自己或初始化时涉及其他对象的方法，构造函数中涉及的其他对象，这些对象的方法也是可以被调用的。
4. 它的直接子对象的行为方法，例如聚合根可以调用被聚合根引用的其他对象的方法。

### 原则：在一致性边界之内建模真正的不变条件
对于一个典型的持久化机制来说，我们通常使用单事务 2 来管理一致性。在提交事务时，边界之内的所有内容都必须保持一致。对于一个设计良好的聚合来说，无论山于何种业务需求而发生改变，在单个事务中，聚合中的所有不变条件都是一致的。而对于一个设计良好的限界上下文来说，无论在哪种情况下，它都能保证在一个事务中只修改一个聚合实例。此外，在设计聚合时，我们必须将事务分析也留虑在内。

在一个事务中只修改一个聚合实例，这听起来可能过于严格。但是，这却是设计聚合的重要经验原则，也是我们为什么要使用聚合的原因。

### 原则：设计小聚合
考虑亠．下系统性能和可伸缩性，假定一个存在了1年多的敏捷项目，其中已经包含有数以千计的待定项，如果一个租户的某个用户只是需要将一个待定项添加到产品中，会发生什么情况？假设我们使用了延迟加载的持久化机制（比如llibernate) ，我们几乎不用同时加载待定项、发布和冲刺。但是，为了添加一个待定项，我们依然需要先将所有的待定项集合元素加载到内存里，而这个数目是巨大的。对于那些不支持延迟加载的持久化机制来说，问题就更糟了。即便我们将内存使用考虑在内，有时我们仍然需要加载多个集合，比如将某个待定项加人到发布中，或者将某个待定项提交到冲刺中。此时，所有的待定项、发布或冲刺都需要加载进内存。

对象之间的关联数目几乎不可能为 0 ，并且还会随着时间不断增加。为了完成一项基本的操作，我们可能需要将成百上千个对象一同加载进内存中，而这只是一个租户中的一个团队成员操作一个产品的情况。 ProjectOva n 将拥有成百上千的租户，每个租户都有多个团队和多个产品。随着时间的增加，这种情况将变得更糟。

如果我们要设计小的聚合，那么，这里的“小”是什么意思呢？最极端的情况是，一个聚合只拥有全局标识和单个属性，当然，这并不是我们所推荐的做法（除非这正是需求所在）。好的做法是，使用根实体（ Root Entity) 来表示聚合，其中只包含最小数量的属性或值类型属性。这里的“最小数量"表示所需的最小属性集合，不多也不少。

### 原则：通过唯一标识引用其他聚合

<center><img src="pics/ddd-5.png" width="40%"></center>

在上例中，一个 Backlogltem 直接关联了一个 Product0结合前文已经讨论的和接下来即将讨论的，以上实现方式隐含着以下几点：
1. 引用聚合 (Backlog1tem) 和被引用聚合 (Product) 不可以在同一个事务中进行修改。
2. 如果你试图在单个事务中修改多个聚合，这往往意味着此时的一致性边界是错误的。发生这样的情况通常是因为我们遗漏了某些建模点，或者尚未发现通用语言中的某个概念。
3. 如果你试图采用第 2 点，但却遇到了先前所讲的有关大聚合的种种麻烦，那么此时你可能需要使用最终一致性（请参考本章后续章节），而不是原子一致性。

<center><img src="pics/ddd-6.png" width="30%"></center>


### 原则：在边界之外使用最终一致性
在[ Evans ]对聚合模式的定义中，有一条经常被忽略。如果单次用户请求需要修改多个聚合实例，而此时我们又需要保证模型的一致性时，这一条便非常重要了：
任何跨聚合的业务規则都不能总是保持处于最新状态。通过事件处理、扯处理或者其他更新杌制，我们可以在一定时间之内处理好他方依赖。 

因此，当在一个聚合上执行命令方法时，如果还需要在其他的聚合上执行额外的业务规则，那么请使用最终一致性。在一个人规模、高吞吐量的企业系统中，要使所有的聚合实例完全一致是不可能的。认识到这一点，你便知道在较小规模的系统中使用最终一致性也是有必要的。
