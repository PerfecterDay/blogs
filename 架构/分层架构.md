# 分层架构
{docsify-updated}

## DDD
```
com.example.project
 ├── api
 │    ├── controller    // WebFlux MVC/REST API
 │    ├── dto           // 入参出参的 DTO
 │    └── advice        // RestControllerAdvice、ExceptionHandler
 ├── application
 │    ├── service       // 应用服务（用例服务）
 │    ├── command       // Command 对象（输入）
 │    └── query         // Query 对象（查询输入）
 |    |__ event         // 应用事件
 ├── domain
 │    ├── model         // 领域实体（Entity, AggregateRoot）
 │    ├── service       // 领域服务
 │    ├── repository    // 仓储接口（Repository Interface）
 │    └── event         // 领域事件
 ├── infrastructure
 │    ├── persistence   // JPA/Mybatis 实现、DAO 实现
 │    ├── gateway       // RPC 调用、RestTemplate/WebClient
 │    ├── config        // Spring 配置、Bean、AOP、Filter 
 │    ├── properties    // PO <-> Entity 转换  
 │    └── converter     // @ConfigurationProperties 类 
 └── bootstrap
      └── ProjectApplication.java
```

### API/Controller 层
```
com.example.project.api
 ├── controller         // WebFlux MVC/REST API
 ├── dto                // 入参出参的 DTO
 └── advice             // RestControllerAdvice、ExceptionHandler
```

只做三件事：
+ 参数接收 & 校验
+ DTO ↔ Command/Query 转换
+ 调用 application 层

禁止：
+ 写业务逻辑
+ 操作数据库
+ 调用 Feign / Kafka


### application 层
```
com.example.project.application
 ├── service            // 应用服务（用例服务）
 ├── command            // Command 对象（输入）
 ├── query              // Query 对象（查询输入）
 └── event              // 应用事件
```

负责：
+ 业务流程编排
+ 事务控制
+ 跨领域协作

```
@Service
public class OrderAppService {

    @Transactional
    public void create(CreateOrderCmd cmd) {
        Order order = orderFactory.create(cmd);
        orderRepository.save(order);
        paymentService.freeze(order);
    }
}
```

### domain 层（核心）
```
com.example.project.domain
 ├── model             // 领域实体（Entity, AggregateRoot）
 ├── service           // 领域服务
 ├── repository        // 仓储接口（Repository Interface）
 ├── event             // 领域事件
 └── exception         // 领域异常
```

+ 纯 Java
+ 不依赖 Spring
+ 不依赖数据库

### infrastructure 层
```
com.example.project.infrastructure
 ├── persistence            // JPA/Mybatis 实现、DAO 实现
 ├── gateway                // RPC 调用、RestTemplate/WebClient
 ├── config                 // Spring 配置、Bean、AOP、Filter
 ├── converter              // PO <-> Entity 转换
 ├── properties             // @ConfigurationProperties 类
 └── external               // 调用外部系统的 Client 封装
```

主要负责：
+ 数据库
+ MQ / RPC / 缓存
+ 第三方 SDK


### bootstrap 层
```
com.example.project.bootstrap
 ├── ProjectApplication.java
 └── initializer          // 启动初始化器（数据加载、RouteLoader等）
```

## 普通MVC架构
```
com.xxx.project
 ├─ ProjectApplication
 ├─ controller        接口层
 ├─ service           业务层
 ├─ repository        持久层
 ├─ client            远程调用层
 └─ common             公共能力
```


## 是否需要在 Service 和 Mapper 中加加一个 DAL 层
**为什么要用 DAL 层操作多个 Mapper？(推荐做法)**

当你的业务逻辑不仅仅是简单的“查单表”时，引入一个中间的 DAL 层（通常称为 Repository）来封装多个 `Mapper` 是更好的选择。

1. 数据聚合 (Aggregation)
   如果业务需要的一个数据对象（Domain Object）的数据来源分布在不同的数据库表中，你需要调用多个 Mapper。

   场景： 查询“用户信息”以及该用户的“最新订单”。

   `Repository` 的做法：
      1. 调用 `UserMapper.selectById(userId)` 。
      2. 调用 `OrderMapper.selectLatestByUserId(userId)`。
      3. 将这两个结果组装成一个 `UserDetailBO` 或 `UserAggregate` 返回给 `Service` 。

   好处： `Service` 层只需要调用 `userRepository.getUserDetail(id)` ，它不需要关心数据是来自一张表还是两张表，也不需要关心你是怎么组装的。

2. 屏蔽底层差异
   有时候数据不仅仅来自 Database（Mapper），可能一部分来自 Redis，一部分来自 Mapper。

   `Repository` 的做法： 先查 Redis，没命中再查 Mapper，然后回写 Redis。

   好处： 对 `Service` 层透明， `Service` 层只管要数据，不用管数据是缓存里的还是数据库里的。

3. 防止 Service 层膨胀
   如果 `Service` 层直接操作多个 `Mapper` ，`Service` 代码会充斥着大量的数据组装代码（Set/Get），导致真正的业务逻辑（如状态判断、计算、流转）被淹没。

**并非所有项目都需要额外封装一层 DAL/Repository。**

场景： 你的项目主要是简单的 CRUD（增删改查），或者是后台管理系统。  
做法： `Service` 直接调用 `Mapper` 。

理由： 这种情况下， `Mapper` 和 `Service` 几乎是一一对应的。强行加一个 `Repository` 层只会变成“透传”（Repository 的方法里只有一行代码：`return mapper.select()`），这属于**过度设计**，增加了代码量但没有增加价值。