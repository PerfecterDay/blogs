# 接口设计
{docsify-updated}

> https://mp.weixin.qq.com/s/svKteAaS-MCyIrYMcWPBIA

之前我们总结了数据模型的设计：[一篇文章彻底掌握数据模型设计](https://mp.weixin.qq.com/s?__biz=MzU0Nzg4Nzk0OQ==&mid=2247483888&idx=1&sn=48ffbec8ba598897569a56fd862b78b4&scene=21#wechat_redirect)。这一次我们补齐系统设计另外一块重要拼图：接口设计。

好的接口设计，不仅能灵活的支撑业务变化，还能保证极高的交付效率和系统稳定性。下面我们从
+ 设计原则
+ 命名与方法
+ 出入参
+ 返回码
+ 安全
+ 设计模板

六个方面，详细讲述下接口设计应该考虑哪些点。

## 设计原则
###  接口隔离
+ 前端调用(app)
+ 外部调用(Ayers)
+ 系统间调用(NRTS)

这三者接口**需要完全隔离，\*\***严禁\***\*复用。从工程包路径到接口类再到接口和出入参实体都要分开，如果底层service逻辑一样，可以复用service。**

### 何时添加新接口 vs 何时复用现有接口

|维度|应该新增接口 | 应该复用接口|
| --|--------| ------------ |
| **业务语义** | 业务概念完全不同 | 同一业务概念的不同操作 |
| **变更频率** | 变化原因和节奏不同 | 变化原因和节奏相同 |
| **安全要求** | 需要不同的认证/授权策略 | 安全要求相同 |
| **性能特征** | QPS、响应时间要求差异大 | 性能特征相似 |
| **调用方** | 被不同的客户端调用 | 被相同的客户端调用 |

## 命名与方法

### 命名规范
1. 接口路径命名规范

- **使用小写字母**：路径全部使用小写字母。
- **使用连字符分隔**：多个单词之间使用连字符（-）分隔，例如 `/api/user-profiles` 。
- **使用复数形式**：资源集合使用复数形式，例如 `/users` 而不是 `/user` 。
- **避免动词**：资源路径使用名词，操作通过HTTP方法表示。特殊情况（如无法用HTTP方法表示的操作）可以使用动词，例如 `/users/{id}/activate` 。
- **层级关系**：资源之间的层级关系使用嵌套路径，例如 `/users/{userId}/orders` ，但最好嵌套不要超过两层。
- **前端调用、外部调用和系统间调用，这三者接口需要隔离**，路径格式分别为：
  - 前端调用：路径前加web前缀，如 `web/xxx/xxx` ，`/web/users/{userId}/orders` ；
  - 外部调用：`external/xxx/xxx`，`/external/users/{userId}/orders`；
  - 系统间调用：`internal/xxx/xxx`，`/internal/users/{userId}/orders`（适用于系统间调用也采用http调用方式）；
- **版本控制**：路径区分接口版本，格式如下： `web/v1/xxx/xxx` ， `external/v2/xxx/xxx` ；

2. 参数命名规范
- **使用小驼峰** ：实体中的单个参数使用小驼峰命名，如 `userId` 。
- **JSON字段** json字段中的参数使用小驼峰或下划线分隔，与团队约定统一。例如 `firstName` 或 `first_name` 。
- **查询参数** ：url中查询参数使用小驼峰或下划线，保持统一。例如 `createdAt=2023-01-01` 或 `created_at=2023-01-01` 。
- **路径参数** ：与查询参数风格一致，例如 `/users/{userId}` 。

### 方法选择
安全风险：

- DELETE方法风险：若未实施严格的权限验证，攻击者可能利用此方法删除业务数据或系统文件，导致服务瘫痪。即使配置了权限控制，误操作风险也远高于其他方法。
- TRACE方法隐患：会回显客户端发送的请求内容（包括Cookie Authorization等敏感头信息），攻击者可通过恶意脚本窃取会话凭证，绕过HttpOnly保护。
- CONNECT方法滥用：若服务器错误配置，允许对任意目标发起CONNECT请求，可能被用作开放代理跳板，隐藏攻击者真实IP进行内网渗透。
- PUT方法风险：虽然常用于更新资源，但若路径控制不严，可能被上传恶意文件（如Webshell）导致服务器被控。

原则上业务系统只允许使用**GET、POST两**种方法类型，如果要使用**PUT**方法类型，一定要带id，使用id更新资源（很多金融类企业是禁用PUT方法的）。禁止使用**PATCH、DELETE、HEAD、TRACE、CONNECT**方法。避免引入不必要的安全风险。这虽然破坏了restful设计理念，但是相比更可靠的安全保障，舍弃这些无关痛痒的理念是有必要的，因为它只是给你带来可读性的提升。

## 出入参设计
+ **嵌套层级**：出入参对象嵌套层级**不允许超过3层**。
+ 列表要**分页**：列表查询，不论当前条件下，查询出的数据量是否会超过每页数量，入参一定要有默认分页参数和默认值（pageNum，pageSize）。
+ **入参必带公共字段**：入参必须带requestId（如果是接入了skywalking等链路追踪组件，会自动帮你把请求链路唯一id塞入head，此时无需显示传入requestId，但是针对提供给外部调用的接口，还是应该要求显示传入和timestamp。
+ 出参必带**公共基础字段**：除文件下载外，任何接口出参都必须带上标准的系统返回码和返回消息和链路id，即resultCode（code），resultMsg（message），requestId（即traceId)。
+ 为每个接口定义专用的请求和响应**DTO，避免使用领域实体(domain)和数据库实体(PO)直接作为参数**。
+ **使用包装类型，而不是基本类型**，因为基本类型有默认值，可能干扰实际传参。
+ 字符串类型用于文本数据传输，需要明确**限制长度**，一些特定属性，使用正则表达式**验证格式**，如号码，邮箱等。
+ 数值类型：对于金额等精确计算，使用BigDecimal。对于整数，根据范围选择Integer或Long。
+ **禁止使用枚举类型**，使用字符串或者整数表示。
+ 日期和时间使用ISO-8601格式的字符串（如"2023-10-27T10:30:00Z"）或时间戳（毫秒数）来表示日期和时间。在DTO中使用 `LocalDateTime`、`LocalDate`或`String`，并配合注解进行格式验证。
+ 集合类型：使用`List`、`Set`等集合类型，需要初始化，**禁止无数据情况下返回null**。
+ **禁止使用Map作为请求参数**，因为这样会失去参数验证和文档生成的能力。

## 返回码设计
+ **业务系统需要定义维护好系统返回码，并在接口文档中明确列出。返回码\*\***以系统名大写开头，共八位\*\*。
+ 成功返回码：所有系统统一为**COM00000**；
+ 系统异常返回码：即非受检异常，所有系统统一为**COM99999**；
+ 系统业务返回码规范：
  - 系统名开头，后面跟五位数字，前两位数字代表业务模块码值，后三位数字代表该业务模块定义的各类异常码值。以PLS生产物流系统举例：物流管理模块码值为10，其中业务功能”保存外运单“参数校验不通过，则码值可以组合为**PLS10001**。 
  - 系统所有的受检异常，业务链路异常，都需要明确定义出系统返回码。

## 安全设计
### 认证
前端调用和外部调用接口都必须做认证，内部系统间调用可不做认证。各类认证方案如下:
#### API Key / Secret
适用场景: 服务端对服务端的调用，例如微服务之间的内部通信，第三方服务集成。
工作原理: 
- 每个客户端被分配一个唯一的API Key和对应的Secret。
- 客户端在请求时，将API Key放在明文中（例如HTTP Header），并使用Secret对请求内容生成**签名**（Signature）。
- 服务端根据API Key找到对应的Secret，使用同样的算法生成签名，并与客户端传来的签名对比，一致则通过认证。

**优点**：
- 简单易用，适合自动化服务。
- 可以结合其他安全措施（如IP白名单）提高安全性。

**缺点**：
- 如果Secret泄露，攻击者可以伪造请求。
- 需要确保Secret的安全存储和传输。

#### OAuth 2.0

适用场景：第三方应用授权访问用户资源，例如使用微信、微博登录，授权第三方应用访问自己的资源。
工作原理：
- OAuth 2.0定义了四种授权模式：授权码模式（Authorization Code）、隐式模式（Implicit）、密码模式（Resource Owner Password Credentials）和客户端模式（Client Credentials）。
- 最常用的是授权码模式，流程如下：
1. 第三方应用引导用户到授权服务器。
2. 用户授权后，授权服务器返回一个授权码（Authorization Code）给第三方应用。
3. 第三方应用使用授权码向授权服务器交换访问令牌（Access Token）。
4. 第三方应用使用Access Token访问资源服务器的资源。

**优点：**
- 广泛使用，标准化。
- 支持第三方应用，用户无需将密码提供给第三方。

**缺点**：
- 实现相对复杂。


#### JWT
**适用场景**：无状态分布式系统，单点登录（SSO）。
**工作原理**：
- 用户登录后，服务器生成一个JWT（包含用户信息、过期时间等），并用自己的私钥签名。
- 客户端在后续请求中携带JWT（通常在HTTP Header的Authorization字段中）。
- 服务端验证JWT的签名和有效性，从而认证用户身份。

**优点**：
- 无状态，服务端不需要存储会话信息。
- 可以跨域使用，适合分布式系统。

**缺点**：
- 一旦签发，在有效期内一直有效，无法中途撤销（除非服务器实现黑名单机制）。
- 负载大小限制，不宜存储过多信息。

#### Session-Cookie
**适用场景**：传统的Web应用，用户通过浏览器登录。
**工作原理**：
- 用户登录后，服务器创建Session，并将Session ID通过Cookie返回给浏览器。
- 浏览器在后续请求中自动携带Cookie（包含Session ID）。
- 服务器通过Session ID查找Session，从而认证用户身份。

**优点：**
- 成熟，易于实现。
- 可以方便地存储用户状态。

**缺点**：
- 状态保存在服务端，不利于分布式系统（需要Session共享机制）。
- 跨域问题。

#### 双向TLS(mTLS)
**适用场景**：对安全要求极高的服务间通信，例如金融、政府等领域。
**工作原理**：
- 在TLS握手过程中，不仅服务器向客户端提供证书，客户端也要向服务器提供证书。
- 服务器验证客户端的证书，确保客户端是可信的。

**优点**：

- 高安全性，防止中间人攻击。
- 适合微服务架构中的内部通信。

**缺点**：
- 证书管理复杂，需要维护PKI。

### 授权

#### 资源权限
- **权限控制方式：需要在权限平台为角色岗位配置资源权限，前端需要进入页面时查询用户的权限，展示对应资源。**
- **最小权限原则：用户只拥有完成其任务所必需的最小资源权限。**
- **基于角色的访问控制（RBAC）：定义角色和权限，为用户分配角色。**
- **细粒度授权：对于敏感操作，除了角色检查，还应进行资源级别的权限验证。**

#### 数据权限
- **权限控制方式：同样可由权限平台控制，在权限平台配置好数据类别和角色规则。业务系统拦截请求，调用权限平台接口，获取岗位角色数据权限。**
- **一定确保用户只能访问自己角色范围内的数据，严禁敏感业务数据查询不经过数据权限控制。**

### 加密
1. **通道加密（防止中间人攻击）**：所有接口都必须采用**HTTPS**， **禁止**HTTP，防止数据在传输过程中被篡改。使用**TLS 1.2**及以上版本。
2. 加签验签（防数据篡改）：外部暴露接口或安全要求高的场景（如交易支付），需要额外做数据加密和加签验签。对请求数据+盐值（可以是商议好的算法）计算摘要，再用私钥对摘要加密生成签名。接收方重新对这些数据以同样的方式计算摘要，再使用公钥解密签名，比对摘要一样说明没有篡改。为什么需要对传输数据做加签验签？因为通常HTTPS只是能保证客户端到证书所在服务器的链路安全。但是证书服务器到应用服务器是没有通道加密的，同时中间人攻击，它也可以与客户端和真实服务端分别建立连接，这样就有数据被篡改的风险。为什么需要加盐值？因为摘要算法有一致性的特点，相同数据多次计算的摘要是相同的。利用这个特性，攻击者可以预先生成一系列简单数据的摘要，并存储 “摘要 - 数据” 的映射，这个映射关系就是彩虹表。在获取到数据摘要后，如果发现摘要存在彩虹表中，就可以轻易地反推出原始数据。
3. 数据加密：同样是针对外部暴露接口或安全要求高的场景（如交易支付），需要额外的数据加密。为什么通道加密了还需要额外的数据加密？这里区别于https通道加密，HTTPS在数据传输过程中是加密的，可以有效防止中间人拦截。但是HTTPS在两端（客户端和服务端）是明文显示的，因为SSL会自动解析对称加密的数据内容，在浏览器中可以看到这些接口的请求参数和返回值，通过自己调用接口的方式一样可以进行攻击操作。所以我们需要区分中间人攻击和模拟攻击，如果在应用程序层自己再加密一层，浏览器也无法显示请求和返回的数据内容，这会增加模拟攻击的难度，同时也能避免证书所在的暴露公网的主机攻破时，数据被窃取（因为通道加密的密文是在这里被解密的）。
4. 敏感字段脱敏：接口返回的数据需要对敏感数据（如手机号、邮箱、身份证号、银行卡号）进行脱敏处理。

### 其他安全措施
+ **不返回敏感信息**：错误信息不应包含系统内部细节（如数据库错误、堆栈跟踪）。
+ 防止重放攻击：唯一交易流水号（服务端生成）、验证时间戳（客户端的请求时间戳跟服务端的时间戳比较，超过允许的范围，拒绝请求）、请求序号（维护一个当前最大值序号，当请求序号不连续（过大或过小），拒绝请求）；
+ 接口紧急下线：针对安全风险事件，网关需支持针对指定接口做下线，请求不再转发到后台应用。
+ 收缩暴露接口：避免暴露不必要的接口，对于不使用的接口及时关闭。

## 设计模版

### 文档基本信息

| 项目 | 说明 |
|--| ------ |
| **接口名称** | 用户管理服务 API |
| **版本** | v2.1.0 |
| **最后更新** | 2024-01-15 |
| **文档维护者** | 后端架构组 - 张三 |
| **服务负责人** | 李四 |

### 接口基础信息
1. 服务端点

    基础URL: https://api.company.com/user-service/api/v2
    环境说明:
    - 生产环境: https://api.company.com/user-service/api/v2
    - 测试环境: https://api-test.company.com/user-service/api/v2
    - 开发环境: https://api-dev.company.com/user-service/api/v2

2. 通用约定

请求头:
```
Content-Type: application/json; charset=utf-8
Authorization: Bearer {access_token}
X-Request-ID: {request_id}
X-Client-Version: 2.1.0
X-Client-Platform: iOS/Android/Web
```
响应格式:
  成功: HTTP 200 + `BaseResponse<T>`
  失败: HTTP 4xx/5xx + `ErrorResponse`

字符编码: UTF-8
时间格式: ISO 8601 (yyyy-MM-dd'T'HH:mm:ss.SSS'Z')

3. 通用响应结构
```
// 成功响应示例
{
  "success": true,
  "code": "SUCCESS",
  "message": "操作成功",
  "data": {
    // 业务数据
  },
  "timestamp": "2024-01-15T10:30:00.000Z",
  "requestId": "REQ_20240115103000_123456"
}
```