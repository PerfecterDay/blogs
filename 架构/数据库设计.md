# 数据库表设计指南
{docsify-updated}

设计一个高效、可靠的数据库表是构建任何应用系统的基础。一个优秀的设计应满足 **数据完整性、查询效率** 和 **维护灵活性**。

## 数据库表设计基本流程

### 明确需求 (Requirements Gathering)

在开始设计前，必须清晰地定义系统要管理的核心数据和业务逻辑。

* **核心实体：** 系统需要管理哪些主要对象（如用户、商品、订单、文章）？
* **数据属性：** 每个实体需要包含哪些具体的字段信息？
* **业务关系：** 实体之间如何相互关联和作用？

### 实体关系模型 (ERD - Entity-Relationship Diagram)

将业务需求抽象为实体关系模型，明确实体间的连接方式：

| 关系类型         | 描述                                                     | 示例                                |
| :--------------- | :------------------------------------------------------- | :---------------------------------- |
| **一对一 (1:1)** | 一个实体最多与另一个实体的一个实例相关联。               | 用户 $\leftrightarrow$ 详细配置文件 |
| **一对多 (1:N)** | 一个实体可与多个实例相关联，但另一个实体只能与一个关联。 | 部门 $\leftrightarrow$ 多个员工     |
| **多对多 (N:M)** | 两个实体中的任何一个都可以与另一个的多个实例相关联。     | 学生 $\leftrightarrow$ 多门课程     |

### 表结构设计与范式化 (Normalization)

将 ERD 转化为表结构，并通过范式化来减少数据冗余和提高数据一致性。

| 范式 (NF)          | 核心目标         | 作用                                 |
| :----------------- | :--------------- | :----------------------------------- |
| **第一范式 (1NF)** | **原子性**       | 确保每列都是不可分割的原子值。       |
| **第二范式 (2NF)** | **消除部分依赖** | 非主键列必须完全依赖于整个复合主键。 |
| **第三范式 (3NF)** | **消除传递依赖** | 非主键列之间不应存在依赖关系。       |

> ** 注意：** 大多数应用设计到 **3NF** 即可。为了优化查询性能，有时会进行适度的 **反范式化 (Denormalization)**。

#### 第一范式 (1NF)
在讨论 2NF 和 3NF 之前，必须先满足 1NF。

* **定义：** 数据库表中的每一列都必须是**原子性的（不可再分割的）**。
* **目的：** 消除重复组，确保数据表的结构化。

#### 第二范式 (2NF)
2NF 主要关注的是**复合主键**与**非主键列**之间的关系。

定义：一个表如果满足 1NF，并且所有**非主键列**都**完全依赖**于**整个主键**，那么它就满足 2NF。

> 核心问题：消除**部分函数依赖**（Partial Dependency）。

##### 示例：不满足 2NF 的情况

假设有一个复合主键的订单商品表：

| (订单 ID, 商品 ID) (复合主键) | 商品名称    | 订单金额 |
| :---------------------------- | :---------- | :------- |
| (1001, P01)                   | MacBook Pro | 5000     |
| (1001, P02)                   | iPhone      | 5000     |
| (1002, P01)                   | MacBook Pro | 8000     |

* 问题所在：
* `商品名称` **只依赖于** `商品 ID`（主键的一部分）。
* `订单金额` **只依赖于** `订单 ID`（主键的一部分）。

##### 解决方案 (达到 2NF)
将表拆分，消除部分依赖：

**表 A: 订单表**

| 订单 ID (主键) | 订单金额 |
| :------------- | :------- |
| 1001           | 5000     |
| 1002           | 8000     |

**表 B: 商品信息表**

| 商品 ID (主键) | 商品名称    |
| :------------- | :---------- |
| P01            | MacBook Pro |
| P02            | iPhone      |

---

#### 第三范式 (3NF)
3NF 是在 2NF 的基础上，进一步消除**非主键列之间**的依赖关系。

定义：一个表如果满足 2NF，并且所有**非主键列**之间不存在**传递函数依赖**，那么它就满足 3NF。

> 核心问题： 消除**传递函数依赖**（Transitive Dependency）。

##### 示例：不满足 3NF 的情况

假设有一个员工信息表（主键为 `员工 ID`）：

| 员工 ID (主键) | 员工姓名 | 部门名称 | 部门电话 |
| :------------- | :------- | :------- | :------- |
| E001           | 张三     | 市场部   | 555-1234 |
| E002           | 李四     | 研发部   | 555-5678 |
| E003           | 王五     | 市场部   | 555-1234 |

* **依赖链条：** `员工 ID` $\rightarrow$ `部门名称` $\rightarrow$ `部门电话`
* **问题所在：** 非主键列 `部门电话` 依赖于另一个非主键列 `部门名称`，当市场部的电话变更时，我们需要更新所有属于市场部的员工记录，造成数据冗余和更新异常。

##### 解决方案 (达到 3NF)

将表拆分，消除传递依赖：

**表 A: 员工表**

| 员工 ID (主键) | 员工姓名 | 部门名称 (外键) |
| :------------- | :------- | :-------------- |
| E001           | 张三     | 市场部          |
| E002           | 李四     | 研发部          |
| E003           | 王五     | 市场部          |

**表 B: 部门表**

| 部门名称 (主键) | 部门电话 |
| :-------------- | :------- |
| 市场部          | 555-1234 |
| 研发部          | 555-5678 |


### 确定字段属性 (Defining Columns)

为每个字段选择合适的类型和添加必要的约束。

* **数据类型：** 选择最能精确表达数据且占用空间最小的类型（例如：`INT`, `VARCHAR(255)`, `DATETIME`）。
* **约束：**
  * 主键 (Primary Key): 唯一标识一行数据，通常使用自增 ID (INT 或 BIGINT) 或 UUID。
  * 外键 (Foreign Key): 建立表与表之间的关系，保证引用数据的完整性。
  * 非空 (NOT NULL): 确保该字段必须有值。
  * 唯一 (UNIQUE): 确保该字段的值在表中是唯一的（例如：用户邮箱）。
  * 默认值 (DEFAULT): 设定字段未被显式赋值时的默认值。

## 关键设计原则与最佳实践

| 原则             | 说明                                                    | 最佳实践示例                                                                |
| :--------------- | :------------------------------------------------------ | :-------------------------------------------------------------------------- |
| **单一职责**     | 每个表应只负责存储一个核心实体的信息。                  | 将用户基本信息和用户登录日志分开存储在不同表中。                            |
| **数据类型优化** | 使用最准确、最紧凑的数据类型，避免使用过于宽泛的类型。  | 状态/标志使用 `TINYINT(1)` 或 `BOOLEAN`。                                   |
| **索引设计**     | 为经常用于 `WHERE`、`JOIN` 和 `ORDER BY` 的列创建索引。 | 为外键、用户名、创建时间等字段添加索引。 **(索引能提升查询，但会降低写入)** |
| **时间字段**     | 统一记录数据的创建和更新时间，便于跟踪和审计。          | 包含 `created_at` (创建时间) 和 `updated_at` (更新时间)。                   |
| **多对多关系**   | 必须通过创建一个独立的 **中间表** (或称连接表) 来处理。 | `Book` 和 `Author` 通过 `Book_Author` 表连接。                              |