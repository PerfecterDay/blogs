#  装饰者模式
{docsify-updated}

- [装饰者模式](#装饰者模式)
	- [实例分析](#实例分析)
	- [装饰者模式解决方案](#装饰者模式解决方案)
	- [Java IO 的装饰者模式](#java-io-的装饰者模式)
	- [与代理模式的区别](#与代理模式的区别)


设计原则：开放-关闭原则
类应该对拓展开放，对修改关闭。我们的目标是允许类容易拓展，在不修改现有代码的情况下，就可以搭配新的行为。如果能实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。


### 实例分析
假设有一家咖啡店的收银系统，定义了 `Beverage` 抽象类代表各种饮料，下边有许多咖啡类继承自该类：
<center><img src="pics/beverage.png" alt=""></center>
购买咖啡时也可以要求在其中加入各种调料，如：蒸奶、豆浆、摩卡或者奶泡，不同调料价格不同，所以订单系统需要考虑这些调料部分，如何设计呢？  

1. 将所有的咖啡和调料组合（因为有可能加多种调料，所以并不是两两组合），创建新的类，每个类定一个价格。这样做的话，会有无穷的类需要维护，而且如果加上一种新的调料或者咖啡，需要创建大量的类；另外，如果某个调料价格调整，需要修改大量类
2. 第二种方案，修改 `Beverage` 基类，添加多个实例变量来代表每一种调料是否添加了，然后在 `cost()` 方法根据实例变量状态动态计算价格。这样做的话，当有新的调料加入时，我们就需要修改`Beverage`基类添加新的实例变量并修改 `cost()` 方法,而且万一顾客需要双倍调料时，该设计也无法应对。

### 装饰者模式解决方案
装饰者模式动态地将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的替代方案。
1. 装饰者和被装饰者对象有相同的超类型
2. 可以用一个或多个装饰者包装一个对象。
3. 既然装饰者和被装饰者对象有相同的超类型，所以任何需要原始包装对象的场合，都可以用装饰过的对象替代它
4. 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，已达到特定的目的
5. 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。

<center><img src="pics/plantuml/decorator-pattern.png" alt=""></center>

星巴兹饮料的订单系统设计：
<center><img src="pics/coffee.png" alt=""></center>

使用这种模式，我们能弹性地组合各种咖啡和调料：
```
Beverage a = new Decaf(new Mocha(new Soy(new Whip(new Milk())))); //加 whip/soy/mocha/milk 的 Decaf
Beverage b = new Espresso(new Milk(new Milk())); //双倍奶 Espresso
```

### Java IO 的装饰者模式
<center><img src="pics/java-io.png" alt=""></center>

### 与代理模式的区别
对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。他们之间的边界确实比较模糊，两者都是对类的方法进行扩展，具体区别如下：

1. 装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。
	```
	Beverage a = new Decaf(new Mocha(new Soy(new Whip(new Milk())))); //加 whip/soy/mocha/milk 的 Decaf,装饰后还是 Decaf
	Beverage b = new Espresso(new Milk(new Milk())); //双倍奶 Espresso ，还是 Espresso
	```
2. 装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；
3. 装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；