# 策略模式
{docsify-updated}

**策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。**


初版：
<center><img src="pics/plantuml/strategy-pattern-1.png" alt=""></center>


新需求： 需要为 `Duck` 类添加飞行的行为。

### 设计方案1-使用继承
修改 `Duck` 类，添加 `fly()` 方法，然后所有的鸭子都会继承 `fly()` 方法。
<center><img src="pics/plantuml/strategy-pattern-2.png" alt=""></center>

这种方案的缺点是：不是所有的鸭子都会飞且呱呱叫的，所以如果这样改，需要检查系统内已经存在的所有子类，**根据具体情况去覆盖 fly() 方法**。而且，如果后续加入新的子类如诱饵鸭，既不会叫也不会飞，需要同时覆盖这两种方法。

### 设计方案2-使用接口
将飞行和叫抽象成两个接口：`Flyable` 和 `Quackable`，只有会飞的鸭子才会实现 `Flyable`，只有会叫的鸭子才实现 `Quackable`。
<center><img src="pics/plantuml/strategy-pattern-3.png" alt=""></center>

这种方案的缺点是：`Flyable` 和 `Quackable` 中的飞行策略和叫策略代码无法共享，假如有48个子类都要覆盖两个方法，而且飞行和叫的代码都是一样的，他们也无法复用这部分代码，因为具体实现是分散在各个子类中的。如果这样改，就需要修改系统中的所有子类，根据实际情况去决定是否实现这两个接口。但是代码无法共享。

### 设计方案3-策略模式
设计原则：
1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2. 针对接口编程而不是针对实现编程。
3. 多样组合少用继承

我们知道 Duck 类的 fly() 和 quack() 会随着鸭子的不同而改变。  
为了要把这两个行为从 Duck 类中分开，我们将把它们从 Duck 类中取出来，建立一组新类来代表每个行为。我们利用接口来代表每个行为： FlyBehavior 和 QuackBehavior 。

鸭子类不会负责实现这两个接口，我们会针对两个接口创建一些特定的实现的行为类。鸭子现在会将飞行和呱呱叫的动作委托给这两个接口的实现去处理，而不是使用定义在 Duck 类或子类的方法来处理。

<center><img src="pics/plantuml/strategy-pattern-4.png" alt=""></center>
