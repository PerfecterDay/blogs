# 装饰者模式
{docsify-updated}

设计原则：开放-关闭原则
类应该对拓展开放，对修改关闭。我们的目标是允许类容易拓展，在不修改现有代码的情况下，就可以搭配新的行为。如果能实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。


#### 实例分析
假设有一家咖啡店的收银系统，定义了 `Beverage` 抽象类代表各种饮料，下边有许多咖啡类继承自该类：
<center><img src="pics/beverage.png" alt=""></center>
购买咖啡时也可以要求在其中加入各种调料，如：蒸奶、豆浆、摩卡或者奶泡，不同调料价格不同，所以订单系统需要考虑这些调料部分，如何设计呢？  

1. 将所有的咖啡和调料组合（因为有可能加多种调料，所以并不是两两组合），创建新的类，每个类定一个价格。这样做的话，会有无穷的类需要维护，而且如果加上一种新的调料或者咖啡，需要创建大量的类；另外，如果某个调料价格调整，需要修改大量类
2. 第二种方案，修改 `Beverage` 基类，添加多个实例变量来代表每一种调料是否添加了，然后在 `cost()` 方法根据实例变量状态动态计算价格。这样做的话，当有新的调料加入时，我们就需要修改`Beverage`基类添加新的实例变量并修改 `cost()` 方法,而且万一顾客需要双倍调料时，该设计也无法应对。

#### 装饰者模式解决方案
装饰者模式动态地将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的替代方案。
1. 装饰者和被装饰者对象有相同的超类型
2. 可以用一个或多个装饰者包装一个对象。
3. 既然装饰者和被装饰者对象有相同的超类型，所以任何需要原始包装对象的场合，都可以用装饰过的对象替代它
4. 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，已达到特定的目的
5. 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。

<center><img src="pics/plantuml/decorator-pattern.png" alt=""></center>

星巴兹饮料的订单系统设计：
<center><img src="pics/coffee.png" alt=""></center>

使用这种模式，我们能弹性地组合各种咖啡和调料：
```
Beverage a = new Milk(new Mocha(new Soy(new Whip(new Decaf())))); 加 whip/soy/mocha/milk 的 Decaf
Beverage a = new Milk(new Milk(new Espresso())); //双倍奶 Espresso
```

#### Java IO 的装饰者模式
<center><img src="pics/java-io.png" alt=""></center>

